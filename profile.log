SCRIPT  /private/var/folders/42/_q87rbb52w55zq_dddnjp2mr0000gn/T/nvimnI0L8n/coc.nvim-2655/coc-2655.vim
Sourced 2 times
Total time:   0.002403
 Self time:   0.002403

count  total (s)   self (s)

    2              0.000023 augroup coc_dynamic_autocmd
    2              0.002033   autocmd!
    2              0.000138   autocmd BufReadCmd,FileReadCmd,SourceCmd output://* call coc#rpc#request('CocAutocmd', ['BufReadCmd','output', expand('<amatch>')])
    2              0.000038   autocmd BufReadCmd,FileReadCmd,SourceCmd coc://* call coc#rpc#request('CocAutocmd', ['BufReadCmd','coc', expand('<amatch>')])
    2              0.000047   autocmd BufReadCmd,FileReadCmd,SourceCmd eslint-error://* call coc#rpc#request('CocAutocmd', ['BufReadCmd','eslint-error', expand('<amatch>')])
    2              0.000017   autocmd BufWritePre * call coc#rpc#request('doAutocmd', [1, +expand('<abuf>')])
    2              0.000018   autocmd OptionSet runtimepath call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])
    2              0.000038   autocmd OptionSet completeopt call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])
    2              0.000005 augroup end
SCRIPT  /Users/philippe/.vim/plugged/coc.nvim/autoload/coc/highlight.vim
Sourced 1 time
Total time:   0.000395
 Self time:   0.000395

count  total (s)   self (s)
    1              0.000014 let s:is_vim = !has('nvim')
    1              0.000008 let s:clear_match_by_window = has('nvim-0.5.0') || has('patch-8.1.1084')
    1              0.000003 let s:namespace_map = {}
    1              0.000002 let s:ns_id = 1

    1              0.000004 if has('nvim-0.5.0')
    1              0.000002   try
    1              0.000005     call getmatches(0)
                              catch /^Vim\%((\a\+)\)\=:E118/
                                let s:clear_match_by_window = 0
    1              0.000002   endtry
    1              0.000001 endif

                            " highlight LSP range,
    1              0.000005 function! coc#highlight#ranges(bufnr, key, hlGroup, ranges) abort
                              let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
                              if !bufloaded(bufnr) || !exists('*getbufline')
                                return
                              endif
                              let srcId = s:create_namespace(a:key)
                              for range in a:ranges
                                let start = range['start']
                                let end = range['end']
                                for lnum in range(start['line'] + 1, end['line'] + 1)
                                  let arr = getbufline(bufnr, lnum)
                                  let line = empty(arr) ? '' : arr[0]
                                  if empty(line)
                                    continue
                                  endif
                                  " TODO don't know how to count UTF16 code point, should work most cases.
                                  let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) : 0
                                  let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) : -1
                                  if colStart == colEnd
                                    continue
                                  endif
                                  call coc#highlight#add_highlight(bufnr, srcId, a:hlGroup, lnum - 1, colStart, colEnd)
                                endfor
                              endfor
                            endfunction

    1              0.000005 function! coc#highlight#add_highlight(bufnr, src_id, hl_group, line, col_start, col_end) abort
                              if has('nvim')
                                call nvim_buf_add_highlight(a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end)
                              else
                                call coc#api#call('buf_add_highlight', [a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end])
                              endif
                            endfunction

    1              0.000004 function! coc#highlight#clear_highlight(bufnr, key, start_line, end_line) abort
                              let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
                              if !bufloaded(bufnr)
                                return
                              endif
                              let src_id = s:create_namespace(a:key)
                              if has('nvim')
                                call nvim_buf_clear_namespace(a:bufnr, src_id, a:start_line, a:end_line)
                              else
                                call coc#api#call('buf_clear_namespace', [a:bufnr, src_id, a:start_line, a:end_line])
                              endif
                            endfunction

                            " highlight buffer in winid with CodeBlock &HighlightItems
                            " export interface HighlightItem {
                            "   lnum: number // 0 based
                            "   hlGroup: string
                            "   colStart: number // 0 based
                            "   colEnd: number
                            " }
                            " export interface CodeBlock {
                            "   filetype?: string
                            "   hlGroup?: string
                            "   startLine: number // 0 based
                            "   endLine: number
                            " }
    1              0.000003 function! coc#highlight#add_highlights(winid, codes, highlights) abort
                              " clear highlights
                              call coc#compat#execute(a:winid, 'syntax clear')
                              let bufnr = winbufnr(a:winid)
                              call coc#highlight#clear_highlight(bufnr, -1, 0, -1)
                              if !empty(a:codes)
                                call coc#highlight#highlight_lines(a:winid, a:codes)
                              endif
                              if !empty(a:highlights)
                                for item in a:highlights
                                  call coc#highlight#add_highlight(bufnr, -1, item['hlGroup'], item['lnum'], item['colStart'], item['colEnd'])
                                endfor
                              endif
                            endfunction


                            " Add highlights to line groups of winid, support hlGroup and filetype
                            " config should have startLine, endLine (1 based, end excluded) and filetype or hlGroup
                            " endLine should > startLine and endLine is excluded
                            "
                            " export interface CodeBlock {
                            "   filetype?: string
                            "   hlGroup?: string
                            "   startLine: number // 0 based
                            "   endLine: number
                            " }
    1              0.000003 function! coc#highlight#highlight_lines(winid, blocks) abort
                              let currwin = win_getid()
                              if has('nvim') && currwin != a:winid
                                noa call nvim_set_current_win(a:winid)
                              endif
                              let defined = []
                              let region_id = 1
                              for config in a:blocks
                                let start = config['startLine'] + 1
                                let end = config['endLine'] == -1 ? len(getbufline(winbufnr(a:winid), 1, '$')) + 1 : config['endLine'] + 1
                                let filetype = get(config, 'filetype', '')
                                let hlGroup = get(config, 'hlGroup', '')
                                if !empty(hlGroup)
                                  call s:execute(a:winid, 'syntax region '.hlGroup.' start=/\%'.start.'l/ end=/\%'.end.'l/')
                                else
                                  let filetype = matchstr(filetype, '\v[^.]*')
                                  if index(defined, filetype) == -1
                                    call s:execute(a:winid, 'syntax include @'.toupper(filetype).' syntax/'.filetype.'.vim')
                                    call add(defined, filetype)
                                  endif
                                  call s:execute(a:winid, 'syntax region CodeBlock'.region_id.' start=/\%'.start.'l/ end=/\%'.end.'l/ contains=@'.toupper(filetype))
                                  let region_id = region_id + 1
                                endif
                              endfor
                              if has('nvim')
                                noa call nvim_set_current_win(currwin)
                              endif
                            endfunction

                            " Copmpose hlGroups with foreground and background colors.
    1              0.000003 function! coc#highlight#compose_hlgroup(fgGroup, bgGroup) abort
                              let hlGroup = 'Fg'.a:fgGroup.'Bg'.a:bgGroup
                              if a:fgGroup == a:bgGroup
                                return a:fgGroup
                              endif
                              if hlexists(hlGroup)
                                return hlGroup
                              endif
                              let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'gui')
                              let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'gui')
                              if fg =~# '^#' || bg =~# '^#'
                                call s:create_gui_hlgroup(hlGroup, fg, bg, '')
                              else
                                let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'cterm')
                                let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'cterm')
                                call s:create_cterm_hlgroup(hlGroup, fg, bg, '')
                              endif
                              return hlGroup
                            endfunction

                            " add matches for winid, use 0 for current window.
    1              0.000003 function! coc#highlight#match_ranges(winid, bufnr, ranges, hlGroup, priority) abort
                              let winid = a:winid == 0 ? win_getid() : a:winid
                              let bufnr = a:bufnr == 0 ? winbufnr(winid) : a:bufnr
                              if empty(getwininfo(winid)) || (a:bufnr != 0 && winbufnr(a:winid) != a:bufnr)
                                " not valid
                                return []
                              endif
                              if !s:clear_match_by_window
                                let curr = win_getid()
                                if has('nvim')
                                  noa call nvim_set_current_win(winid)
                                else
                                  noa call win_gotoid(winid)
                                endif
                              endif
                              let ids = []
                              for range in a:ranges
                                let list = []
                                let start = range['start']
                                let end = range['end']
                                for lnum in range(start['line'] + 1, end['line'] + 1)
                                  let arr = getbufline(bufnr, lnum)
                                  let line = empty(arr) ? '' : arr[0]
                                  if empty(line)
                                    continue
                                  endif
                                  let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) + 1 : 1
                                  let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) + 1 : strlen(line) + 1
                                  if colStart == colEnd
                                    continue
                                  endif
                                  call add(list, [lnum, colStart, colEnd - colStart])
                                endfor
                                if !empty(list)
                                  let opts = s:clear_match_by_window ? {'window': a:winid} : {}
                                  let id = matchaddpos(a:hlGroup, list, a:priority, -1, opts)
                                  call add(ids, id)
                                endif
                              endfor
                              if !s:clear_match_by_window
                                if has('nvim')
                                  noa call nvim_set_current_win(curr)
                                else
                                  noa call win_gotoid(curr)
                                endif
                              endif
                              return ids
                            endfunction

                            " Clear matches by hlGroup regexp.
    1              0.000003 function! coc#highlight#clear_match_group(winid, match) abort
                              let winid = a:winid == 0 ? win_getid() : a:winid
                              if empty(getwininfo(winid))
                                " not valid
                                return
                              endif
                              if s:clear_match_by_window
                                let arr = filter(getmatches(winid), 'v:val["group"] =~# "'.a:match.'"')
                                for item in arr
                                  call matchdelete(item['id'], winid)
                                endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  let arr = filter(getmatches(), 'v:val["group"] =~# "'.a:match.'"')
                                  for item in arr
                                    call matchdelete(item['id'])
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
                              endif
                            endfunction

                            " Clear matches by match ids, use 0 for current win.
    1              0.000003 function! coc#highlight#clear_matches(winid, ids)
                              let winid = a:winid == 0 ? win_getid() : a:winid
                              if empty(getwininfo(winid))
                                " not valid
                                return
                              endif
                              if s:clear_match_by_window
                                for id in a:ids
                                  try
                                    call matchdelete(id, winid)
                                  catch /^Vim\%((\a\+)\)\=:E803/
                                    " ignore
                                  endtry
                                endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  for id in a:ids
                                    try
                                      call matchdelete(id)
                                    catch /^Vim\%((\a\+)\)\=:E803/
                                      " ignore
                                    endtry
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
                              endif
                            endfunction

                            " Sets the highlighting for the given group
    1              0.000005 function! s:create_gui_hlgroup(group, fg, bg, attr)
                              if a:fg != ""
                                exec "silent hi " . a:group . " guifg=" . a:fg . " ctermfg=" . coc#color#rgb2term(strpart(a:fg, 1))
                              endif
                              if a:bg != ""
                                exec "silent hi " . a:group . " guibg=" . a:bg . " ctermbg=" . coc#color#rgb2term(strpart(a:bg, 1))
                              endif
                              if a:attr != ""
                                exec "silent hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
                              endif
                            endfun

    1              0.000003 function! s:create_cterm_hlgroup(group, fg, bg, attr) abort
                              if a:fg != ""
                                exec "silent hi " . a:group . " ctermfg=" . a:fg
                              endif
                              if a:bg != ""
                                exec "silent hi " . a:group . " ctermbg=" . a:bg
                              endif
                              if a:attr != ""
                                exec "silent hi " . a:group . " cterm=" . a:attr
                              endif
                            endfunction

    1              0.000002 function! s:execute(winid, cmd) abort
                              if has('nvim')
                                execute 'silent! ' a:cmd
                              else
                                call win_execute(a:winid, a:cmd, 'silent!')
                              endif
                            endfunction

    1              0.000002 function! s:create_namespace(key) abort
                              if type(a:key) == 0
                                return a:key
                              endif
                              if has('nvim')
                                return nvim_create_namespace('coc-'.a:key)
                              endif
                              if !has_key(s:namespace_map, a:key)
                                let s:namespace_map[a:key] = s:ns_id
                                let s:ns_id = s:ns_id + 1
                              endif
                              return s:namespace_map[a:key]
                            endfunction

SCRIPT  /Users/philippe/.vim/plugged/vimspector/autoload/vimspector.vim
Sourced 1 time
Total time:   0.001343
 Self time:   0.000635

count  total (s)   self (s)
                            " vimspector - A multi-language debugging system for Vim
                            " Copyright 2018 Ben Jackson
                            "
                            " Licensed under the Apache License, Version 2.0 (the "License");
                            " you may not use this file except in compliance with the License.
                            " You may obtain a copy of the License at
                            "
                            "   http://www.apache.org/licenses/LICENSE-2.0
                            "
                            " Unless required by applicable law or agreed to in writing, software
                            " distributed under the License is distributed on an "AS IS" BASIS,
                            " WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                            " See the License for the specific language governing permissions and
                            " limitations under the License.


                            " Boilerplate {{{
    1              0.000010 let s:save_cpo = &cpoptions
    1              0.000011 set cpoptions&vim
                            " }}}

    1              0.000005 function! s:Debug( ... ) abort
                              py3 <<EOF
                            if _vimspector_session is not None:
                              _vimspector_session._logger.debug( *vim.eval( 'a:000' ) )
                            EOF
                            endfunction


    1              0.000003 let s:enabled = v:null

    1              0.000002 function! s:Initialised() abort
                              return s:enabled != v:null
                            endfunction

    1              0.000002 function! s:Enabled() abort
                              if !s:Initialised()
                                let s:enabled = vimspector#internal#state#Reset()
                              endif

                              return s:enabled
                            endfunction

    1              0.000002 function! vimspector#Launch() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Start()
                            endfunction

    1              0.000003 function! vimspector#LaunchWithSettings( settings ) abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Start( launch_variables = vim.eval( 'a:settings' ) )
                            endfunction

    1              0.000002 function! vimspector#Reset() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Reset()
                            endfunction

    1              0.000002 function! vimspector#Restart() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Restart()
                            endfunction

    1              0.000002 function! vimspector#ClearBreakpoints() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ClearBreakpoints()
                            endfunction

    1              0.000002 function! vimspector#ToggleBreakpoint( ... ) abort
                              if !s:Enabled()
                                return
                              endif
                              if a:0 == 0
                                let options = {}
                              else
                                let options = a:1
                              endif
                              py3 _vimspector_session.ToggleBreakpoint( vim.eval( 'options' ) )
                            endfunction

    1              0.000003 function! vimspector#SetLineBreakpoint( file_name, line_num, ... ) abort
                              if !s:Enabled()
                                return
                              endif
                              if a:0 == 0
                                let options = {}
                              else
                                let options = a:1
                              endif
                              py3 _vimspector_session.SetLineBreakpoint(
                                    \ vim.eval( 'a:file_name' ),
                                    \ int( vim.eval( 'a:line_num' ) ),
                                    \ vim.eval( 'options' ) )
                            endfunction

    1              0.000003 function! vimspector#ClearLineBreakpoint( file_name, line_num ) abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ClearLineBreakpoint(
                                    \ vim.eval( 'a:file_name' ),
                                    \ int( vim.eval( 'a:line_num' ) ) )
                            endfunction


    1              0.000002 function! vimspector#RunToCursor() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.RunTo(
                                    \ vim.eval( "expand( '%' )" ),
                                    \ int( vim.eval( "line( '.' )" ) ) )
                            endfunction


    1              0.000002 function! vimspector#AddFunctionBreakpoint( function, ... ) abort
                              if !s:Enabled()
                                return
                              endif
                              if a:0 == 0
                                let options = {}
                              else
                                let options = a:1
                              endif
                              py3 _vimspector_session.AddFunctionBreakpoint( vim.eval( 'a:function' ),
                                                                           \ vim.eval( 'options' ) )
                            endfunction

    1              0.000002 function! vimspector#StepOver() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.StepOver()
                            endfunction

    1              0.000002 function! vimspector#StepInto() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.StepInto()
                            endfunction

    1              0.000002 function! vimspector#StepOut() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.StepOut()
                            endfunction

    1              0.000002 function! vimspector#Continue() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Continue()
                            endfunction

    1              0.000002 function! vimspector#Pause() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Pause()
                            endfunction

    1              0.000002 function! vimspector#PauseContinueThread() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.PauseContinueThread()
                            endfunction

    1              0.000002 function! vimspector#SetCurrentThread() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.SetCurrentThread()
                            endfunction

    1              0.000002 function! vimspector#Stop() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.Stop()
                            endfunction

    1              0.000002 function! vimspector#ExpandVariable() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ExpandVariable()
                            endfunction

    1              0.000002 function! vimspector#DeleteWatch() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.DeleteWatch()
                            endfunction

    1              0.000002 function! vimspector#GoToFrame() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ExpandFrameOrThread()
                            endfunction

    1              0.000002 function! vimspector#AddWatch( ... ) abort
                              if !s:Enabled()
                                return
                              endif
                              if a:0 == 0
                                let expr = input( 'Enter watch expression: ' )
                              else
                                let expr = a:1
                              endif

                              if expr ==# ''
                                return
                              endif

                              py3 _vimspector_session.AddWatch( vim.eval( 'expr' ) )
                            endfunction

    1              0.000002 function! vimspector#AddWatchPrompt( expr ) abort
                              if !s:Enabled()
                                return
                              endif
                              stopinsert
                              setlocal nomodified
                              call vimspector#AddWatch( a:expr )
                            endfunction

    1              0.000002 function! vimspector#Evaluate( expr ) abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ShowOutput( 'Console' )
                              py3 _vimspector_session.EvaluateConsole( vim.eval( 'a:expr' ), True )
                            endfunction

    1              0.000002 function! vimspector#EvaluateConsole( expr ) abort
                              if !s:Enabled()
                                return
                              endif
                              stopinsert
                              setlocal nomodified
                              py3 _vimspector_session.EvaluateConsole( vim.eval( 'a:expr' ), False )
                            endfunction

    1              0.000002 function! vimspector#ShowOutput( ... ) abort
                              if !s:Enabled()
                                return
                              endif
                              if a:0 == 1
                                py3 _vimspector_session.ShowOutput( vim.eval( 'a:1' ) )
                              else
                                py3 _vimspector_session.ShowOutput( 'Console' )
                              endif
                            endfunction

    1              0.000003 function! vimspector#ShowOutputInWindow( win_id, category ) abort
                              if !s:Enabled()
                                return
                              endif
                              py3 __import__( 'vimspector',
                                    \         fromlist = [ 'output' ] ).output.ShowOutputInWindow(
                                    \           int( vim.eval( 'a:win_id' ) ),
                                    \           vim.eval( 'a:category' ) )
                            endfunction

    1              0.000002 function! vimspector#ToggleLog() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ToggleLog()
                            endfunction

    1              0.000002 function! vimspector#ListBreakpoints() abort
                              if !s:Enabled()
                                return
                              endif
                              py3 _vimspector_session.ListBreakpoints()
                            endfunction

    1              0.000002 function! vimspector#GetConfigurations() abort
                              if !s:Enabled()
                                return
                              endif
                              let configurations = py3eval(
                                    \ 'list( _vimspector_session.GetConfigurations( {} )[ 1 ].keys() )'
                                    \ . ' if _vimspector_session else []' )
                              return configurations
                            endfunction

    1              0.000003 function! vimspector#CompleteOutput( ArgLead, CmdLine, CursorPos ) abort
                              if !s:Enabled()
                                return
                              endif
                              let buffers = py3eval( '_vimspector_session.GetOutputBuffers() '
                                                   \ . ' if _vimspector_session else []' )
                              return join( buffers, "\n" )
                            endfunction

    1              0.000002 py3 <<EOF
                            def _vimspector_GetExprCompletions( ArgLead, prev_non_keyword_char ):
                              if not _vimspector_session:
                                return []

                              items = []
                              for candidate in _vimspector_session.GetCompletionsSync(
                                ArgLead,
                                prev_non_keyword_char ):

                                label = candidate.get( 'text', candidate[ 'label' ] )

                                start = prev_non_keyword_char - 1

                                if 'start' in candidate and 'length' in candidate:
                                  start = candidate[ 'start' ]

                                items.append( ArgLead[ 0 : start ] + label )

                              return items
                            EOF

    1              0.000007 function! vimspector#CompleteExpr( ArgLead, CmdLine, CursorPos ) abort
                              if !s:Enabled()
                                return
                              endif

                              let col = len( a:ArgLead )
                              let prev_non_keyword_char = match( a:ArgLead[ 0 : col - 1 ], '\k*$' ) + 1

                              return join( py3eval( '_vimspector_GetExprCompletions( '
                                                  \ . 'vim.eval( "a:ArgLead" ), '
                                                  \ . 'int( vim.eval( "prev_non_keyword_char" ) ) )' ),
                                         \ "\n" )
                            endfunction

    1              0.000006 let s:latest_completion_request = {}

    1              0.000003 function! vimspector#CompleteFuncSync( prompt, find_start, query ) abort
                              if py3eval( 'not _vimspector_session' )
                                if a:find_start
                                  return -3
                                endif
                                return v:none
                              endif

                              if a:find_start

                                " We're busy
                                if !empty( s:latest_completion_request )
                                  return -3
                                endif

                                let line = getline( line( '.' ) )[ len( a:prompt ) : ]
                                let col = col( '.' ) - len( a:prompt )

                                " It seems that most servers don't implement the 'start' parameter, which is
                                " clearly necessary, as they all seem to assume a specific behaviour, which
                                " is undocumented.

                                let s:latest_completion_request.items =
                                      \ py3eval( '_vimspector_session.GetCompletionsSync( '
                                               \.'  vim.eval( "line" ), '
                                               \.'  int( vim.eval( "col" ) ) )' )

                                let s:latest_completion_request.line = line
                                let s:latest_completion_request.col = col

                                let prev_non_keyword_char = match( line[ 0 : col - 1 ], '\k*$' ) + 1
                                let query_len = col - prev_non_keyword_char

                                let start_pos = col
                                for item in s:latest_completion_request.items
                                  if !has_key( item, 'start' ) || !has_key( item, 'length' )
                                    " The specification states that if start is not supplied, isertion
                                    " should be at the requested column. But about 0 of the servers actually
                                    " implement that
                                    " (https://github.com/microsoft/debug-adapter-protocol/issues/138)
                                    let item.start = prev_non_keyword_char
                                    let item.length = query_len
                                  else
                                    " For some reason, the returned start value is 0-indexed even though we
                                    " use columnsStartAt1
                                    let item.start += 1
                                  endif

                                  if !has_key( item, 'text' )
                                    let item.text = item.label
                                  endif

                                  if item.start < start_pos
                                    let start_pos = item.start
                                  endif
                                endfor

                                let s:latest_completion_request.start_pos = start_pos
                                let s:latest_completion_request.prompt = a:prompt

                                " call s:Debug( 'FindStart: %s', {
                                "       \ 'line': line,
                                "       \ 'col': col,
                                "       \ 'prompt': len( a:prompt ),
                                "       \ 'start_pos': start_pos,
                                "       \ 'returning': ( start_pos + len( a:prompt ) ) - 1,
                                "       \ } )

                                " start_pos is 1-based and the return of findstart is 0-based
                                return ( start_pos + len( a:prompt ) ) - 1
                              else
                                let items = []
                                let pfxlen = len( s:latest_completion_request.prompt )
                                for item in s:latest_completion_request.items
                                  if item.start > s:latest_completion_request.start_pos
                                    " fix up the text (insert anything that is already present in the line
                                    " that would be erased by the fixed-up earlier start position)
                                    "
                                    " both start_pos and item.start are 1-based
                                    let item.text = s:latest_completion_request.line[
                                          \ s:latest_completion_request.start_pos + pfxlen - 1 :
                                          \  item.start + pfxlen - 1 ] . item.text
                                  endif

                                  if item.length > len( a:query )
                                    " call s:Debug( 'Rejecting %s, length is greater than %s',
                                    "       \ item,
                                    "       \ len( a:query ) )
                                    continue
                                  endif

                                  call add( items, { 'word': item.text,
                                                   \ 'abbr': item.label,
                                                   \ 'menu': get( item, 'type', '' ),
                                                   \ 'icase': 1,
                                                   \ } )
                                endfor
                                let s:latest_completion_request = {}

                                " call s:Debug( 'Items: %s', items )
                                return { 'words': items, 'refresh': 'always' }
                              endif
                            endfunction

    1              0.000003 function! vimspector#OmniFuncWatch( find_start, query ) abort
                              return vimspector#CompleteFuncSync( 'Expression: ', a:find_start, a:query )
                            endfunction

    1              0.000003 function! vimspector#OmniFuncConsole( find_start, query ) abort
                              return vimspector#CompleteFuncSync( '> ', a:find_start, a:query )
                            endfunction

    1              0.000002 function! vimspector#Install( bang, ... ) abort
                              if !s:Enabled()
                                return
                              endif
                              let prefix = vimspector#internal#state#GetAPIPrefix()
                              py3 __import__( 'vimspector',
                                    \         fromlist = [ 'installer' ] ).installer.RunInstaller(
                                    \           vim.eval( 'prefix' ),
                                    \           vim.eval( 'a:bang' ) == '!',
                                    \           *vim.eval( 'a:000' ) )
                            endfunction

    1              0.000003 function! vimspector#CompleteInstall( ArgLead, CmdLine, CursorPos ) abort
                              if !s:Enabled()
                                return
                              endif
                              return py3eval( '"\n".join('
                                            \ .   '__import__( "vimspector", fromlist = [ "gadgets" ] )'
                                            \ .   '.gadgets.GADGETS.keys() '
                                            \ . ')' )
                            endfunction

    1              0.000002 function! vimspector#Update( bang, ... ) abort
                              if !s:Enabled()
                                return
                              endif

                              let prefix = vimspector#internal#state#GetAPIPrefix()
                              py3 __import__( 'vimspector',
                                    \         fromlist = [ 'installer' ] ).installer.RunUpdate(
                                    \           vim.eval( 'prefix' ),
                                    \           vim.eval( 'a:bang' ) == '!',
                                    \           *vim.eval( 'a:000' ) )
                            endfunction

    1              0.000002 function! vimspector#AbortInstall() abort
                              if !s:Enabled()
                                return
                              endif

                              let prefix = vimspector#internal#state#GetAPIPrefix()
                              py3 __import__( 'vimspector', fromlist = [ 'installer' ] ).installer.Abort()
                            endfunction


    1              0.000002 function! vimspector#OnBufferCreated( file_name ) abort
                              if len( a:file_name ) == 0
                                return
                              endif

                              " Don't actually load up vimsepctor python in autocommands that trigger
                              " regularly. We'll only create the session obkect in s:Enabled()
                              if !s:Initialised()
                                return
                              endif

                              if !s:Enabled()
                                return
                              endif

                              py3 _vimspector_session.RefreshSigns( vim.eval( 'a:file_name' ) )
                            endfunction


                            " Boilerplate {{{
    1              0.000011 let &cpoptions=s:save_cpo
    1              0.000003 unlet s:save_cpo
                            " }}}

SCRIPT  /usr/local/Cellar/neovim/HEAD-759a054/share/nvim/runtime/scripts.vim
Sourced 2 times
Total time:   0.006425
 Self time:   0.006425

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2020 Jun 07

                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            "
                            " Note that the pattern matches are done with =~# to avoid the value of the
                            " 'ignorecase' option making a difference.  Where case is to be ignored use
                            " =~? instead.  Do not use =~ anywhere.


                            " Only do the rest when the FileType autocommand has not been triggered yet.
    2              0.000022 if did_filetype()
                              finish
    2              0.000002 endif

                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    2              0.000015 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
    2              0.000002 endif

                            " Line continuation is used here, remove 'C' from 'cpoptions'
    2              0.000024 let s:cpo_save = &cpo
    2              0.000026 set cpo&vim

    2              0.000011 let s:line1 = getline(1)

    2              0.000019 if s:line1 =~# "^#!"
                              " A script that starts with "#!".

                              " Check for a line like "#!/usr/bin/env {options} bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              " Recognize only a few {options} that are commonly used.
                              if s:line1 =~# '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\(-[iS]\|--ignore-environment\|--split-string\)', '', '')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif

                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~# '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif

                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~# '^exec wish'
                                let s:name = 'wish'
                              endif

                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~# '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim

                                " csh scripts
                              elseif s:name =~# '^csh\>'
                                if exists("g:filetype_csh")
                                  call dist#ft#SetFileTypeShell(g:filetype_csh)
                                else
                                  call dist#ft#SetFileTypeShell("csh")
                                endif

                                " tcsh scripts
                              elseif s:name =~# '^tcsh\>'
                                call dist#ft#SetFileTypeShell("tcsh")

                                " Z shell scripts
                              elseif s:name =~# '^zsh\>'
                                set ft=zsh

                                " TCL scripts
                              elseif s:name =~# '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl

                                " Expect scripts
                              elseif s:name =~# '^expect\>'
                                set ft=expect

                                " Gnuplot scripts
                              elseif s:name =~# '^gnuplot\>'
                                set ft=gnuplot

                                " Makefiles
                              elseif s:name =~# 'make\>'
                                set ft=make

                                " Pike
                              elseif s:name =~# '^pike\%(\>\|[0-9]\)'
                                set ft=pike

                                " Lua
                              elseif s:name =~# 'lua'
                                set ft=lua

                                " Perl 6
                              elseif s:name =~# 'perl6'
                                set ft=perl6

                                " Perl
                              elseif s:name =~# 'perl'
                                set ft=perl

                                " PHP
                              elseif s:name =~# 'php'
                                set ft=php

                                " Python
                              elseif s:name =~# 'python'
                                set ft=python

                                " Groovy
                              elseif s:name =~# '^groovy\>'
                                set ft=groovy

                                " Ruby
                              elseif s:name =~# 'ruby'
                                set ft=ruby

                                " JavaScript
                              elseif s:name =~# 'node\(js\)\=\>\|js\>' || s:name =~# 'rhino\>'
                                set ft=javascript

                                " BC calculator
                              elseif s:name =~# '^bc\>'
                                set ft=bc

                                " sed
                              elseif s:name =~# 'sed\>'
                                set ft=sed

                                " OCaml-scripts
                              elseif s:name =~# 'ocaml'
                                set ft=ocaml

                                " Awk scripts
                              elseif s:name =~# 'awk\>'
                                set ft=awk

                                " Website MetaLanguage
                              elseif s:name =~# 'wml'
                                set ft=wml

                                " Scheme scripts
                              elseif s:name =~# 'scheme'
                                set ft=scheme

                                " CFEngine scripts
                              elseif s:name =~# 'cfengine'
                                set ft=cfengine

                                " Erlang scripts
                              elseif s:name =~# 'escript'
                                set ft=erlang

                                " Haskell
                              elseif s:name =~# 'haskell'
                                set ft=haskell

                                " Scala
                              elseif s:name =~# 'scala\>'
                                set ft=scala

                                " Clojure
                              elseif s:name =~# 'clojure'
                                set ft=clojure

                              endif
                              unlet s:name

    2              0.000005 else
                              " File does not start with "#!".

    2              0.000023   let s:line2 = getline(2)
    2              0.000010   let s:line3 = getline(3)
    2              0.000008   let s:line4 = getline(4)
    2              0.000008   let s:line5 = getline(5)

                              " Bourne-like shell scripts: sh ksh bash bash2
    2              0.000026   if s:line1 =~# '^:$'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim

                              " Z shell scripts
    2              0.000097   elseif s:line1 =~# '^#compdef\>' || s:line1 =~# '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~# '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh

                              " ELM Mail files
    2              0.000038   elseif s:line1 =~# '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail

                              " Mason
    2              0.000015   elseif s:line1 =~# '^<[%&].*>'
                                set ft=mason

                              " Vim scripts (must have '" vim' as the first line to trigger this)
    2              0.000013   elseif s:line1 =~# '^" *[vV]im$'
                                set ft=vim

                              " libcxx and libstdc++ standard library headers like "iostream" do not have
                              " an extension, recognize the Emacs file mode.
    2              0.000015   elseif s:line1 =~? '-\*-.*C++.*-\*-'
                                set ft=cpp

                              " MOO
    2              0.000035   elseif s:line1 =~# '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo

                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                " - "# HG changeset patch" in first line (Mercurial export format)
    2              0.000178   elseif s:line1 =~# '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	\ || (s:line1 =~# '^--- ' && s:line2 =~# '^+++ ')
                            	\ || (s:line1 =~# '^\* looking for ' && s:line2 =~# '^\* comparing to ')
                            	\ || (s:line1 =~# '^\*\*\* ' && s:line2 =~# '^--- ')
                            	\ || (s:line1 =~# '^=== ' && ((s:line2 =~# '^=\{66\}' && s:line3 =~# '^--- ' && s:line4 =~# '^+++') || (s:line2 =~# '^--- ' && s:line3 =~# '^+++ ')))
                            	\ || (s:line1 =~# '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff

                                " PostScript Files (must have %!PS as the first line, like a2ps output)
    2              0.000015   elseif s:line1 =~# '^%![ \t]*PS'
                                set ft=postscr

                                " M4 scripts: Guess there is a line that starts with "dnl".
    2              0.000060   elseif s:line1 =~# '^\s*dnl\>'
                            	\ || s:line2 =~# '^\s*dnl\>'
                            	\ || s:line3 =~# '^\s*dnl\>'
                            	\ || s:line4 =~# '^\s*dnl\>'
                            	\ || s:line5 =~# '^\s*dnl\>'
                                set ft=m4

                                " AmigaDos scripts
    2              0.000015   elseif $TERM == "amiga"
                            	\ && (s:line1 =~# "^;" || s:line1 =~? '^\.bra')
                                set ft=amiga

                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
    2              0.000018   elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad

                                " Purify log files start with "****  Purify"
    2              0.000015   elseif s:line1 =~# '^\*\*\*\*  Purify'
                                set ft=purifylog

                                " XML
    2              0.000014   elseif s:line1 =~# '<?\s*xml.*?>'
                                set ft=xml

                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
    2              0.000014   elseif s:line1 =~# '\<DTD\s\+XHTML\s'
                                set ft=xhtml

                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                " Avoid "doctype html", used by slim.
    2              0.000016   elseif s:line1 =~? '<!DOCTYPE\s\+html\>'
                                set ft=html

                                " PDF
    2              0.000011   elseif s:line1 =~# '^%PDF-'
                                set ft=pdf

                                " XXD output
    2              0.000043   elseif s:line1 =~# '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd

                                " RCS/CVS log output
    2              0.000023   elseif s:line1 =~# '^RCS file:' || s:line2 =~# '^RCS file:'
                                set ft=rcslog

                                " CVS commit
    2              0.000025   elseif s:line2 =~# '^CVS:' || getline("$") =~# '^CVS: '
                                set ft=cvs

                                " Prescribe
    2              0.000010   elseif s:line1 =~# '^!R!'
                                set ft=prescribe

                                " Send-pr
    2              0.000014   elseif s:line1 =~# '^SEND-PR:'
                                set ft=sendpr

                                " SNNS files
    2              0.000020   elseif s:line1 =~# '^SNNS network definition file'
                                set ft=snnsnet
    2              0.000019   elseif s:line1 =~# '^SNNS pattern definition file'
                                set ft=snnspat
    2              0.000034   elseif s:line1 =~# '^SNNS result file'
                                set ft=snnsres

                                " Virata
    2              0.000107   elseif s:line1 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~# '^%.\{-}[Vv]irata'
                                set ft=virata

                                " Strace
    2              0.000043   elseif s:line1 =~# '[0-9:.]* *execve(' || s:line1 =~# '^__libc_start_main'
                                set ft=strace

                                " VSE JCL
    2              0.000025   elseif s:line1 =~# '^\* $$ JOB\>' || s:line1 =~# '^// *JOB\>'
                                set ft=vsejcl

                                " TAK and SINDA
    2              0.000027   elseif s:line4 =~# 'K & K  Associates' || s:line2 =~# 'TAK 2000'
                                set ft=takout
    2              0.000024   elseif s:line3 =~# 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
    2              0.000019   elseif getline(6) =~# 'Run Date: '
                                set ft=takcmp
    2              0.000018   elseif getline(9) =~# 'Node    File  1'
                                set ft=sindacmp

                                " DNS zone files
    2              0.000093   elseif s:line1.s:line2.s:line3.s:line4 =~# '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone

                                " BAAN
    2              0.000093   elseif s:line1 =~# '|\*\{1,80}' && s:line2 =~# 'VRC '
                            	\ || s:line2 =~# '|\*\{1,80}' && s:line3 =~# 'VRC '
                                set ft=baan

                              " Valgrind
    2              0.000031   elseif s:line1 =~# '^==\d\+== valgrind' || s:line3 =~# '^==\d\+== Using valgrind'
                                set ft=valgrind

                              " Go docs
    2              0.000018   elseif s:line1 =~# '^PACKAGE DOCUMENTATION$'
                                set ft=godoc

                              " Renderman Interface Bytestream
    2              0.000013   elseif s:line1 =~# '^##RenderMan'
                                set ft=rib

                              " Scheme scripts
    2              0.000029   elseif s:line1 =~# 'exec\s\+\S*scheme' || s:line2 =~# 'exec\s\+\S*scheme'
                                set ft=scheme

                              " Git output
    2              0.000051   elseif s:line1 =~# '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git

                               " Gprof (gnu profiler)
    2              0.000014    elseif s:line1 == 'Flat profile:'
                                 \ && s:line2 == ''
                                 \ && s:line3 =~# '^Each sample counts as .* seconds.$'
                                 set ft=gprof

                              " Erlang terms
                              " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
    2              0.000017   elseif s:line1 =~? '-\*-.*erlang.*-\*-'
                                set ft=erlang

                              " YAML
    2              0.000011   elseif s:line1 =~# '^%YAML'
                                set ft=yaml

                              " CVS diff
    2              0.000003   else
    2              0.000010     let s:lnum = 1
    2              0.000023     while getline(s:lnum) =~# "^? " && s:lnum < line("$")
                                  let s:lnum += 1
    2              0.000006     endwhile
    2              0.000019     if getline(s:lnum) =~# '^Index:\s\+\f\+$'
                                  set ft=diff

                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
    2              0.000065     elseif expand("%") =~# '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~# '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
    2              0.000003     endif
    2              0.000007     unlet s:lnum

    2              0.000003   endif

    2              0.000009   unlet s:line2 s:line3 s:line4 s:line5

    2              0.000003 endif

                            " Restore 'cpoptions'
    2              0.000039 let &cpo = s:cpo_save

    2              0.000019 unlet s:cpo_save s:line1

SCRIPT  /Users/philippe/.vim/plugged/nerdtree/syntax/nerdtree.vim
Sourced 1 time
Total time:   0.004296
 Self time:   0.004296

count  total (s)   self (s)
    1              0.000021 let s:tree_up_dir_line = '.. (up a dir)'
    1              0.000062 syn match NERDTreeIgnore #\~#
    1              0.000016 exec 'syn match NERDTreeIgnore #\['.g:NERDTreeGlyphReadOnly.'\]#'

                            "highlighting for the .. (up dir) line at the top of the tree
    1              0.000021 execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line .'#'

                            "quickhelp syntax elements
    1              0.000024 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#ms=s+2,me=e-1
    1              0.000005 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#ms=s+2,me=e-1
    1              0.000022 syn match NERDTreeHelpTitle #" .*\~$#ms=s+2,me=e-1
    1              0.000021 syn match NERDTreeToggleOn #(on)#ms=s+1,he=e-1
    1              0.000015 syn match NERDTreeToggleOff #(off)#ms=e-3,me=e-1
    1              0.000021 syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
    1              0.000063 syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeIgnore,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand

                            "highlighting for sym links
    1              0.000057 syn match NERDTreeLinkTarget #->.*# containedin=NERDTreeDir,NERDTreeFile
    1              0.000036 syn match NERDTreeLinkFile #.* ->#me=e-3 containedin=NERDTreeFile
    1              0.000042 syn match NERDTreeLinkDir #.*/ ->#me=e-3 containedin=NERDTreeDir

                            "highlighting to conceal the delimiter around the file/dir name
    1              0.000008 if has('conceal')
    1              0.000034     exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# conceal containedin=ALL'
    1              0.000020     setlocal conceallevel=2 concealcursor=nvic
                            else
                                exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# containedin=ALL'
                                hi! link NERDTreeNodeDelimiters Ignore
    1              0.000001 endif

                            "highlighing for directory nodes and file nodes
    1              0.000036 syn match NERDTreeDirSlash #/# containedin=NERDTreeDir

    1              0.000004 if g:NERDTreeDirArrowExpandable !=# ''
    1              0.000067     exec 'syn match NERDTreeClosable #' . escape(g:NERDTreeDirArrowCollapsible, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
    1              0.000067     exec 'syn match NERDTreeOpenable #' . escape(g:NERDTreeDirArrowExpandable, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
    1              0.000011     let s:dirArrows = escape(g:NERDTreeDirArrowCollapsible, '~]\-').escape(g:NERDTreeDirArrowExpandable, '~]\-')
    1              0.000021     exec 'syn match NERDTreeDir #[^'.s:dirArrows.' ].*/#'
    1              0.000056     exec 'syn match NERDTreeExecFile #^.*'.g:NERDTreeNodeDelimiter.'\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmark'
    1              0.000068     exec 'syn match NERDTreeFile  #^[^"\.'.s:dirArrows.'] *[^'.s:dirArrows.']*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile'
                            else
                                exec 'syn match NERDTreeDir #[^'.g:NERDTreeNodeDelimiter.']\{-}/\ze\($\|'.g:NERDTreeNodeDelimiter.'\)#'
                                exec 'syn match NERDTreeExecFile #[^'.g:NERDTreeNodeDelimiter.']\{-}'.g:NERDTreeNodeDelimiter.'\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmark'
                                exec 'syn match NERDTreeFile     #^.*'.g:NERDTreeNodeDelimiter.'.*[^\/]\($\|'.g:NERDTreeNodeDelimiter.'.*\)# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile'
    1              0.000001 endif

                            "highlighting for readonly files
    1              0.000042 exec 'syn match NERDTreeRO #.*'.g:NERDTreeNodeDelimiter.'\zs.*\ze'.g:NERDTreeNodeDelimiter.'.*\['.g:NERDTreeGlyphReadOnly.'\]# contains=NERDTreeIgnore,NERDTreeBookmark,NERDTreeFile'

    1              0.000107 exec 'syn match NERDTreeFlags #\[[^\]]*\]\ze'.g:NERDTreeNodeDelimiter.'# containedin=NERDTreeFile,NERDTreeExecFile,NERDTreeLinkFile,NERDTreeRO,NERDTreeDir'

    1              0.000015 syn match NERDTreeCWD #^[</].*$#

                            "highlighting for bookmarks
    1              0.000008 syn match NERDTreeBookmark # {.*}#hs=s+1

                            "highlighting for the bookmarks table
    1              0.000020 syn match NERDTreeBookmarksLeader #^>#
    1              0.000025 syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
    1              0.000023 syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
    1              0.000010 syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader

    1              0.000032 hi def link NERDTreePart Special
    1              0.000032 hi def link NERDTreePartFile Type
    1              0.000027 hi def link NERDTreeExecFile Title
    1              0.000027 hi def link NERDTreeDirSlash Identifier

    1              0.000016 hi def link NERDTreeBookmarksHeader statement
    1              0.000016 hi def link NERDTreeBookmarksLeader ignore
    1              0.000017 hi def link NERDTreeBookmarkName Identifier
    1              0.000017 hi def link NERDTreeBookmark normal

    1              0.000026 hi def link NERDTreeHelp String
    1              0.000017 hi def link NERDTreeHelpKey Identifier
    1              0.000017 hi def link NERDTreeHelpCommand Identifier
    1              0.000016 hi def link NERDTreeHelpTitle Macro
    1              0.000027 hi def link NERDTreeToggleOn Question
    1              0.000027 hi def link NERDTreeToggleOff WarningMsg

    1              0.001322 hi def link NERDTreeLinkTarget Type
    1              0.000029 hi def link NERDTreeLinkFile Macro
    1              0.000017 hi def link NERDTreeLinkDir Macro

    1              0.000030 hi def link NERDTreeDir Directory
    1              0.000029 hi def link NERDTreeUp Directory
    1              0.000029 hi def link NERDTreeFile Normal
    1              0.000027 hi def link NERDTreeCWD Statement
    1              0.000029 hi def link NERDTreeOpenable Directory
    1              0.000029 hi def link NERDTreeClosable Directory
    1              0.000017 hi def link NERDTreeIgnore ignore
    1              0.000018 hi def link NERDTreeRO WarningMsg
    1              0.000017 hi def link NERDTreeBookmark Statement
    1              0.000028 hi def link NERDTreeFlags Number

    1              0.000036 hi def link NERDTreeCurrentNode Search

    1              0.000031 hi NERDTreeFile ctermbg=NONE guibg=NONE

SCRIPT  /Users/philippe/.vim/plugged/fzf.vim/autoload/fzf/vim.vim
Sourced 1 time
Total time:   0.009176
 Self time:   0.008839

count  total (s)   self (s)
                            " Copyright (c) 2017 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    1              0.000019 let s:cpo_save = &cpo
    1   0.000025   0.000016 set cpo&vim

                            " ------------------------------------------------------------------
                            " Common
                            " ------------------------------------------------------------------

    1              0.000004 let s:min_version = '0.23.0'
    1              0.000011 let s:is_win = has('win32') || has('win64')
    1              0.000005 let s:layout_keys = ['window', 'up', 'down', 'left', 'right']
    1              0.000049 let s:bin_dir = expand('<sfile>:p:h:h:h').'/bin/'
    1              0.000011 let s:bin = {
                            \ 'preview': s:bin_dir.'preview.sh',
                            \ 'tags':    s:bin_dir.'tags.pl' }
    1              0.000015 let s:TYPE = {'dict': type({}), 'funcref': type(function('call')), 'string': type(''), 'list': type([])}
    1              0.000002 if s:is_win
                              if has('nvim')
                                let s:bin.preview = split(system('for %A in ("'.s:bin.preview.'") do @echo %~sA'), "\n")[0]
                              else
                                let s:bin.preview = fnamemodify(s:bin.preview, ':8')
                              endif
    1              0.000001 endif

    1              0.000003 let s:wide = 120
    1              0.000002 let s:warned = 0
    1              0.000002 let s:checked = 0

    1              0.000006 function! s:version_requirement(val, min)
                              let val = split(a:val, '\.')
                              let min = split(a:min, '\.')
                              for idx in range(0, len(min) - 1)
                                let v = get(val, idx, 0)
                                if     v < min[idx] | return 0
                                elseif v > min[idx] | return 1
                                endif
                              endfor
                              return 1
                            endfunction

    1              0.000003 function! s:check_requirements()
                              if s:checked
                                return
                              endif

                              if !exists('*fzf#run')
                                throw "fzf#run function not found. You also need Vim plugin from the main fzf repository (i.e. junegunn/fzf *and* junegunn/fzf.vim)"
                              endif
                              if !exists('*fzf#exec')
                                throw "fzf#exec function not found. You need to upgrade Vim plugin from the main fzf repository ('junegunn/fzf')"
                              endif
                              let exec = fzf#exec()
                              let output = split(system(exec . ' --version'), "\n")
                              if v:shell_error || empty(output)
                                throw 'Failed to run "fzf --version": ' . string(output)
                              endif
                              let fzf_version = matchstr(output[-1], '[0-9.]\+')

                              if s:version_requirement(fzf_version, s:min_version)
                                let s:checked = 1
                                return
                              end
                              throw printf('You need to upgrade fzf. Found: %s (%s). Required: %s or above.', fzf_version, exec, s:min_version)
                            endfunction

    1              0.000003 function! s:extend_opts(dict, eopts, prepend)
                              if empty(a:eopts)
                                return
                              endif
                              if has_key(a:dict, 'options')
                                if type(a:dict.options) == s:TYPE.list && type(a:eopts) == s:TYPE.list
                                  if a:prepend
                                    let a:dict.options = extend(copy(a:eopts), a:dict.options)
                                  else
                                    call extend(a:dict.options, a:eopts)
                                  endif
                                else
                                  let all_opts = a:prepend ? [a:eopts, a:dict.options] : [a:dict.options, a:eopts]
                                  let a:dict.options = join(map(all_opts, 'type(v:val) == s:TYPE.list ? join(map(copy(v:val), "fzf#shellescape(v:val)")) : v:val'))
                                endif
                              else
                                let a:dict.options = a:eopts
                              endif
                            endfunction

    1              0.000002 function! s:merge_opts(dict, eopts)
                              return s:extend_opts(a:dict, a:eopts, 0)
                            endfunction

    1              0.000002 function! s:prepend_opts(dict, eopts)
                              return s:extend_opts(a:dict, a:eopts, 1)
                            endfunction

                            " [[spec to wrap], [preview window expression], [toggle-preview keys...]]
    1              0.000002 function! fzf#vim#with_preview(...)
                              " Default spec
                              let spec = {}
                              let window = ''

                              let args = copy(a:000)

                              " Spec to wrap
                              if len(args) && type(args[0]) == s:TYPE.dict
                                let spec = copy(args[0])
                                call remove(args, 0)
                              endif

                              if !executable('bash')
                                if !s:warned
                                  call s:warn('Preview window not supported (bash not found in PATH)')
                                  let s:warned = 1
                                endif
                                return spec
                              endif

                              " Placeholder expression (TODO/TBD: undocumented)
                              let placeholder = get(spec, 'placeholder', '{}')

                              " Preview window
                              if len(args) && type(args[0]) == s:TYPE.string
                                if args[0] !~# '^\(up\|down\|left\|right\)'
                                  throw 'invalid preview window: '.args[0]
                                endif
                                let window = args[0]
                                call remove(args, 0)
                              endif

                              let preview = []
                              if len(window)
                                let preview += ['--preview-window', window]
                              endif
                              if s:is_win
                                let is_wsl_bash = exepath('bash') =~? 'Windows[/\\]system32[/\\]bash.exe$'
                                let preview_cmd = 'bash '.(is_wsl_bash
                                \ ? substitute(substitute(s:bin.preview, '^\([A-Z]\):', '/mnt/\L\1', ''), '\', '/', 'g')
                                \ : escape(s:bin.preview, '\'))
                              else
                                let preview_cmd = fzf#shellescape(s:bin.preview)
                              endif
                              if len(placeholder)
                                let preview += ['--preview', preview_cmd.' '.placeholder]
                              end

                              if len(args)
                                call extend(preview, ['--bind', join(map(args, 'v:val.":toggle-preview"'), ',')])
                              endif
                              call s:merge_opts(spec, preview)
                              return spec
                            endfunction

    1              0.000011 function! s:remove_layout(opts)
                              for key in s:layout_keys
                                if has_key(a:opts, key)
                                  call remove(a:opts, key)
                                endif
                              endfor
                              return a:opts
                            endfunction

    1              0.000003 function! s:reverse_list(opts)
                              let tokens = map(split($FZF_DEFAULT_OPTS, '[^a-z-]'), 'substitute(v:val, "^--", "", "")')
                              if index(tokens, 'reverse') < 0
                                return extend(['--layout=reverse-list'], a:opts)
                              endif
                              return a:opts
                            endfunction

    1              0.000003 function! s:wrap(name, opts, bang)
                              " fzf#wrap does not append --expect if sink or sink* is found
                              let opts = copy(a:opts)
                              let options = ''
                              if has_key(opts, 'options')
                                let options = type(opts.options) == s:TYPE.list ? join(opts.options) : opts.options
                              endif
                              if options !~ '--expect' && has_key(opts, 'sink*')
                                let Sink = remove(opts, 'sink*')
                                let wrapped = fzf#wrap(a:name, opts, a:bang)
                                let wrapped['sink*'] = Sink
                              else
                                let wrapped = fzf#wrap(a:name, opts, a:bang)
                              endif
                              return wrapped
                            endfunction

    1              0.000002 function! s:strip(str)
                              return substitute(a:str, '^\s*\|\s*$', '', 'g')
                            endfunction

    1              0.000002 function! s:chomp(str)
                              return substitute(a:str, '\n*$', '', 'g')
                            endfunction

    1              0.000002 function! s:escape(path)
                              let path = fnameescape(a:path)
                              return s:is_win ? escape(path, '$') : path
                            endfunction

    1              0.000007 if v:version >= 704
    1              0.000003   function! s:function(name)
                                return function(a:name)
                              endfunction
                            else
                              function! s:function(name)
                                " By Ingo Karkat
                                return function(substitute(a:name, '^s:', matchstr(expand('<sfile>'), '<SNR>\d\+_\zefunction$'), ''))
                              endfunction
    1              0.000001 endif

    1              0.000002 function! s:get_color(attr, ...)
                              let gui = has('termguicolors') && &termguicolors
                              let fam = gui ? 'gui' : 'cterm'
                              let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
                              for group in a:000
                                let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
                                if code =~? pat
                                  return code
                                endif
                              endfor
                              return ''
                            endfunction

    1              0.000012 let s:ansi = {'black': 30, 'red': 31, 'green': 32, 'yellow': 33, 'blue': 34, 'magenta': 35, 'cyan': 36}

    1              0.000002 function! s:csi(color, fg)
                              let prefix = a:fg ? '38;' : '48;'
                              if a:color[0] == '#'
                                return prefix.'2;'.join(map([a:color[1:2], a:color[3:4], a:color[5:6]], 'str2nr(v:val, 16)'), ';')
                              endif
                              return prefix.'5;'.a:color
                            endfunction

    1              0.000003 function! s:ansi(str, group, default, ...)
                              let fg = s:get_color('fg', a:group)
                              let bg = s:get_color('bg', a:group)
                              let color = (empty(fg) ? s:ansi[a:default] : s:csi(fg, 1)) .
                                    \ (empty(bg) ? '' : ';'.s:csi(bg, 0))
                              return printf("\x1b[%s%sm%s\x1b[m", color, a:0 ? ';1' : '', a:str)
                            endfunction

    8              0.000024 for s:color_name in keys(s:ansi)
    7              0.000093   execute "function! s:".s:color_name."(str, ...)\n"
                                    \ "  return s:ansi(a:str, get(a:, 1, ''), '".s:color_name."')\n"
                                    \ "endfunction"
    8              0.000008 endfor

    1              0.000070 function! s:buflisted()
                              return filter(range(1, bufnr('$')), 'buflisted(v:val) && getbufvar(v:val, "&filetype") != "qf"')
                            endfunction

    1              0.000003 function! s:fzf(name, opts, extra)
                              call s:check_requirements()

                              let [extra, bang] = [{}, 0]
                              if len(a:extra) <= 1
                                let first = get(a:extra, 0, 0)
                                if type(first) == s:TYPE.dict
                                  let extra = first
                                else
                                  let bang = first
                                endif
                              elseif len(a:extra) == 2
                                let [extra, bang] = a:extra
                              else
                                throw 'invalid number of arguments'
                              endif

                              let eopts  = has_key(extra, 'options') ? remove(extra, 'options') : ''
                              let merged = extend(copy(a:opts), extra)
                              call s:merge_opts(merged, eopts)
                              return fzf#run(s:wrap(a:name, merged, bang))
                            endfunction

    1              0.000010 let s:default_action = {
                              \ 'ctrl-t': 'tab split',
                              \ 'ctrl-x': 'split',
                              \ 'ctrl-v': 'vsplit' }

    1              0.000002 function! s:action_for(key, ...)
                              let default = a:0 ? a:1 : ''
                              let Cmd = get(get(g:, 'fzf_action', s:default_action), a:key, default)
                              return type(Cmd) == s:TYPE.string ? Cmd : default
                            endfunction

    1              0.000002 function! s:open(cmd, target)
                              if stridx('edit', a:cmd) == 0 && fnamemodify(a:target, ':p') ==# expand('%:p')
                                return
                              endif
                              execute a:cmd s:escape(a:target)
                            endfunction

    1              0.000002 function! s:align_lists(lists)
                              let maxes = {}
                              for list in a:lists
                                let i = 0
                                while i < len(list)
                                  let maxes[i] = max([get(maxes, i, 0), len(list[i])])
                                  let i += 1
                                endwhile
                              endfor
                              for list in a:lists
                                call map(list, "printf('%-'.maxes[v:key].'s', v:val)")
                              endfor
                              return a:lists
                            endfunction

    1              0.000002 function! s:warn(message)
                              echohl WarningMsg
                              echom a:message
                              echohl None
                              return 0
                            endfunction

    1              0.000002 function! s:fill_quickfix(list, ...)
                              if len(a:list) > 1
                                call setqflist(a:list)
                                copen
                                wincmd p
                                if a:0
                                  execute a:1
                                endif
                              endif
                            endfunction

    1              0.000003 function! fzf#vim#_uniq(list)
                              let visited = {}
                              let ret = []
                              for l in a:list
                                if !empty(l) && !has_key(visited, l)
                                  call add(ret, l)
                                  let visited[l] = 1
                                endif
                              endfor
                              return ret
                            endfunction

                            " ------------------------------------------------------------------
                            " Files
                            " ------------------------------------------------------------------
    1              0.000002 function! s:shortpath()
                              let short = fnamemodify(getcwd(), ':~:.')
                              if !has('win32unix')
                                let short = pathshorten(short)
                              endif
                              let slash = (s:is_win && !&shellslash) ? '\' : '/'
                              return empty(short) ? '~'.slash : short . (short =~ escape(slash, '\').'$' ? '' : slash)
                            endfunction

    1              0.000002 function! fzf#vim#files(dir, ...)
                              let args = {}
                              if !empty(a:dir)
                                if !isdirectory(expand(a:dir))
                                  return s:warn('Invalid directory')
                                endif
                                let slash = (s:is_win && !&shellslash) ? '\\' : '/'
                                let dir = substitute(a:dir, '[/\\]*$', slash, '')
                                let args.dir = dir
                              else
                                let dir = s:shortpath()
                              endif

                              let args.options = ['-m', '--prompt', strwidth(dir) < &columns / 2 - 20 ? dir : '> ']
                              call s:merge_opts(args, get(g:, 'fzf_files_options', []))
                              return s:fzf('files', args, a:000)
                            endfunction

                            " ------------------------------------------------------------------
                            " Lines
                            " ------------------------------------------------------------------
    1              0.000002 function! s:line_handler(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              normal! m'
                              let cmd = s:action_for(a:lines[0])
                              if !empty(cmd) && stridx('edit', cmd) < 0
                                execute 'silent' cmd
                              endif

                              let keys = split(a:lines[1], '\t')
                              execute 'buffer' keys[0]
                              execute keys[2]
                              normal! ^zvzz
                            endfunction

    1              0.000002 function! fzf#vim#_lines(all)
                              let cur = []
                              let rest = []
                              let buf = bufnr('')
                              let longest_name = 0
                              let display_bufnames = &columns > s:wide
                              if display_bufnames
                                let bufnames = {}
                                for b in s:buflisted()
                                  let bufnames[b] = pathshorten(fnamemodify(bufname(b), ":~:."))
                                  let longest_name = max([longest_name, len(bufnames[b])])
                                endfor
                              endif
                              let len_bufnames = min([15, longest_name])
                              for b in s:buflisted()
                                let lines = getbufline(b, 1, "$")
                                if empty(lines)
                                  let path = fnamemodify(bufname(b), ':p')
                                  let lines = filereadable(path) ? readfile(path) : []
                                endif
                                if display_bufnames
                                  let bufname = bufnames[b]
                                  if len(bufname) > len_bufnames + 1
                                    let bufname = '…' . bufname[-len_bufnames+1:]
                                  endif
                                  let bufname = printf(s:green("%".len_bufnames."s", "Directory"), bufname)
                                else
                                  let bufname = ''
                                endif
                                let linefmt = s:blue("%2d\t", "TabLine")."%s".s:yellow("\t%4d ", "LineNr")."\t%s"
                                call extend(b == buf ? cur : rest,
                                \ filter(
                                \   map(lines,
                                \       '(!a:all && empty(v:val)) ? "" : printf(linefmt, b, bufname, v:key + 1, v:val)'),
                                \   'a:all || !empty(v:val)'))
                              endfor
                              return [display_bufnames, extend(cur, rest)]
                            endfunction

    1              0.000013 function! fzf#vim#lines(...)
                              let [display_bufnames, lines] = fzf#vim#_lines(1)
                              let nth = display_bufnames ? 3 : 2
                              let [query, args] = (a:0 && type(a:1) == type('')) ?
                                    \ [a:1, a:000[1:]] : ['', a:000]
                              return s:fzf('lines', {
                              \ 'source':  lines,
                              \ 'sink*':   s:function('s:line_handler'),
                              \ 'options': s:reverse_list(['+m', '--tiebreak=index', '--prompt', 'Lines> ', '--ansi', '--extended', '--nth='.nth.'..', '--tabstop=1', '--query', query])
                              \}, args)
                            endfunction

                            " ------------------------------------------------------------------
                            " BLines
                            " ------------------------------------------------------------------
    1              0.000089 function! s:buffer_line_handler(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              let qfl = []
                              for line in a:lines[1:]
                                let chunks = split(line, "\t", 1)
                                let ln = chunks[0]
                                let ltxt = join(chunks[1:], "\t")
                                call add(qfl, {'filename': expand('%'), 'lnum': str2nr(ln), 'text': ltxt})
                              endfor
                              call s:fill_quickfix(qfl, 'cfirst')
                              normal! m'
                              let cmd = s:action_for(a:lines[0])
                              if !empty(cmd)
                                execute 'silent' cmd
                              endif

                              execute split(a:lines[1], '\t')[0]
                              normal! ^zvzz
                            endfunction

    1              0.000124 function! s:buffer_lines(query)
                              let linefmt = s:yellow(" %4d ", "LineNr")."\t%s"
                              let fmtexpr = 'printf(linefmt, v:key + 1, v:val)'
                              let lines = getline(1, '$')
                              if empty(a:query)
                                return map(lines, fmtexpr)
                              end
                              return filter(map(lines, 'v:val =~ a:query ? '.fmtexpr.' : ""'), 'len(v:val)')
                            endfunction

    1              0.000009 function! fzf#vim#buffer_lines(...)
                              let [query, args] = (a:0 && type(a:1) == type('')) ?
                                    \ [a:1, a:000[1:]] : ['', a:000]
                              return s:fzf('blines', {
                              \ 'source':  s:buffer_lines(query),
                              \ 'sink*':   s:function('s:buffer_line_handler'),
                              \ 'options': s:reverse_list(['+m', '--tiebreak=index', '--multi', '--prompt', 'BLines> ', '--ansi', '--extended', '--nth=2..', '--tabstop=1'])
                              \}, args)
                            endfunction

                            " ------------------------------------------------------------------
                            " Colors
                            " ------------------------------------------------------------------
    1              0.000006 function! fzf#vim#colors(...)
                              let colors = split(globpath(&rtp, "colors/*.vim"), "\n")
                              if has('packages')
                                let colors += split(globpath(&packpath, "pack/*/opt/*/colors/*.vim"), "\n")
                              endif
                              return s:fzf('colors', {
                              \ 'source':  fzf#vim#_uniq(map(colors, "substitute(fnamemodify(v:val, ':t'), '\\..\\{-}$', '', '')")),
                              \ 'sink':    'colo',
                              \ 'options': '+m --prompt="Colors> "'
                              \}, a:000)
                            endfunction

                            " ------------------------------------------------------------------
                            " Locate
                            " ------------------------------------------------------------------
    1              0.000008 function! fzf#vim#locate(query, ...)
                              return s:fzf('locate', {
                              \ 'source':  'locate '.a:query,
                              \ 'options': '-m --prompt "Locate> "'
                              \}, a:000)
                            endfunction

                            " ------------------------------------------------------------------
                            " History[:/]
                            " ------------------------------------------------------------------
    1              0.000006 function! fzf#vim#_recent_files()
                              return fzf#vim#_uniq(map(
                                \ filter([expand('%')], 'len(v:val)')
                                \   + filter(map(fzf#vim#_buflisted_sorted(), 'bufname(v:val)'), 'len(v:val)')
                                \   + filter(copy(v:oldfiles), "filereadable(fnamemodify(v:val, ':p'))"),
                                \ 'fnamemodify(v:val, ":~:.")'))
                            endfunction

    1              0.000009 function! s:history_source(type)
                              let max  = histnr(a:type)
                              let fmt  = s:yellow(' %'.len(string(max)).'d ', 'Number')
                              let list = filter(map(range(1, max), 'histget(a:type, - v:val)'), '!empty(v:val)')
                              return extend([' :: Press '.s:magenta('CTRL-E', 'Special').' to edit'],
                                \ map(list, 'printf(fmt, len(list) - v:key)." ".v:val'))
                            endfunction

    1              0.000302 nnoremap <plug>(-fzf-vim-do) :execute g:__fzf_command<cr>
    1              0.000299 nnoremap <plug>(-fzf-/) /
    1              0.000059 nnoremap <plug>(-fzf-:) :

    1              0.000018 function! s:history_sink(type, lines)
                              if len(a:lines) < 2
                                return
                              endif

                              let prefix = "\<plug>(-fzf-".a:type.')'
                              let key  = a:lines[0]
                              let item = matchstr(a:lines[1], ' *[0-9]\+ *\zs.*')
                              if key == 'ctrl-e'
                                call histadd(a:type, item)
                                redraw
                                call feedkeys(a:type."\<up>", 'n')
                              else
                                if a:type == ':'
                                  call histadd(a:type, item)
                                endif
                                let g:__fzf_command = "normal ".prefix.item."\<cr>"
                                call feedkeys("\<plug>(-fzf-vim-do)")
                              endif
                            endfunction

    1              0.000011 function! s:cmd_history_sink(lines)
                              call s:history_sink(':', a:lines)
                            endfunction

    1              0.000007 function! fzf#vim#command_history(...)
                              return s:fzf('history-command', {
                              \ 'source':  s:history_source(':'),
                              \ 'sink*':   s:function('s:cmd_history_sink'),
                              \ 'options': '+m --ansi --prompt="Hist:> " --header-lines=1 --expect=ctrl-e --tiebreak=index'}, a:000)
                            endfunction

    1              0.000009 function! s:search_history_sink(lines)
                              call s:history_sink('/', a:lines)
                            endfunction

    1              0.000007 function! fzf#vim#search_history(...)
                              return s:fzf('history-search', {
                              \ 'source':  s:history_source('/'),
                              \ 'sink*':   s:function('s:search_history_sink'),
                              \ 'options': '+m --ansi --prompt="Hist/> " --header-lines=1 --expect=ctrl-e --tiebreak=index'}, a:000)
                            endfunction

    1              0.000006 function! fzf#vim#history(...)
                              return s:fzf('history-files', {
                              \ 'source':  fzf#vim#_recent_files(),
                              \ 'options': ['-m', '--header-lines', !empty(expand('%')), '--prompt', 'Hist> ']
                              \}, a:000)
                            endfunction

                            " ------------------------------------------------------------------
                            " GFiles[?]
                            " ------------------------------------------------------------------

    1              0.000007 function! s:get_git_root()
                              let root = split(system('git rev-parse --show-toplevel'), '\n')[0]
                              return v:shell_error ? '' : root
                            endfunction

    1              0.000018 function! fzf#vim#gitfiles(args, ...)
                              let root = s:get_git_root()
                              if empty(root)
                                return s:warn('Not in git repo')
                              endif
                              if a:args != '?'
                                return s:fzf('gfiles', {
                                \ 'source':  'git ls-files '.a:args.(s:is_win ? '' : ' | uniq'),
                                \ 'dir':     root,
                                \ 'options': '-m --prompt "GitFiles> "'
                                \}, a:000)
                              endif

                              " Here be dragons!
                              " We're trying to access the common sink function that fzf#wrap injects to
                              " the options dictionary.
                              let preview = printf(
                                \ 'bash -c "if [[ {1} =~ M ]]; then %s; else %s {-1}; fi"',
                                \ executable('delta')
                                  \ ? 'git diff -- {-1} | delta --file-style=omit | sed 1d'
                                  \ : 'git diff --color=always -- {-1} | sed 1,4d',
                                \ s:bin.preview)
                              let wrapped = fzf#wrap({
                              \ 'source':  'git -c color.status=always status --short --untracked-files=all',
                              \ 'dir':     root,
                              \ 'options': ['--ansi', '--multi', '--nth', '2..,..', '--tiebreak=index', '--prompt', 'GitFiles?> ', '--preview', preview]
                              \})
                              call s:remove_layout(wrapped)
                              let wrapped.common_sink = remove(wrapped, 'sink*')
                              function! wrapped.newsink(lines)
                                let lines = extend(a:lines[0:0], map(a:lines[1:], 'substitute(v:val[3:], ".* -> ", "", "")'))
                                return self.common_sink(lines)
                              endfunction
                              let wrapped['sink*'] = remove(wrapped, 'newsink')
                              return s:fzf('gfiles-diff', wrapped, a:000)
                            endfunction

                            " ------------------------------------------------------------------
                            " Buffers
                            " ------------------------------------------------------------------
    1              0.000005 function! s:find_open_window(b)
                              let [tcur, tcnt] = [tabpagenr() - 1, tabpagenr('$')]
                              for toff in range(0, tabpagenr('$') - 1)
                                let t = (tcur + toff) % tcnt + 1
                                let buffers = tabpagebuflist(t)
                                for w in range(1, len(buffers))
                                  let b = buffers[w - 1]
                                  if b == a:b
                                    return [t, w]
                                  endif
                                endfor
                              endfor
                              return [0, 0]
                            endfunction

    1              0.000004 function! s:jump(t, w)
                              execute a:t.'tabnext'
                              execute a:w.'wincmd w'
                            endfunction

    1              0.000004 function! s:bufopen(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              let b = matchstr(a:lines[1], '\[\zs[0-9]*\ze\]')
                              if empty(a:lines[0]) && get(g:, 'fzf_buffers_jump')
                                let [t, w] = s:find_open_window(b)
                                if t
                                  call s:jump(t, w)
                                  return
                                endif
                              endif
                              let cmd = s:action_for(a:lines[0])
                              if !empty(cmd)
                                execute 'silent' cmd
                              endif
                              execute 'buffer' b
                            endfunction

    1              0.000007 function! fzf#vim#_format_buffer(b)
                              let name = bufname(a:b)
                              let line = exists('*getbufinfo') ? getbufinfo(a:b)[0]['lnum'] : 0
                              let name = empty(name) ? '[No Name]' : fnamemodify(name, ":p:~:.")
                              let flag = a:b == bufnr('')  ? s:blue('%', 'Conditional') :
                                      \ (a:b == bufnr('#') ? s:magenta('#', 'Special') : ' ')
                              let modified = getbufvar(a:b, '&modified') ? s:red(' [+]', 'Exception') : ''
                              let readonly = getbufvar(a:b, '&modifiable') ? '' : s:green(' [RO]', 'Constant')
                              let extra = join(filter([modified, readonly], '!empty(v:val)'), '')
                              let target = line == 0 ? name : name.':'.line
                              return s:strip(printf("%s\t%d\t[%s] %s\t%s\t%s", target, line, s:yellow(a:b, 'Number'), flag, name, extra))
                            endfunction

    1              0.000005 function! s:sort_buffers(...)
                              let [b1, b2] = map(copy(a:000), 'get(g:fzf#vim#buffers, v:val, v:val)')
                              " Using minus between a float and a number in a sort function causes an error
                              return b1 < b2 ? 1 : -1
                            endfunction

    1              0.000004 function! fzf#vim#_buflisted_sorted()
                              return sort(s:buflisted(), 's:sort_buffers')
                            endfunction

    1              0.000003 function! fzf#vim#buffers(...)
                              let [query, args] = (a:0 && type(a:1) == type('')) ?
                                    \ [a:1, a:000[1:]] : ['', a:000]
                              return s:fzf('buffers', {
                              \ 'source':  map(fzf#vim#_buflisted_sorted(), 'fzf#vim#_format_buffer(v:val)'),
                              \ 'sink*':   s:function('s:bufopen'),
                              \ 'options': ['+m', '-x', '--tiebreak=index', '--header-lines=1', '--ansi', '-d', '\t', '--with-nth', '3..', '-n', '2,1..2', '--prompt', 'Buf> ', '--query', query, '--preview-window', '+{2}-/2']
                              \}, args)
                            endfunction

                            " ------------------------------------------------------------------
                            " Ag / Rg
                            " ------------------------------------------------------------------
    1              0.000005 function! s:ag_to_qf(line, has_column)
                              let parts = matchlist(a:line, '\(.\{-}\)\s*:\s*\(\d\+\)\%(\s*:\s*\(\d\+\)\)\?\%(\s*:\(.*\)\)\?')
                              let dict = {'filename': &acd ? fnamemodify(parts[1], ':p') : parts[1], 'lnum': parts[2], 'text': parts[4]}
                              if a:has_column
                                let dict.col = parts[3]
                              endif
                              return dict
                            endfunction

    1              0.000005 function! s:ag_handler(lines, has_column)
                              if len(a:lines) < 2
                                return
                              endif

                              let cmd = s:action_for(a:lines[0], 'e')
                              let list = map(filter(a:lines[1:], 'len(v:val)'), 's:ag_to_qf(v:val, a:has_column)')
                              if empty(list)
                                return
                              endif

                              let first = list[0]
                              try
                                call s:open(cmd, first.filename)
                                execute first.lnum
                                if a:has_column
                                  call cursor(0, first.col)
                                endif
                                normal! zz
                              catch
                              endtry

                              call s:fill_quickfix(list)
                            endfunction

                            " query, [[ag options], options]
    1              0.000008 function! fzf#vim#ag(query, ...)
                              if type(a:query) != s:TYPE.string
                                return s:warn('Invalid query argument')
                              endif
                              let query = empty(a:query) ? '^(?=.)' : a:query
                              let args = copy(a:000)
                              let ag_opts = len(args) > 1 && type(args[0]) == s:TYPE.string ? remove(args, 0) : ''
                              let command = ag_opts . ' -- ' . fzf#shellescape(query)
                              return call('fzf#vim#ag_raw', insert(args, command, 0))
                            endfunction

                            " ag command suffix, [options]
    1              0.000005 function! fzf#vim#ag_raw(command_suffix, ...)
                              if !executable('ag')
                                return s:warn('ag is not found')
                              endif
                              return call('fzf#vim#grep', extend(['ag --nogroup --column --color '.a:command_suffix, 1], a:000))
                            endfunction

                            " command (string), has_column (0/1), [options (dict)], [fullscreen (0/1)]
    1              0.000005 function! fzf#vim#grep(grep_command, has_column, ...)
                              let words = []
                              for word in split(a:grep_command)
                                if word !~# '^[a-z]'
                                  break
                                endif
                                call add(words, word)
                              endfor
                              let words   = empty(words) ? ['grep'] : words
                              let name    = join(words, '-')
                              let capname = join(map(words, 'toupper(v:val[0]).v:val[1:]'), '')
                              let opts = {
                              \ 'column':  a:has_column,
                              \ 'options': ['--ansi', '--prompt', capname.'> ',
                              \             '--multi', '--bind', 'alt-a:select-all,alt-d:deselect-all',
                              \             '--delimiter', ':', '--preview-window', '+{2}-/2']
                              \}
                              function! opts.sink(lines)
                                return s:ag_handler(a:lines, self.column)
                              endfunction
                              let opts['sink*'] = remove(opts, 'sink')
                              try
                                let prev_default_command = $FZF_DEFAULT_COMMAND
                                let $FZF_DEFAULT_COMMAND = a:grep_command
                                return s:fzf(name, opts, a:000)
                              finally
                                let $FZF_DEFAULT_COMMAND = prev_default_command
                              endtry
                            endfunction

                            " ------------------------------------------------------------------
                            " BTags
                            " ------------------------------------------------------------------
    1              0.000007 function! s:btags_source(tag_cmds)
                              if !filereadable(expand('%'))
                                throw 'Save the file first'
                              endif

                              for cmd in a:tag_cmds
                                let lines = split(system(cmd), "\n")
                                if !v:shell_error && len(lines)
                                  break
                                endif
                              endfor
                              if v:shell_error
                                throw get(lines, 0, 'Failed to extract tags')
                              elseif empty(lines)
                                throw 'No tags found'
                              endif
                              return map(s:align_lists(map(lines, 'split(v:val, "\t")')), 'join(v:val, "\t")')
                            endfunction

    1              0.000005 function! s:btags_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              normal! m'
                              let cmd = s:action_for(a:lines[0])
                              if !empty(cmd)
                                execute 'silent' cmd '%'
                              endif
                              let qfl = []
                              for line in a:lines[1:]
                                execute split(line, "\t")[2]
                                call add(qfl, {'filename': expand('%'), 'lnum': line('.'), 'text': getline('.')})
                              endfor
                              call s:fill_quickfix(qfl, 'cfirst')
                              normal! zvzz
                            endfunction

                            " query, [[tag commands], options]
    1              0.000005 function! fzf#vim#buffer_tags(query, ...)
                              let args = copy(a:000)
                              let escaped = fzf#shellescape(expand('%'))
                              let null = s:is_win ? 'nul' : '/dev/null'
                              let sort = has('unix') && !has('win32unix') && executable('sort') ? '| sort -s -k 5' : ''
                              let tag_cmds = (len(args) > 1 && type(args[0]) != type({})) ? remove(args, 0) : [
                                \ printf('ctags -f - --sort=yes --excmd=number --language-force=%s %s 2> %s %s', &filetype, escaped, null, sort),
                                \ printf('ctags -f - --sort=yes --excmd=number %s 2> %s %s', escaped, null, sort)]
                              if type(tag_cmds) != type([])
                                let tag_cmds = [tag_cmds]
                              endif
                              try
                                return s:fzf('btags', {
                                \ 'source':  s:btags_source(tag_cmds),
                                \ 'sink*':   s:function('s:btags_sink'),
                                \ 'options': s:reverse_list(['-m', '-d', '\t', '--with-nth', '1,4..', '-n', '1', '--prompt', 'BTags> ', '--query', a:query, '--preview-window', '+{3}-/2'])}, args)
                              catch
                                return s:warn(v:exception)
                              endtry
                            endfunction

                            " ------------------------------------------------------------------
                            " Tags
                            " ------------------------------------------------------------------
    1              0.000005 function! s:tags_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              normal! m'
                              let qfl = []
                              let cmd = s:action_for(a:lines[0], 'e')
                              try
                                let [magic, &magic, wrapscan, &wrapscan, acd, &acd] = [&magic, 0, &wrapscan, 1, &acd, 0]
                                for line in a:lines[1:]
                                  try
                                    let parts   = split(line, '\t\zs')
                                    let excmd   = matchstr(join(parts[2:-2], '')[:-2], '^.\{-}\ze;\?"\t')
                                    let base    = fnamemodify(parts[-1], ':h')
                                    let relpath = parts[1][:-2]
                                    let abspath = relpath =~ (s:is_win ? '^[A-Z]:\' : '^/') ? relpath : join([base, relpath], '/')
                                    call s:open(cmd, expand(abspath, 1))
                                    silent execute excmd
                                    call add(qfl, {'filename': expand('%'), 'lnum': line('.'), 'text': getline('.')})
                                  catch /^Vim:Interrupt$/
                                    break
                                  catch
                                    call s:warn(v:exception)
                                  endtry
                                endfor
                              finally
                                let [&magic, &wrapscan, &acd] = [magic, wrapscan, acd]
                              endtry
                              call s:fill_quickfix(qfl, 'clast')
                              normal! zvzz
                            endfunction

    1              0.000005 function! fzf#vim#tags(query, ...)
                              if !executable('perl')
                                return s:warn('Tags command requires perl')
                              endif
                              if empty(tagfiles())
                                call inputsave()
                                echohl WarningMsg
                                let gen = input('tags not found. Generate? (y/N) ')
                                echohl None
                                call inputrestore()
                                redraw
                                if gen =~? '^y'
                                  call s:warn('Preparing tags')
                                  call system(get(g:, 'fzf_tags_command', 'ctags -R'.(s:is_win ? ' --output-format=e-ctags' : '')))
                                  if empty(tagfiles())
                                    return s:warn('Failed to create tags')
                                  endif
                                else
                                  return s:warn('No tags found')
                                endif
                              endif

                              let tagfiles = tagfiles()
                              let v2_limit = 1024 * 1024 * 200
                              for tagfile in tagfiles
                                let v2_limit -= getfsize(tagfile)
                                if v2_limit < 0
                                  break
                                endif
                              endfor
                              let opts = v2_limit < 0 ? ['--algo=v1'] : []

                              return s:fzf('tags', {
                              \ 'source':  'perl '.fzf#shellescape(s:bin.tags).' '.join(map(tagfiles, 'fzf#shellescape(fnamemodify(v:val, ":p"))')),
                              \ 'sink*':   s:function('s:tags_sink'),
                              \ 'options': extend(opts, ['--nth', '1..2', '-m', '--tiebreak=begin', '--prompt', 'Tags> ', '--query', a:query])}, a:000)
                            endfunction

                            " ------------------------------------------------------------------
                            " Snippets (UltiSnips)
                            " ------------------------------------------------------------------
    1              0.000008 function! s:inject_snippet(line)
                              let snip = split(a:line, "\t")[0]
                              execute 'normal! a'.s:strip(snip)."\<c-r>=UltiSnips#ExpandSnippet()\<cr>"
                            endfunction

    1              0.000004 function! fzf#vim#snippets(...)
                              if !exists(':UltiSnipsEdit')
                                return s:warn('UltiSnips not found')
                              endif
                              let list = UltiSnips#SnippetsInCurrentScope()
                              if empty(list)
                                return s:warn('No snippets available here')
                              endif
                              let aligned = sort(s:align_lists(items(list)))
                              let colored = map(aligned, 's:yellow(v:val[0])."\t".v:val[1]')
                              return s:fzf('snippets', {
                              \ 'source':  colored,
                              \ 'options': '--ansi --tiebreak=index +m -n 1 -d "\t"',
                              \ 'sink':    s:function('s:inject_snippet')}, a:000)
                            endfunction

                            " ------------------------------------------------------------------
                            " Commands
                            " ------------------------------------------------------------------
    1              0.000016 let s:nbs = nr2char(0x2007)

    1              0.000005 function! s:format_cmd(line)
                              return substitute(a:line, '\C \([A-Z]\S*\) ',
                                    \ '\=s:nbs.s:yellow(submatch(1), "Function").s:nbs', '')
                            endfunction

    1              0.000004 function! s:command_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              let cmd = matchstr(a:lines[1], s:nbs.'\zs\S*\ze'.s:nbs)
                              if empty(a:lines[0])
                                call feedkeys(':'.cmd.(a:lines[1][0] == '!' ? '' : ' '), 'n')
                              else
                                call histadd(':', cmd)
                                execute cmd
                              endif
                            endfunction

    1   0.000398   0.000077 let s:fmt_excmd = '   '.s:blue('%-38s', 'Statement').'%s'

    1              0.000006 function! s:format_excmd(ex)
                              let match = matchlist(a:ex, '^|:\(\S\+\)|\s*\S*\(.*\)')
                              return printf(s:fmt_excmd, s:nbs.match[1].s:nbs, s:strip(match[2]))
                            endfunction

    1              0.000002 function! s:excmds()
                              let help = globpath($VIMRUNTIME, 'doc/index.txt')
                              if empty(help)
                                return []
                              endif

                              let commands = []
                              let command = ''
                              for line in readfile(help)
                                if line =~ '^|:[^|]'
                                  if !empty(command)
                                    call add(commands, s:format_excmd(command))
                                  endif
                                  let command = line
                                elseif line =~ '^\s\+\S' && !empty(command)
                                  let command .= substitute(line, '^\s*', ' ', '')
                                elseif !empty(commands) && line =~ '^\s*$'
                                  break
                                endif
                              endfor
                              if !empty(command)
                                call add(commands, s:format_excmd(command))
                              endif
                              return commands
                            endfunction

    1              0.000003 function! fzf#vim#commands(...)
                              redir => cout
                              silent command
                              redir END
                              let list = split(cout, "\n")
                              return s:fzf('commands', {
                              \ 'source':  extend(extend(list[0:0], map(list[1:], 's:format_cmd(v:val)')), s:excmds()),
                              \ 'sink*':   s:function('s:command_sink'),
                              \ 'options': '--ansi --expect '.get(g:, 'fzf_commands_expect', 'ctrl-x').
                              \            ' --tiebreak=index --header-lines 1 -x --prompt "Commands> " -n2,3,2..3 -d'.s:nbs}, a:000)
                            endfunction

                            " ------------------------------------------------------------------
                            " Marks
                            " ------------------------------------------------------------------
    1              0.000003 function! s:format_mark(line)
                              return substitute(a:line, '\S', '\=s:yellow(submatch(0), "Number")', '')
                            endfunction

    1              0.000002 function! s:mark_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif
                              let cmd = s:action_for(a:lines[0])
                              if !empty(cmd)
                                execute 'silent' cmd
                              endif
                              execute 'normal! `'.matchstr(a:lines[1], '\S').'zz'
                            endfunction

    1              0.000002 function! fzf#vim#marks(...)
                              redir => cout
                              silent marks
                              redir END
                              let list = split(cout, "\n")
                              return s:fzf('marks', {
                              \ 'source':  extend(list[0:0], map(list[1:], 's:format_mark(v:val)')),
                              \ 'sink*':   s:function('s:mark_sink'),
                              \ 'options': '+m -x --ansi --tiebreak=index --header-lines 1 --tiebreak=begin --prompt "Marks> "'}, a:000)
                            endfunction

                            " ------------------------------------------------------------------
                            " Help tags
                            " ------------------------------------------------------------------
    1              0.000003 function! s:helptag_sink(line)
                              let [tag, file, path] = split(a:line, "\t")[0:2]
                              let rtp = fnamemodify(path, ':p:h:h')
                              if stridx(&rtp, rtp) < 0
                                execute 'set rtp+='.s:escape(rtp)
                              endif
                              execute 'help' tag
                            endfunction

    1              0.000002 function! fzf#vim#helptags(...)
                              if !executable('grep') || !executable('perl')
                                return s:warn('Helptags command requires grep and perl')
                              endif
                              let sorted = sort(split(globpath(&runtimepath, 'doc/tags', 1), '\n'))
                              let tags = exists('*uniq') ? uniq(sorted) : fzf#vim#_uniq(sorted)

                              if exists('s:helptags_script')
                                silent! call delete(s:helptags_script)
                              endif
                              let s:helptags_script = tempname()
                              call writefile(['/('.(s:is_win ? '^[A-Z]:[\/\\].*?[^:]' : '.*?').'):(.*?)\t(.*?)\t/; printf(qq('.s:green('%-40s', 'Label').'\t%s\t%s\n), $2, $3, $1)'], s:helptags_script)
                              return s:fzf('helptags', {
                              \ 'source':  'grep -H ".*" '.join(map(tags, 'fzf#shellescape(v:val)')).
                                \ ' | perl -n '.fzf#shellescape(s:helptags_script).' | sort',
                              \ 'sink':    s:function('s:helptag_sink'),
                              \ 'options': ['--ansi', '+m', '--tiebreak=begin', '--with-nth', '..-2']}, a:000)
                            endfunction

                            " ------------------------------------------------------------------
                            " File types
                            " ------------------------------------------------------------------
    1              0.000002 function! fzf#vim#filetypes(...)
                              return s:fzf('filetypes', {
                              \ 'source':  fzf#vim#_uniq(sort(map(split(globpath(&rtp, 'syntax/*.vim'), '\n'),
                              \            'fnamemodify(v:val, ":t:r")'))),
                              \ 'sink':    'setf',
                              \ 'options': '+m --prompt="File types> "'
                              \}, a:000)
                            endfunction

                            " ------------------------------------------------------------------
                            " Windows
                            " ------------------------------------------------------------------
    1              0.000003 function! s:format_win(tab, win, buf)
                              let modified = getbufvar(a:buf, '&modified')
                              let name = bufname(a:buf)
                              let name = empty(name) ? '[No Name]' : name
                              let active = tabpagewinnr(a:tab) == a:win
                              return (active? s:blue('> ', 'Operator') : '  ') . name . (modified? s:red(' [+]', 'Exception') : '')
                            endfunction

    1              0.000002 function! s:windows_sink(line)
                              let list = matchlist(a:line, '^ *\([0-9]\+\) *\([0-9]\+\)')
                              call s:jump(list[1], list[2])
                            endfunction

    1              0.000002 function! fzf#vim#windows(...)
                              let lines = []
                              for t in range(1, tabpagenr('$'))
                                let buffers = tabpagebuflist(t)
                                for w in range(1, len(buffers))
                                  call add(lines,
                                    \ printf('%s %s  %s',
                                        \ s:yellow(printf('%3d', t), 'Number'),
                                        \ s:cyan(printf('%3d', w), 'String'),
                                        \ s:format_win(t, w, buffers[w-1])))
                                endfor
                              endfor
                              return s:fzf('windows', {
                              \ 'source':  extend(['Tab Win    Name'], lines),
                              \ 'sink':    s:function('s:windows_sink'),
                              \ 'options': '+m --ansi --tiebreak=begin --header-lines=1'}, a:000)
                            endfunction

                            " ------------------------------------------------------------------
                            " Commits / BCommits
                            " ------------------------------------------------------------------
    1              0.000002 function! s:yank_to_register(data)
                              let @" = a:data
                              silent! let @* = a:data
                              silent! let @+ = a:data
                            endfunction

    1              0.000002 function! s:commits_sink(lines)
                              if len(a:lines) < 2
                                return
                              endif

                              let pat = '[0-9a-f]\{7,9}'

                              if a:lines[0] == 'ctrl-y'
                                let hashes = join(filter(map(a:lines[1:], 'matchstr(v:val, pat)'), 'len(v:val)'))
                                return s:yank_to_register(hashes)
                              end

                              let diff = a:lines[0] == 'ctrl-d'
                              let cmd = s:action_for(a:lines[0], 'e')
                              let buf = bufnr('')
                              for idx in range(1, len(a:lines) - 1)
                                let sha = matchstr(a:lines[idx], pat)
                                if !empty(sha)
                                  if diff
                                    if idx > 1
                                      execute 'tab sb' buf
                                    endif
                                    execute 'Gdiff' sha
                                  else
                                    " Since fugitive buffers are unlisted, we can't keep using 'e'
                                    let c = (cmd == 'e' && idx > 1) ? 'tab split' : cmd
                                    execute c FugitiveFind(sha)
                                  endif
                                endif
                              endfor
                            endfunction

    1              0.000002 function! s:commits(buffer_local, args)
                              let s:git_root = s:get_git_root()
                              if empty(s:git_root)
                                return s:warn('Not in git repository')
                              endif

                              let source = 'git log '.get(g:, 'fzf_commits_log_options', '--color=always '.fzf#shellescape('--format=%C(auto)%h%d %s %C(green)%cr'))
                              let current = expand('%')
                              let managed = 0
                              if !empty(current)
                                call system('git show '.fzf#shellescape(current).' 2> '.(s:is_win ? 'nul' : '/dev/null'))
                                let managed = !v:shell_error
                              endif

                              if a:buffer_local
                                if !managed
                                  return s:warn('The current buffer is not in the working tree')
                                endif
                                let source .= ' --follow '.fzf#shellescape(current)
                              else
                                let source .= ' --graph'
                              endif

                              let command = a:buffer_local ? 'BCommits' : 'Commits'
                              let expect_keys = join(keys(get(g:, 'fzf_action', s:default_action)), ',')
                              let options = {
                              \ 'source':  source,
                              \ 'sink*':   s:function('s:commits_sink'),
                              \ 'options': s:reverse_list(['--ansi', '--multi', '--tiebreak=index',
                              \   '--inline-info', '--prompt', command.'> ', '--bind=ctrl-s:toggle-sort',
                              \   '--header', ':: Press '.s:magenta('CTRL-S', 'Special').' to toggle sort, '.s:magenta('CTRL-Y', 'Special').' to yank commit hashes',
                              \   '--expect=ctrl-y,'.expect_keys])
                              \ }

                              if a:buffer_local
                                let options.options[-2] .= ', '.s:magenta('CTRL-D', 'Special').' to diff'
                                let options.options[-1] .= ',ctrl-d'
                              endif

                              if !s:is_win && &columns > s:wide
                                let suffix = executable('delta') ? '| delta' : '--color=always'
                                call extend(options.options,
                                \ ['--preview', 'echo {} | grep -o "[a-f0-9]\{7,\}" | head -1 | xargs git show --format=format: ' . suffix])
                              endif

                              return s:fzf(a:buffer_local ? 'bcommits' : 'commits', options, a:args)
                            endfunction

    1              0.000005 function! fzf#vim#commits(...)
                              return s:commits(0, a:000)
                            endfunction

    1              0.000002 function! fzf#vim#buffer_commits(...)
                              return s:commits(1, a:000)
                            endfunction

                            " ------------------------------------------------------------------
                            " fzf#vim#maps(mode, opts[with count and op])
                            " ------------------------------------------------------------------
    1              0.000004 function! s:align_pairs(list)
                              let maxlen = 0
                              let pairs = []
                              for elem in a:list
                                let match = matchlist(elem, '^\(\S*\)\s*\(.*\)$')
                                let [_, k, v] = match[0:2]
                                let maxlen = max([maxlen, len(k)])
                                call add(pairs, [k, substitute(v, '^\*\?[@ ]\?', '', '')])
                              endfor
                              let maxlen = min([maxlen, 35])
                              return map(pairs, "printf('%-'.maxlen.'s', v:val[0]).' '.v:val[1]")
                            endfunction

    1              0.000003 function! s:highlight_keys(str)
                              return substitute(
                                    \ substitute(a:str, '<[^ >]\+>', s:yellow('\0', 'Special'), 'g'),
                                    \ '<Plug>', s:blue('<Plug>', 'SpecialKey'), 'g')
                            endfunction

    1              0.000002 function! s:key_sink(line)
                              let key = matchstr(a:line, '^\S*')
                              redraw
                              call feedkeys(s:map_gv.s:map_cnt.s:map_reg, 'n')
                              call feedkeys(s:map_op.
                                    \ substitute(key, '<[^ >]\+>', '\=eval("\"\\".submatch(0)."\"")', 'g'))
                            endfunction

    1              0.000002 function! fzf#vim#maps(mode, ...)
                              let s:map_gv  = a:mode == 'x' ? 'gv' : ''
                              let s:map_cnt = v:count == 0 ? '' : v:count
                              let s:map_reg = empty(v:register) ? '' : ('"'.v:register)
                              let s:map_op  = a:mode == 'o' ? v:operator : ''

                              redir => cout
                              silent execute 'verbose' a:mode.'map'
                              redir END
                              let list = []
                              let curr = ''
                              for line in split(cout, "\n")
                                if line =~ "^\t"
                                  let src = "\t".substitute(matchstr(line, '/\zs[^/\\]*\ze$'), ' [^ ]* ', ':', '')
                                  call add(list, printf('%s %s', curr, s:green(src, 'Comment')))
                                  let curr = ''
                                else
                                  if !empty(curr)
                                    call add(list, curr)
                                  endif
                                  let curr = line[3:]
                                endif
                              endfor
                              if !empty(curr)
                                call add(list, curr)
                              endif
                              let aligned = s:align_pairs(list)
                              let sorted  = sort(aligned)
                              let colored = map(sorted, 's:highlight_keys(v:val)')
                              let pcolor  = a:mode == 'x' ? 9 : a:mode == 'o' ? 10 : 12
                              return s:fzf('maps', {
                              \ 'source':  colored,
                              \ 'sink':    s:function('s:key_sink'),
                              \ 'options': '--prompt "Maps ('.a:mode.')> " --ansi --no-hscroll --nth 1,.. --color prompt:'.pcolor}, a:000)
                            endfunction

                            " ----------------------------------------------------------------------------
                            " fzf#vim#complete - completion helper
                            " ----------------------------------------------------------------------------
    1              0.000055 inoremap <silent> <Plug>(-fzf-complete-trigger) <c-o>:call <sid>complete_trigger()<cr>

    1              0.000004 function! s:pluck(dict, key, default)
                              return has_key(a:dict, a:key) ? remove(a:dict, a:key) : a:default
                            endfunction

    1              0.000002 function! s:complete_trigger()
                              let opts = copy(s:opts)
                              call s:prepend_opts(opts, ['+m', '-q', s:query])
                              let opts['sink*'] = s:function('s:complete_insert')
                              let s:reducer = s:pluck(opts, 'reducer', s:function('s:first_line'))
                              call fzf#run(opts)
                            endfunction

                            " The default reducer
    1              0.000002 function! s:first_line(lines)
                              return a:lines[0]
                            endfunction

    1              0.000002 function! s:complete_insert(lines)
                              if empty(a:lines)
                                return
                              endif

                              let chars = strchars(s:query)
                              if     chars == 0 | let del = ''
                              elseif chars == 1 | let del = '"_x'
                              else              | let del = (chars - 1).'"_dvh'
                              endif

                              let data = call(s:reducer, [a:lines])
                              let ve = &ve
                              set ve=
                              execute 'normal!' ((s:eol || empty(chars)) ? '' : 'h').del.(s:eol ? 'a': 'i').data
                              let &ve = ve
                              if mode() =~ 't'
                                call feedkeys('a', 'n')
                              else
                                execute "normal! \<esc>la"
                              endif
                            endfunction

    1              0.000003 function! s:eval(dict, key, arg)
                              if has_key(a:dict, a:key) && type(a:dict[a:key]) == s:TYPE.funcref
                                let ret = copy(a:dict)
                                let ret[a:key] = call(a:dict[a:key], [a:arg])
                                return ret
                              endif
                              return a:dict
                            endfunction

    1              0.000002 function! fzf#vim#complete(...)
                              if a:0 == 0
                                let s:opts = fzf#wrap()
                              elseif type(a:1) == s:TYPE.dict
                                let s:opts = copy(a:1)
                              elseif type(a:1) == s:TYPE.string
                                let s:opts = extend({'source': a:1}, get(a:000, 1, fzf#wrap()))
                              else
                                echoerr 'Invalid argument: '.string(a:000)
                                return ''
                              endif
                              for s in ['sink', 'sink*']
                                if has_key(s:opts, s)
                                  call remove(s:opts, s)
                                endif
                              endfor

                              let eol = col('$')
                              let ve = &ve
                              set ve=all
                              let s:eol = col('.') == eol
                              let &ve = ve

                              let Prefix = s:pluck(s:opts, 'prefix', '\k*$')
                              if col('.') == 1
                                let s:query = ''
                              else
                                let full_prefix = getline('.')[0 : col('.')-2]
                                if type(Prefix) == s:TYPE.funcref
                                  let s:query = call(Prefix, [full_prefix])
                                else
                                  let s:query = matchstr(full_prefix, Prefix)
                                endif
                              endif
                              let s:opts = s:eval(s:opts, 'source', s:query)
                              let s:opts = s:eval(s:opts, 'options', s:query)
                              let s:opts = s:eval(s:opts, 'extra_options', s:query)
                              if has_key(s:opts, 'extra_options')
                                call s:merge_opts(s:opts, remove(s:opts, 'extra_options'))
                              endif
                              if has_key(s:opts, 'options')
                                if type(s:opts.options) == s:TYPE.list
                                  call add(s:opts.options, '--no-expect')
                                else
                                  let s:opts.options .= ' --no-expect'
                                endif
                              endif

                              call feedkeys("\<Plug>(-fzf-complete-trigger)")
                              return ''
                            endfunction

                            " ------------------------------------------------------------------
    1   0.000030   0.000022 let &cpo = s:cpo_save
    1              0.000008 unlet s:cpo_save

SCRIPT  /Users/philippe/.vim/plugged/vim-fugitive/syntax/fugitive.vim
Sourced 1 time
Total time:   0.010887
 Self time:   0.004983

count  total (s)   self (s)
    1              0.000019 if exists("b:current_syntax")
                              finish
    1              0.000003 endif

    1              0.000005 syn sync fromstart
    1              0.000002 syn spell notoplevel

    1   0.008578   0.002674 syn include @fugitiveDiff syntax/diff.vim

    1              0.000090 syn match fugitiveHeader /^[A-Z][a-z][^:]*:/ nextgroup=fugitiveHash,fugitiveSymbolicRef skipwhite
    1              0.000032 syn match fugitiveBareHeader /^Bare:/
    1              0.000045 syn match fugitiveHelpHeader /^Help:/ nextgroup=fugitiveHelpTag skipwhite
    1              0.000006 syn match fugitiveHelpTag    /\S\+/ contained

    1              0.000048 syn region fugitiveSection start=/^\%(.*(\d\+)$\)\@=/ contains=fugitiveHeading end=/^$/
    1              0.000006 syn cluster fugitiveSection contains=fugitiveSection
    1              0.000046 syn match fugitiveHeading /^[A-Z][a-z][^:]*\ze (\d\+)$/ contains=fugitivePreposition contained nextgroup=fugitiveCount skipwhite
    1              0.000006 syn match fugitiveCount /(\d\+)/hs=s+1,he=e-1 contained
    1              0.000022 syn match fugitivePreposition /\<\%([io]nto\|from\|to\|Rebasing\%( detached\)\=\)\>/ transparent contained nextgroup=fugitiveHash,fugitiveSymbolicRef skipwhite

    1              0.000028 syn match fugitiveInstruction /^\l\l\+\>/ contained containedin=@fugitiveSection nextgroup=fugitiveHash skipwhite
    1              0.000026 syn match fugitiveDone /^done\>/ contained containedin=@fugitiveSection nextgroup=fugitiveHash skipwhite
    1              0.000025 syn match fugitiveStop /^stop\>/ contained containedin=@fugitiveSection nextgroup=fugitiveHash skipwhite
    1              0.000027 syn match fugitiveModifier /^[MADRCU?]\{1,2} / contained containedin=@fugitiveSection
    1              0.000064 syn match fugitiveSymbolicRef /\.\@!\%(\.\.\@!\|[^[:space:][:cntrl:]\:.]\)\+\.\@<!/ contained
    1              0.000009 syn match fugitiveHash /^\x\{4,\}\S\@!/ contained containedin=@fugitiveSection
    1              0.000006 syn match fugitiveHash /\S\@<!\x\{4,\}\S\@!/ contained

    1              0.000036 syn region fugitiveHunk start=/^\%(@@\+ -\)\@=/ end=/^\%([A-Za-z?@]\|$\)\@=/ contains=@fugitiveDiff containedin=@fugitiveSection fold

    4              0.000016 for s:section in ['Untracked', 'Unstaged', 'Staged']
    3              0.000170   exe 'syn region fugitive' . s:section . 'Section start=/^\%(' . s:section . ' .*(\d\+)$\)\@=/ contains=fugitive' . s:section . 'Heading end=/^$/'
    3              0.000099   exe 'syn match fugitive' . s:section . 'Modifier /^[MADRCU?] / contained containedin=fugitive' . s:section . 'Section'
    3              0.000029   exe 'syn cluster fugitiveSection add=fugitive' . s:section . 'Section'
    3              0.000052   exe 'syn match fugitive' . s:section . 'Heading /^[A-Z][a-z][^:]*\ze (\d\+)$/ contains=fugitivePreposition contained nextgroup=fugitiveCount skipwhite'
    4              0.000006 endfor
    1              0.000004 unlet s:section

    1              0.000004 hi def link fugitiveBareHeader fugitiveHeader
    1              0.000003 hi def link fugitiveHelpHeader fugitiveHeader
    1              0.000017 hi def link fugitiveHeader Label
    1              0.000017 hi def link fugitiveHelpTag Tag
    1              0.000017 hi def link fugitiveHeading PreProc
    1              0.000018 hi def link fugitiveUntrackedHeading PreCondit
    1              0.000017 hi def link fugitiveUnstagedHeading Macro
    1              0.000017 hi def link fugitiveStagedHeading Include
    1              0.000018 hi def link fugitiveModifier Type
    1              0.000018 hi def link fugitiveUntrackedModifier StorageClass
    1              0.000017 hi def link fugitiveUnstagedModifier Structure
    1              0.000017 hi def link fugitiveStagedModifier Typedef
    1              0.000018 hi def link fugitiveInstruction Type
    1              0.000017 hi def link fugitiveStop Function
    1              0.000018 hi def link fugitiveHash Identifier
    1              0.000017 hi def link fugitiveSymbolicRef Function
    1              0.000018 hi def link fugitiveCount Number

    1              0.000009 let b:current_syntax = "fugitive"

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/diff.vim
Sourced 1 time
Total time:   0.005570
 Self time:   0.005570

count  total (s)   self (s)
    1              0.000045 if has_key(g:polyglot_is_disabled, 'diff')
                              finish
    1              0.000001 endif

                            " Vim syntax file
                            " Language:	Diff (context or unified)
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            "               Translations by Jakson Alves de Aquino.
                            " Last Change:	2016 Apr 02

                            " Quit when a (custom) syntax file was already loaded
    1              0.000006 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
    1              0.000004 scriptencoding utf-8

    1              0.000080 syn match diffOnly	"^Only in .*"
    1              0.000029 syn match diffIdentical	"^Files .* and .* are identical$"
    1              0.000025 syn match diffDiffer	"^Files .* and .* differ$"
    1              0.000026 syn match diffBDiffer	"^Binary files .* and .* differ$"
    1              0.000027 syn match diffIsA	"^File .* is a .* while file .* is a .*"
    1              0.000029 syn match diffNoEOL	"^\\ No newline at end of file .*"
    1              0.000027 syn match diffCommon	"^Common subdirectories: .*"

                            " Disable the translations by setting diff_translations to zero.
    1              0.000008 if !exists("diff_translations") || diff_translations

                            " ca
    1              0.000008 syn match diffOnly	"^Només a .*"
    1              0.000008 syn match diffIdentical	"^Els fitxers .* i .* són idèntics$"
    1              0.000007 syn match diffDiffer	"^Els fitxers .* i .* difereixen$"
    1              0.000008 syn match diffBDiffer	"^Els fitxers .* i .* difereixen$"
    1              0.000011 syn match diffIsA	"^El fitxer .* és un .* mentre que el fitxer .* és un .*"
    1              0.000042 syn match diffNoEOL	"^\\ No hi ha cap caràcter de salt de línia al final del fitxer"
    1              0.000007 syn match diffCommon	"^Subdirectoris comuns: .* i .*"

                            " cs
    1              0.000005 syn match diffOnly	"^Pouze v .*"
    1              0.000008 syn match diffIdentical	"^Soubory .* a .* jsou identické$"
    1              0.000007 syn match diffDiffer	"^Soubory .* a .* jsou různé$"
    1              0.000009 syn match diffBDiffer	"^Binární soubory .* a .* jsou rozdílné$"
    1              0.000007 syn match diffBDiffer	"^Soubory .* a .* jsou různé$"
    1              0.000008 syn match diffIsA	"^Soubor .* je .* pokud soubor .* je .*"
    1              0.000019 syn match diffNoEOL	"^\\ Chybí znak konce řádku na konci souboru"
    1              0.000009 syn match diffCommon	"^Společné podadresáře: .* a .*"

                            " da
    1              0.000007 syn match diffOnly	"^Kun i .*"
    1              0.000007 syn match diffIdentical	"^Filerne .* og .* er identiske$"
    1              0.000007 syn match diffDiffer	"^Filerne .* og .* er forskellige$"
    1              0.000008 syn match diffBDiffer	"^Binære filer .* og .* er forskellige$"
    1              0.000008 syn match diffIsA	"^Filen .* er en .* mens filen .* er en .*"
    1              0.000008 syn match diffNoEOL	"^\\ Intet linjeskift ved filafslutning"
    1              0.000009 syn match diffCommon	"^Identiske underkataloger: .* og .*"

                            " de
    1              0.000005 syn match diffOnly	"^Nur in .*"
    1              0.000010 syn match diffIdentical	"^Dateien .* und .* sind identisch.$"
    1              0.000009 syn match diffDiffer	"^Dateien .* und .* sind verschieden.$"
    1              0.000012 syn match diffBDiffer	"^Binärdateien .* and .* sind verschieden.$"
    1              0.000009 syn match diffBDiffer	"^Binärdateien .* und .* sind verschieden.$"
    1              0.000011 syn match diffIsA	"^Datei .* ist ein .* während Datei .* ein .* ist.$"
    1              0.000008 syn match diffNoEOL	"^\\ Kein Zeilenumbruch am Dateiende."
    1              0.000010 syn match diffCommon	"^Gemeinsame Unterverzeichnisse: .* und .*.$"

                            " el
    1              0.000010 syn match diffOnly	"^Μόνο στο .*"
    1              0.000018 syn match diffIdentical	"^Τα αρχεία .* καί .* είναι πανομοιότυπα$"
    1              0.000017 syn match diffDiffer	"^Τα αρχεία .* και .* διαφέρουν$"
    1              0.000017 syn match diffBDiffer	"^Τα αρχεία .* και .* διαφέρουν$"
    1              0.000022 syn match diffIsA	"^Το αρχείο .* είναι .* ενώ το αρχείο .* είναι .*"
    1              0.000029 syn match diffNoEOL	"^\\ Δεν υπάρχει χαρακτήρας νέας γραμμής στο τέλος του αρχείου"
    1              0.000022 syn match diffCommon	"^Οι υποκατάλογοι .* και .* είναι ταυτόσημοι$"

                            " eo
    1              0.000005 syn match diffOnly	"^Nur en .*"
    1              0.000010 syn match diffIdentical	"^Dosieroj .* kaj .* estas samaj$"
    1              0.000009 syn match diffDiffer	"^Dosieroj .* kaj .* estas malsamaj$"
    1              0.000008 syn match diffBDiffer	"^Dosieroj .* kaj .* estas malsamaj$"
    1              0.000009 syn match diffIsA	"^Dosiero .* estas .*, dum dosiero .* estas .*"
    1              0.000008 syn match diffNoEOL	"^\\ Mankas linifino ĉe fino de dosiero"
    1              0.000007 syn match diffCommon	"^Komunaj subdosierujoj: .* kaj .*"

                            " es
    1              0.000005 syn match diffOnly	"^Sólo en .*"
    1              0.000014 syn match diffIdentical	"^Los ficheros .* y .* son idénticos$"
    1              0.000011 syn match diffDiffer	"^Los ficheros .* y .* son distintos$"
    1              0.000009 syn match diffBDiffer	"^Los ficheros binarios .* y .* son distintos$"
    1              0.000010 syn match diffIsA	"^El fichero .* es un .* mientras que el .* es un .*"
    1              0.001199 syn match diffNoEOL	"^\\ No hay ningún carácter de nueva línea al final del fichero"
    1              0.000012 syn match diffCommon	"^Subdirectorios comunes: .* y .*"

                            " fi
    1              0.000007 syn match diffOnly	"^Vain hakemistossa .*"
    1              0.000018 syn match diffIdentical	"^Tiedostot .* ja .* ovat identtiset$"
    1              0.000007 syn match diffDiffer	"^Tiedostot .* ja .* eroavat$"
    1              0.000008 syn match diffBDiffer	"^Binääritiedostot .* ja .* eroavat$"
    1              0.000010 syn match diffIsA	"^Tiedosto .* on .*, kun taas tiedosto .* on .*"
    1              0.000008 syn match diffNoEOL	"^\\ Ei rivinvaihtoa tiedoston lopussa"
    1              0.000007 syn match diffCommon	"^Yhteiset alihakemistot: .* ja .*"

                            " fr
    1              0.000006 syn match diffOnly	"^Seulement dans .*"
    1              0.000008 syn match diffIdentical	"^Les fichiers .* et .* sont identiques.*"
    1              0.000010 syn match diffDiffer	"^Les fichiers .* et .* sont différents.*"
    1              0.000009 syn match diffBDiffer	"^Les fichiers binaires .* et .* sont différents.*"
    1              0.000010 syn match diffIsA	"^Le fichier .* est un .* alors que le fichier .* est un .*"
    1              0.000009 syn match diffNoEOL	"^\\ Pas de fin de ligne à la fin du fichier.*"
    1              0.000010 syn match diffCommon	"^Les sous-répertoires .* et .* sont identiques.*"

                            " ga
    1              0.000005 syn match diffOnly	"^I .* amháin: .*"
    1              0.000008 syn match diffIdentical	"^Is comhionann iad na comhaid .* agus .*"
    1              0.000008 syn match diffDiffer	"^Tá difríocht idir na comhaid .* agus .*"
    1              0.000008 syn match diffBDiffer	"^Tá difríocht idir na comhaid .* agus .*"
    1              0.000008 syn match diffIsA	"^Tá comhad .* ina .* ach tá comhad .* ina .*"
    1              0.000008 syn match diffNoEOL	"^\\ Gan líne nua ag an chomhadchríoch"
    1              0.000008 syn match diffCommon	"^Fochomhadlanna i gcoitianta: .* agus .*"

                            " gl
    1              0.000004 syn match diffOnly	"^Só en .*"
    1              0.000014 syn match diffIdentical	"^Os ficheiros .* e .* son idénticos$"
    1              0.000008 syn match diffDiffer	"^Os ficheiros .* e .* son diferentes$"
    1              0.000010 syn match diffBDiffer	"^Os ficheiros binarios .* e .* son diferentes$"
    1              0.000012 syn match diffIsA	"^O ficheiro .* é un .* mentres que o ficheiro .* é un .*"
    1              0.000009 syn match diffNoEOL	"^\\ Non hai un salto de liña na fin da liña"
    1              0.000007 syn match diffCommon	"^Subdirectorios comúns: .* e .*"

                            " he
                            " ^.* are expansive patterns for long lines, so disabled unless we can match
                            " some specific hebrew chars
    1              0.000139 if search('\%u05d5\|\%u05d1', 'nw', '', 100)
                              syn match diffOnly	"^.*-ב קר אצמנ .*"
                              syn match diffIdentical	"^םיהז םניה .*-ו .* םיצבקה$"
                              syn match diffDiffer	"^הזמ הז םינוש `.*'-ו `.*' םיצבקה$"
                              syn match diffBDiffer	"^הזמ הז םינוש `.*'-ו `.*' םיירניב םיצבק$"
                              syn match diffIsA	"^.* .*-ל .* .* תוושהל ןתינ אל$"
                              syn match diffNoEOL	"^\\ ץבוקה ףוסב השד.-הרוש ות רס."
                              syn match diffCommon	"^.*-ו .* :תוהז תויקית-תת$"
    1              0.000002 endif

                            " hr
    1              0.000005 syn match diffOnly	"^Samo u .*"
    1              0.000007 syn match diffIdentical	"^Datoteke .* i .* su identične$"
    1              0.000007 syn match diffDiffer	"^Datoteke .* i .* se razlikuju$"
    1              0.000008 syn match diffBDiffer	"^Binarne datoteke .* i .* se razlikuju$"
    1              0.000009 syn match diffIsA	"^Datoteka .* je .*, a datoteka .* je .*"
    1              0.000008 syn match diffNoEOL	"^\\ Nema novog retka na kraju datoteke"
    1              0.000007 syn match diffCommon	"^Uobičajeni poddirektoriji: .* i .*"

                            " hu
    1              0.000012 syn match diffOnly	"^Csak .* -ben: .*"
    1              0.000007 syn match diffIdentical	"^.* és .* fájlok azonosak$"
    1              0.000008 syn match diffDiffer	"^A(z) .* és a(z) .* fájlok különböznek$"
    1              0.000008 syn match diffBDiffer	"^A(z) .* és a(z) .* fájlok különböznek$"
    1              0.000012 syn match diffIsA	"^A(z) .* fájl egy .*, viszont a(z) .* fájl egy .*"
    1              0.000007 syn match diffNoEOL	"^\\ Nincs újsor a fájl végén"
    1              0.000007 syn match diffCommon	"^Közös alkönyvtárak: .* és .*"

                            " id
    1              0.000021 syn match diffOnly	"^Hanya dalam .*"
    1              0.000007 syn match diffIdentical	"^File .* dan .* identik$"
    1              0.000010 syn match diffDiffer	"^Berkas .* dan .* berbeda$"
    1              0.000007 syn match diffBDiffer	"^File biner .* dan .* berbeda$"
    1              0.000011 syn match diffIsA	"^File .* adalah .* sementara file .* adalah .*"
    1              0.000009 syn match diffNoEOL	"^\\ Tidak ada baris-baru di akhir dari berkas"
    1              0.000007 syn match diffCommon	"^Subdirektori sama: .* dan .*"

                            " it
    1              0.000007 syn match diffOnly	"^Solo in .*"
    1              0.000007 syn match diffIdentical	"^I file .* e .* sono identici$"
    1              0.000007 syn match diffDiffer	"^I file .* e .* sono diversi$"
    1              0.000007 syn match diffBDiffer	"^I file .* e .* sono diversi$"
    1              0.000008 syn match diffBDiffer	"^I file binari .* e .* sono diversi$"
    1              0.000011 syn match diffIsA	"^File .* è un .* mentre file .* è un .*"
    1              0.000008 syn match diffNoEOL	"^\\ Manca newline alla fine del file"
    1              0.000007 syn match diffCommon	"^Sottodirectory in comune: .* e .*"

                            " ja
    1              0.000010 syn match diffOnly	"^.*だけに発見: .*"
    1              0.000008 syn match diffIdentical	"^ファイル.*と.*は同一$"
    1              0.000009 syn match diffDiffer	"^ファイル.*と.*は違います$"
    1              0.000016 syn match diffBDiffer	"^バイナリー・ファイル.*と.*は違います$"
    1              0.000012 syn match diffIsA	"^ファイル.*は.*、ファイル.*は.*"
    1              0.000012 syn match diffNoEOL	"^\\ ファイル末尾に改行がありません"
    1              0.000010 syn match diffCommon	"^共通の下位ディレクトリー: .*と.*"

                            " ja DiffUtils 3.3
    1              0.000007 syn match diffOnly	"^.* のみに存在: .*"
    1              0.000011 syn match diffIdentical	"^ファイル .* と .* は同一です$"
    1              0.000010 syn match diffDiffer	"^ファイル .* と .* は異なります$"
    1              0.000015 syn match diffBDiffer	"^バイナリーファイル .* と.* は異なります$"
    1              0.000017 syn match diffIsA	"^ファイル .* は .* です。一方、ファイル .* は .* です$"
    1              0.000013 syn match diffNoEOL	"^\\ ファイル末尾に改行がありません"
    1              0.000011 syn match diffCommon	"^共通のサブディレクトリー: .* と .*"

                            " lv
    1              0.000005 syn match diffOnly	"^Tikai iekš .*"
    1              0.000007 syn match diffIdentical	"^Fails .* un .* ir identiski$"
    1              0.000008 syn match diffDiffer	"^Faili .* un .* atšķiras$"
    1              0.000007 syn match diffBDiffer	"^Faili .* un .* atšķiras$"
    1              0.000019 syn match diffBDiffer	"^Binārie faili .* un .* atšķiras$"
    1              0.000008 syn match diffIsA	"^Fails .* ir .* kamēr fails .* ir .*"
    1              0.000009 syn match diffNoEOL	"^\\ Nav jaunu rindu faila beigās"
    1              0.000008 syn match diffCommon	"^Kopējās apakšdirektorijas: .* un .*"

                            " ms
    1              0.000006 syn match diffOnly	"^Hanya dalam .*"
    1              0.000009 syn match diffIdentical	"^Fail .* dan .* adalah serupa$"
    1              0.000010 syn match diffDiffer	"^Fail .* dan .* berbeza$"
    1              0.000006 syn match diffBDiffer	"^Fail .* dan .* berbeza$"
    1              0.000008 syn match diffIsA	"^Fail .* adalah .* manakala fail .* adalah .*"
    1              0.000008 syn match diffNoEOL	"^\\ Tiada baris baru pada penghujung fail"
    1              0.000007 syn match diffCommon	"^Subdirektori umum: .* dan .*"

                            " nl
    1              0.000005 syn match diffOnly	"^Alleen in .*"
    1              0.000007 syn match diffIdentical	"^Bestanden .* en .* zijn identiek$"
    1              0.000010 syn match diffDiffer	"^Bestanden .* en .* zijn verschillend$"
    1              0.000008 syn match diffBDiffer	"^Bestanden .* en .* zijn verschillend$"
    1              0.000011 syn match diffBDiffer	"^Binaire bestanden .* en .* zijn verschillend$"
    1              0.000011 syn match diffIsA	"^Bestand .* is een .* terwijl bestand .* een .* is$"
    1              0.000028 syn match diffNoEOL	"^\\ Geen regeleindeteken (LF) aan einde van bestand"
    1              0.000008 syn match diffCommon	"^Gemeenschappelijke submappen: .* en .*"

                            " pl
    1              0.000004 syn match diffOnly	"^Tylko w .*"
    1              0.000007 syn match diffIdentical	"^Pliki .* i .* są identyczne$"
    1              0.000006 syn match diffDiffer	"^Pliki .* i .* różnią się$"
    1              0.000006 syn match diffBDiffer	"^Pliki .* i .* różnią się$"
    1              0.000007 syn match diffBDiffer	"^Binarne pliki .* i .* różnią się$"
    1              0.000008 syn match diffIsA	"^Plik .* jest .*, podczas gdy plik .* jest .*"
    1              0.000008 syn match diffNoEOL	"^\\ Brak znaku nowej linii na końcu pliku"
    1              0.000009 syn match diffCommon	"^Wspólne podkatalogi: .* i .*"

                            " pt_BR
    1              0.000009 syn match diffOnly	"^Somente em .*"
    1              0.000005 syn match diffOnly	"^Apenas em .*"
    1              0.000008 syn match diffIdentical	"^Os aquivos .* e .* são idênticos$"
    1              0.000007 syn match diffDiffer	"^Os arquivos .* e .* são diferentes$"
    1              0.000009 syn match diffBDiffer	"^Os arquivos binários .* e .* são diferentes$"
    1              0.000009 syn match diffIsA	"^O arquivo .* é .* enquanto o arquivo .* é .*"
    1              0.000009 syn match diffNoEOL	"^\\ Falta o caracter nova linha no final do arquivo"
    1              0.000007 syn match diffCommon	"^Subdiretórios idênticos: .* e .*"

                            " ro
    1              0.000005 syn match diffOnly	"^Doar în .*"
    1              0.000007 syn match diffIdentical	"^Fişierele .* şi .* sunt identice$"
    1              0.000006 syn match diffDiffer	"^Fişierele .* şi .* diferă$"
    1              0.000007 syn match diffBDiffer	"^Fişierele binare .* şi .* diferă$"
    1              0.000010 syn match diffIsA	"^Fişierul .* este un .* pe când fişierul .* este un .*.$"
    1              0.000010 syn match diffNoEOL	"^\\ Nici un element de linie nouă la sfârşitul fişierului"
    1              0.000010 syn match diffCommon	"^Subdirectoare comune: .* şi .*.$"

                            " ru
    1              0.000007 syn match diffOnly	"^Только в .*"
    1              0.000011 syn match diffIdentical	"^Файлы .* и .* идентичны$"
    1              0.000011 syn match diffDiffer	"^Файлы .* и .* различаются$"
    1              0.000011 syn match diffBDiffer	"^Файлы .* и .* различаются$"
    1              0.000017 syn match diffIsA	"^Файл .* это .*, тогда как файл .* -- .*"
    1              0.000549 syn match diffNoEOL	"^\\ В конце файла нет новой строки"
    1              0.000016 syn match diffCommon	"^Общие подкаталоги: .* и .*"

                            " sr
    1              0.000007 syn match diffOnly	"^Само у .*"
    1              0.000018 syn match diffIdentical	"^Датотеке „.*“ и „.*“ се подударају$"
    1              0.000023 syn match diffDiffer	"^Датотеке .* и .* различите$"
    1              0.000017 syn match diffBDiffer	"^Бинарне датотеке .* и .* различите$"
    1              0.000027 syn match diffIsA	"^Датотека „.*“ је „.*“ док је датотека „.*“ „.*“$"
    1              0.000018 syn match diffNoEOL	"^\\ Без новог реда на крају датотеке"
    1              0.000017 syn match diffCommon	"^Заједнички поддиректоријуми: .* и .*"

                            " sv
    1              0.000005 syn match diffOnly	"^Endast i .*"
    1              0.000007 syn match diffIdentical	"^Filerna .* och .* är lika$"
    1              0.000007 syn match diffDiffer	"^Filerna .* och .* skiljer$"
    1              0.000007 syn match diffBDiffer	"^Filerna .* och .* skiljer$"
    1              0.000009 syn match diffIsA	"^Fil .* är en .* medan fil .* är en .*"
    1              0.000008 syn match diffBDiffer	"^De binära filerna .* och .* skiljer$"
    1              0.000008 syn match diffIsA	"^Filen .* är .* medan filen .* är .*"
    1              0.000007 syn match diffNoEOL	"^\\ Ingen nyrad vid filslut"
    1              0.000008 syn match diffCommon	"^Lika underkataloger: .* och .*"

                            " tr
    1              0.000009 syn match diffOnly	"^Yalnızca .*'da: .*"
    1              0.000012 syn match diffIdentical	"^.* ve .* dosyaları birbirinin aynı$"
    1              0.000011 syn match diffDiffer	"^.* ve .* dosyaları birbirinden farklı$"
    1              0.000009 syn match diffBDiffer	"^.* ve .* dosyaları birbirinden farklı$"
    1              0.000008 syn match diffBDiffer	"^İkili .* ve .* birbirinden farklı$"
    1              0.000012 syn match diffIsA	"^.* dosyası, bir .*, halbuki .* dosyası bir .*"
    1              0.000008 syn match diffNoEOL	"^\\ Dosya sonunda yenisatır yok."
    1              0.000007 syn match diffCommon	"^Ortak alt dizinler: .* ve .*"

                            " uk
    1              0.000009 syn match diffOnly	"^Лише у .*"
    1              0.000013 syn match diffIdentical	"^Файли .* та .* ідентичні$"
    1              0.000016 syn match diffDiffer	"^Файли .* та .* відрізняються$"
    1              0.000014 syn match diffBDiffer	"^Файли .* та .* відрізняються$"
    1              0.000022 syn match diffBDiffer	"^Двійкові файли .* та .* відрізняються$"
    1              0.000018 syn match diffIsA	"^Файл .* це .*, тоді як файл .* -- .*"
    1              0.000019 syn match diffNoEOL	"^\\ Наприкінці файлу немає нового рядка"
    1              0.000014 syn match diffCommon	"^Спільні підкаталоги: .* та .*"

                            " vi
    1              0.000008 syn match diffOnly	"^Chỉ trong .*"
    1              0.000012 syn match diffIdentical	"^Hai tập tin .* và .* là bằng nhau.$"
    1              0.000009 syn match diffIdentical	"^Cả .* và .* là cùng một tập tin$"
    1              0.000009 syn match diffDiffer	"^Hai tập tin .* và .* là khác nhau.$"
    1              0.000010 syn match diffBDiffer	"^Hai tập tin nhị phân .* và .* khác nhau$"
    1              0.000015 syn match diffIsA	"^Tập tin .* là một .* trong khi tập tin .* là một .*.$"
    1              0.000009 syn match diffBDiffer	"^Hai tập tin .* và .* là khác nhau.$"
    1              0.000014 syn match diffIsA	"^Tập tin .* là một .* còn tập tin .* là một .*.$"
    1              0.000012 syn match diffNoEOL	"^\\ Không có ký tự dòng mới tại kêt thức tập tin."
    1              0.000008 syn match diffCommon	"^Thư mục con chung: .* và .*"

                            " zh_CN
    1              0.000010 syn match diffOnly	"^只在 .* 存在：.*"
    1              0.000018 syn match diffIdentical	"^檔案 .* 和 .* 相同$"
    1              0.000010 syn match diffDiffer	"^文件 .* 和 .* 不同$"
    1              0.000007 syn match diffBDiffer	"^文件 .* 和 .* 不同$"
    1              0.000008 syn match diffIsA	"^文件 .* 是.*而文件 .* 是.*"
    1              0.000009 syn match diffNoEOL	"^\\ 文件尾没有 newline 字符"
    1              0.000011 syn match diffCommon	"^.* 和 .* 有共同的子目录$"

                            " zh_TW
    1              0.000007 syn match diffOnly	"^只在 .* 存在：.*"
    1              0.000007 syn match diffIdentical	"^檔案 .* 和 .* 相同$"
    1              0.000007 syn match diffDiffer	"^檔案 .* 與 .* 不同$"
    1              0.000008 syn match diffBDiffer	"^二元碼檔 .* 與 .* 不同$"
    1              0.000010 syn match diffIsA	"^檔案 .* 是.*而檔案 .* 是.*"
    1              0.000009 syn match diffNoEOL	"^\\ 檔案末沒有 newline 字元"
    1              0.000009 syn match diffCommon	"^.* 和 .* 有共同的副目錄$"

    1              0.000002 endif


    1              0.000015 syn match diffRemoved	"^-.*"
    1              0.000008 syn match diffRemoved	"^<.*"
    1              0.000007 syn match diffAdded	"^+.*"
    1              0.000010 syn match diffAdded	"^>.*"
    1              0.000007 syn match diffChanged	"^! .*"

    1              0.000035 syn match diffSubname	" @@..*"ms=s+3 contained
    1              0.000010 syn match diffLine	"^@.*" contains=diffSubname
    1              0.000009 syn match diffLine	"^\<\d\+\>.*"
    1              0.000007 syn match diffLine	"^\*\*\*\*.*"
    1              0.000007 syn match diffLine	"^---$"

                            " Some versions of diff have lines like "#c#" and "#d#" (where # is a number)
    1              0.000011 syn match diffLine	"^\d\+\(,\d\+\)\=[cda]\d\+\>.*"

    1              0.000009 syn match diffFile	"^diff\>.*"
    1              0.000011 syn match diffFile	"^+++ .*"
    1              0.000008 syn match diffFile	"^Index: .*"
    1              0.000007 syn match diffFile	"^==== .*"
    1              0.000007 syn match diffOldFile	"^\*\*\* .*"
    1              0.000007 syn match diffNewFile	"^--- .*"

                            " Used by git
    1              0.000008 syn match diffIndexLine	"^index \x\x\x\x.*"

    1              0.000020 syn match diffComment	"^#.*"

                            " Define the default highlighting.
                            " Only used when an item doesn't have highlighting yet
    1              0.000009 hi def link diffOldFile		diffFile
    1              0.000007 hi def link diffNewFile		diffFile
    1              0.000018 hi def link diffIndexLine	PreProc
    1              0.000019 hi def link diffFile		Type
    1              0.000016 hi def link diffOnly		Constant
    1              0.000016 hi def link diffIdentical	Constant
    1              0.000016 hi def link diffDiffer		Constant
    1              0.000016 hi def link diffBDiffer		Constant
    1              0.000016 hi def link diffIsA		Constant
    1              0.000016 hi def link diffNoEOL		Constant
    1              0.000016 hi def link diffCommon		Constant
    1              0.000018 hi def link diffRemoved		Special
    1              0.000018 hi def link diffChanged		PreProc
    1              0.000019 hi def link diffAdded		Identifier
    1              0.000018 hi def link diffLine		Statement
    1              0.000016 hi def link diffSubname		PreProc
    1              0.000016 hi def link diffComment		Comment

    1              0.000009 let b:current_syntax = "diff"

                            " vim: ts=8 sw=2

SCRIPT  /usr/local/Cellar/neovim/HEAD-759a054/share/nvim/runtime/syntax/diff.vim
Sourced 1 time
Total time:   0.000258
 Self time:   0.000258

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Diff (context or unified)
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            "               Translations by Jakson Alves de Aquino.
                            " Last Change:	2016 Apr 02

                            " Quit when a (custom) syntax file was already loaded
    1              0.000016 if exists("b:current_syntax")
    1              0.000003   finish
                            endif
                            scriptencoding utf-8

                            syn match diffOnly	"^Only in .*"
                            syn match diffIdentical	"^Files .* and .* are identical$"
                            syn match diffDiffer	"^Files .* and .* differ$"
                            syn match diffBDiffer	"^Binary files .* and .* differ$"
                            syn match diffIsA	"^File .* is a .* while file .* is a .*"
                            syn match diffNoEOL	"^\\ No newline at end of file .*"
                            syn match diffCommon	"^Common subdirectories: .*"

                            " Disable the translations by setting diff_translations to zero.
                            if !exists("diff_translations") || diff_translations

                            " ca
                            syn match diffOnly	"^Només a .*"
                            syn match diffIdentical	"^Els fitxers .* i .* són idèntics$"
                            syn match diffDiffer	"^Els fitxers .* i .* difereixen$"
                            syn match diffBDiffer	"^Els fitxers .* i .* difereixen$"
                            syn match diffIsA	"^El fitxer .* és un .* mentre que el fitxer .* és un .*"
                            syn match diffNoEOL	"^\\ No hi ha cap caràcter de salt de línia al final del fitxer"
                            syn match diffCommon	"^Subdirectoris comuns: .* i .*"

                            " cs
                            syn match diffOnly	"^Pouze v .*"
                            syn match diffIdentical	"^Soubory .* a .* jsou identické$"
                            syn match diffDiffer	"^Soubory .* a .* jsou různé$"
                            syn match diffBDiffer	"^Binární soubory .* a .* jsou rozdílné$"
                            syn match diffBDiffer	"^Soubory .* a .* jsou různé$"
                            syn match diffIsA	"^Soubor .* je .* pokud soubor .* je .*"
                            syn match diffNoEOL	"^\\ Chybí znak konce řádku na konci souboru"
                            syn match diffCommon	"^Společné podadresáře: .* a .*"

                            " da
                            syn match diffOnly	"^Kun i .*"
                            syn match diffIdentical	"^Filerne .* og .* er identiske$"
                            syn match diffDiffer	"^Filerne .* og .* er forskellige$"
                            syn match diffBDiffer	"^Binære filer .* og .* er forskellige$"
                            syn match diffIsA	"^Filen .* er en .* mens filen .* er en .*"
                            syn match diffNoEOL	"^\\ Intet linjeskift ved filafslutning"
                            syn match diffCommon	"^Identiske underkataloger: .* og .*"

                            " de
                            syn match diffOnly	"^Nur in .*"
                            syn match diffIdentical	"^Dateien .* und .* sind identisch.$"
                            syn match diffDiffer	"^Dateien .* und .* sind verschieden.$"
                            syn match diffBDiffer	"^Binärdateien .* and .* sind verschieden.$"
                            syn match diffBDiffer	"^Binärdateien .* und .* sind verschieden.$"
                            syn match diffIsA	"^Datei .* ist ein .* während Datei .* ein .* ist.$"
                            syn match diffNoEOL	"^\\ Kein Zeilenumbruch am Dateiende."
                            syn match diffCommon	"^Gemeinsame Unterverzeichnisse: .* und .*.$"

                            " el
                            syn match diffOnly	"^Μόνο στο .*"
                            syn match diffIdentical	"^Τα αρχεία .* καί .* είναι πανομοιότυπα$"
                            syn match diffDiffer	"^Τα αρχεία .* και .* διαφέρουν$"
                            syn match diffBDiffer	"^Τα αρχεία .* και .* διαφέρουν$"
                            syn match diffIsA	"^Το αρχείο .* είναι .* ενώ το αρχείο .* είναι .*"
                            syn match diffNoEOL	"^\\ Δεν υπάρχει χαρακτήρας νέας γραμμής στο τέλος του αρχείου"
                            syn match diffCommon	"^Οι υποκατάλογοι .* και .* είναι ταυτόσημοι$"

                            " eo
                            syn match diffOnly	"^Nur en .*"
                            syn match diffIdentical	"^Dosieroj .* kaj .* estas samaj$"
                            syn match diffDiffer	"^Dosieroj .* kaj .* estas malsamaj$"
                            syn match diffBDiffer	"^Dosieroj .* kaj .* estas malsamaj$"
                            syn match diffIsA	"^Dosiero .* estas .*, dum dosiero .* estas .*"
                            syn match diffNoEOL	"^\\ Mankas linifino ĉe fino de dosiero"
                            syn match diffCommon	"^Komunaj subdosierujoj: .* kaj .*"

                            " es
                            syn match diffOnly	"^Sólo en .*"
                            syn match diffIdentical	"^Los ficheros .* y .* son idénticos$"
                            syn match diffDiffer	"^Los ficheros .* y .* son distintos$"
                            syn match diffBDiffer	"^Los ficheros binarios .* y .* son distintos$"
                            syn match diffIsA	"^El fichero .* es un .* mientras que el .* es un .*"
                            syn match diffNoEOL	"^\\ No hay ningún carácter de nueva línea al final del fichero"
                            syn match diffCommon	"^Subdirectorios comunes: .* y .*"

                            " fi
                            syn match diffOnly	"^Vain hakemistossa .*"
                            syn match diffIdentical	"^Tiedostot .* ja .* ovat identtiset$"
                            syn match diffDiffer	"^Tiedostot .* ja .* eroavat$"
                            syn match diffBDiffer	"^Binääritiedostot .* ja .* eroavat$"
                            syn match diffIsA	"^Tiedosto .* on .*, kun taas tiedosto .* on .*"
                            syn match diffNoEOL	"^\\ Ei rivinvaihtoa tiedoston lopussa"
                            syn match diffCommon	"^Yhteiset alihakemistot: .* ja .*"

                            " fr
                            syn match diffOnly	"^Seulement dans .*"
                            syn match diffIdentical	"^Les fichiers .* et .* sont identiques.*"
                            syn match diffDiffer	"^Les fichiers .* et .* sont différents.*"
                            syn match diffBDiffer	"^Les fichiers binaires .* et .* sont différents.*"
                            syn match diffIsA	"^Le fichier .* est un .* alors que le fichier .* est un .*"
                            syn match diffNoEOL	"^\\ Pas de fin de ligne à la fin du fichier.*"
                            syn match diffCommon	"^Les sous-répertoires .* et .* sont identiques.*"

                            " ga
                            syn match diffOnly	"^I .* amháin: .*"
                            syn match diffIdentical	"^Is comhionann iad na comhaid .* agus .*"
                            syn match diffDiffer	"^Tá difríocht idir na comhaid .* agus .*"
                            syn match diffBDiffer	"^Tá difríocht idir na comhaid .* agus .*"
                            syn match diffIsA	"^Tá comhad .* ina .* ach tá comhad .* ina .*"
                            syn match diffNoEOL	"^\\ Gan líne nua ag an chomhadchríoch"
                            syn match diffCommon	"^Fochomhadlanna i gcoitianta: .* agus .*"

                            " gl
                            syn match diffOnly	"^Só en .*"
                            syn match diffIdentical	"^Os ficheiros .* e .* son idénticos$"
                            syn match diffDiffer	"^Os ficheiros .* e .* son diferentes$"
                            syn match diffBDiffer	"^Os ficheiros binarios .* e .* son diferentes$"
                            syn match diffIsA	"^O ficheiro .* é un .* mentres que o ficheiro .* é un .*"
                            syn match diffNoEOL	"^\\ Non hai un salto de liña na fin da liña"
                            syn match diffCommon	"^Subdirectorios comúns: .* e .*"

                            " he
                            " ^.* are expansive patterns for long lines, so disabled unless we can match
                            " some specific hebrew chars
                            if search('\%u05d5\|\%u05d1', 'nw', '', 100)
                              syn match diffOnly	"^.*-ב קר אצמנ .*"
                              syn match diffIdentical	"^םיהז םניה .*-ו .* םיצבקה$"
                              syn match diffDiffer	"^הזמ הז םינוש `.*'-ו `.*' םיצבקה$"
                              syn match diffBDiffer	"^הזמ הז םינוש `.*'-ו `.*' םיירניב םיצבק$"
                              syn match diffIsA	"^.* .*-ל .* .* תוושהל ןתינ אל$"
                              syn match diffNoEOL	"^\\ ץבוקה ףוסב השד.-הרוש ות רס."
                              syn match diffCommon	"^.*-ו .* :תוהז תויקית-תת$"
                            endif

                            " hr
                            syn match diffOnly	"^Samo u .*"
                            syn match diffIdentical	"^Datoteke .* i .* su identične$"
                            syn match diffDiffer	"^Datoteke .* i .* se razlikuju$"
                            syn match diffBDiffer	"^Binarne datoteke .* i .* se razlikuju$"
                            syn match diffIsA	"^Datoteka .* je .*, a datoteka .* je .*"
                            syn match diffNoEOL	"^\\ Nema novog retka na kraju datoteke"
                            syn match diffCommon	"^Uobičajeni poddirektoriji: .* i .*"

                            " hu
                            syn match diffOnly	"^Csak .* -ben: .*"
                            syn match diffIdentical	"^.* és .* fájlok azonosak$"
                            syn match diffDiffer	"^A(z) .* és a(z) .* fájlok különböznek$"
                            syn match diffBDiffer	"^A(z) .* és a(z) .* fájlok különböznek$"
                            syn match diffIsA	"^A(z) .* fájl egy .*, viszont a(z) .* fájl egy .*"
                            syn match diffNoEOL	"^\\ Nincs újsor a fájl végén"
                            syn match diffCommon	"^Közös alkönyvtárak: .* és .*"

                            " id
                            syn match diffOnly	"^Hanya dalam .*"
                            syn match diffIdentical	"^File .* dan .* identik$"
                            syn match diffDiffer	"^Berkas .* dan .* berbeda$"
                            syn match diffBDiffer	"^File biner .* dan .* berbeda$"
                            syn match diffIsA	"^File .* adalah .* sementara file .* adalah .*"
                            syn match diffNoEOL	"^\\ Tidak ada baris-baru di akhir dari berkas"
                            syn match diffCommon	"^Subdirektori sama: .* dan .*"

                            " it
                            syn match diffOnly	"^Solo in .*"
                            syn match diffIdentical	"^I file .* e .* sono identici$"
                            syn match diffDiffer	"^I file .* e .* sono diversi$"
                            syn match diffBDiffer	"^I file .* e .* sono diversi$"
                            syn match diffBDiffer	"^I file binari .* e .* sono diversi$"
                            syn match diffIsA	"^File .* è un .* mentre file .* è un .*"
                            syn match diffNoEOL	"^\\ Manca newline alla fine del file"
                            syn match diffCommon	"^Sottodirectory in comune: .* e .*"

                            " ja
                            syn match diffOnly	"^.*だけに発見: .*"
                            syn match diffIdentical	"^ファイル.*と.*は同一$"
                            syn match diffDiffer	"^ファイル.*と.*は違います$"
                            syn match diffBDiffer	"^バイナリー・ファイル.*と.*は違います$"
                            syn match diffIsA	"^ファイル.*は.*、ファイル.*は.*"
                            syn match diffNoEOL	"^\\ ファイル末尾に改行がありません"
                            syn match diffCommon	"^共通の下位ディレクトリー: .*と.*"

                            " ja DiffUtils 3.3
                            syn match diffOnly	"^.* のみに存在: .*"
                            syn match diffIdentical	"^ファイル .* と .* は同一です$"
                            syn match diffDiffer	"^ファイル .* と .* は異なります$"
                            syn match diffBDiffer	"^バイナリーファイル .* と.* は異なります$"
                            syn match diffIsA	"^ファイル .* は .* です。一方、ファイル .* は .* です$"
                            syn match diffNoEOL	"^\\ ファイル末尾に改行がありません"
                            syn match diffCommon	"^共通のサブディレクトリー: .* と .*"

                            " lv
                            syn match diffOnly	"^Tikai iekš .*"
                            syn match diffIdentical	"^Fails .* un .* ir identiski$"
                            syn match diffDiffer	"^Faili .* un .* atšķiras$"
                            syn match diffBDiffer	"^Faili .* un .* atšķiras$"
                            syn match diffBDiffer	"^Binārie faili .* un .* atšķiras$"
                            syn match diffIsA	"^Fails .* ir .* kamēr fails .* ir .*"
                            syn match diffNoEOL	"^\\ Nav jaunu rindu faila beigās"
                            syn match diffCommon	"^Kopējās apakšdirektorijas: .* un .*"

                            " ms
                            syn match diffOnly	"^Hanya dalam .*"
                            syn match diffIdentical	"^Fail .* dan .* adalah serupa$"
                            syn match diffDiffer	"^Fail .* dan .* berbeza$"
                            syn match diffBDiffer	"^Fail .* dan .* berbeza$"
                            syn match diffIsA	"^Fail .* adalah .* manakala fail .* adalah .*"
                            syn match diffNoEOL	"^\\ Tiada baris baru pada penghujung fail"
                            syn match diffCommon	"^Subdirektori umum: .* dan .*"

                            " nl
                            syn match diffOnly	"^Alleen in .*"
                            syn match diffIdentical	"^Bestanden .* en .* zijn identiek$"
                            syn match diffDiffer	"^Bestanden .* en .* zijn verschillend$"
                            syn match diffBDiffer	"^Bestanden .* en .* zijn verschillend$"
                            syn match diffBDiffer	"^Binaire bestanden .* en .* zijn verschillend$"
                            syn match diffIsA	"^Bestand .* is een .* terwijl bestand .* een .* is$"
                            syn match diffNoEOL	"^\\ Geen regeleindeteken (LF) aan einde van bestand"
                            syn match diffCommon	"^Gemeenschappelijke submappen: .* en .*"

                            " pl
                            syn match diffOnly	"^Tylko w .*"
                            syn match diffIdentical	"^Pliki .* i .* są identyczne$"
                            syn match diffDiffer	"^Pliki .* i .* różnią się$"
                            syn match diffBDiffer	"^Pliki .* i .* różnią się$"
                            syn match diffBDiffer	"^Binarne pliki .* i .* różnią się$"
                            syn match diffIsA	"^Plik .* jest .*, podczas gdy plik .* jest .*"
                            syn match diffNoEOL	"^\\ Brak znaku nowej linii na końcu pliku"
                            syn match diffCommon	"^Wspólne podkatalogi: .* i .*"

                            " pt_BR
                            syn match diffOnly	"^Somente em .*"
                            syn match diffOnly	"^Apenas em .*"
                            syn match diffIdentical	"^Os aquivos .* e .* são idênticos$"
                            syn match diffDiffer	"^Os arquivos .* e .* são diferentes$"
                            syn match diffBDiffer	"^Os arquivos binários .* e .* são diferentes$"
                            syn match diffIsA	"^O arquivo .* é .* enquanto o arquivo .* é .*"
                            syn match diffNoEOL	"^\\ Falta o caracter nova linha no final do arquivo"
                            syn match diffCommon	"^Subdiretórios idênticos: .* e .*"

                            " ro
                            syn match diffOnly	"^Doar în .*"
                            syn match diffIdentical	"^Fişierele .* şi .* sunt identice$"
                            syn match diffDiffer	"^Fişierele .* şi .* diferă$"
                            syn match diffBDiffer	"^Fişierele binare .* şi .* diferă$"
                            syn match diffIsA	"^Fişierul .* este un .* pe când fişierul .* este un .*.$"
                            syn match diffNoEOL	"^\\ Nici un element de linie nouă la sfârşitul fişierului"
                            syn match diffCommon	"^Subdirectoare comune: .* şi .*.$"

                            " ru
                            syn match diffOnly	"^Только в .*"
                            syn match diffIdentical	"^Файлы .* и .* идентичны$"
                            syn match diffDiffer	"^Файлы .* и .* различаются$"
                            syn match diffBDiffer	"^Файлы .* и .* различаются$"
                            syn match diffIsA	"^Файл .* это .*, тогда как файл .* -- .*"
                            syn match diffNoEOL	"^\\ В конце файла нет новой строки"
                            syn match diffCommon	"^Общие подкаталоги: .* и .*"

                            " sr
                            syn match diffOnly	"^Само у .*"
                            syn match diffIdentical	"^Датотеке „.*“ и „.*“ се подударају$"
                            syn match diffDiffer	"^Датотеке .* и .* различите$"
                            syn match diffBDiffer	"^Бинарне датотеке .* и .* различите$"
                            syn match diffIsA	"^Датотека „.*“ је „.*“ док је датотека „.*“ „.*“$"
                            syn match diffNoEOL	"^\\ Без новог реда на крају датотеке"
                            syn match diffCommon	"^Заједнички поддиректоријуми: .* и .*"

                            " sv
                            syn match diffOnly	"^Endast i .*"
                            syn match diffIdentical	"^Filerna .* och .* är lika$"
                            syn match diffDiffer	"^Filerna .* och .* skiljer$"
                            syn match diffBDiffer	"^Filerna .* och .* skiljer$"
                            syn match diffIsA	"^Fil .* är en .* medan fil .* är en .*"
                            syn match diffBDiffer	"^De binära filerna .* och .* skiljer$"
                            syn match diffIsA	"^Filen .* är .* medan filen .* är .*"
                            syn match diffNoEOL	"^\\ Ingen nyrad vid filslut"
                            syn match diffCommon	"^Lika underkataloger: .* och .*"

                            " tr
                            syn match diffOnly	"^Yalnızca .*'da: .*"
                            syn match diffIdentical	"^.* ve .* dosyaları birbirinin aynı$"
                            syn match diffDiffer	"^.* ve .* dosyaları birbirinden farklı$"
                            syn match diffBDiffer	"^.* ve .* dosyaları birbirinden farklı$"
                            syn match diffBDiffer	"^İkili .* ve .* birbirinden farklı$"
                            syn match diffIsA	"^.* dosyası, bir .*, halbuki .* dosyası bir .*"
                            syn match diffNoEOL	"^\\ Dosya sonunda yenisatır yok."
                            syn match diffCommon	"^Ortak alt dizinler: .* ve .*"

                            " uk
                            syn match diffOnly	"^Лише у .*"
                            syn match diffIdentical	"^Файли .* та .* ідентичні$"
                            syn match diffDiffer	"^Файли .* та .* відрізняються$"
                            syn match diffBDiffer	"^Файли .* та .* відрізняються$"
                            syn match diffBDiffer	"^Двійкові файли .* та .* відрізняються$"
                            syn match diffIsA	"^Файл .* це .*, тоді як файл .* -- .*"
                            syn match diffNoEOL	"^\\ Наприкінці файлу немає нового рядка"
                            syn match diffCommon	"^Спільні підкаталоги: .* та .*"

                            " vi
                            syn match diffOnly	"^Chỉ trong .*"
                            syn match diffIdentical	"^Hai tập tin .* và .* là bằng nhau.$"
                            syn match diffIdentical	"^Cả .* và .* là cùng một tập tin$"
                            syn match diffDiffer	"^Hai tập tin .* và .* là khác nhau.$"
                            syn match diffBDiffer	"^Hai tập tin nhị phân .* và .* khác nhau$"
                            syn match diffIsA	"^Tập tin .* là một .* trong khi tập tin .* là một .*.$"
                            syn match diffBDiffer	"^Hai tập tin .* và .* là khác nhau.$"
                            syn match diffIsA	"^Tập tin .* là một .* còn tập tin .* là một .*.$"
                            syn match diffNoEOL	"^\\ Không có ký tự dòng mới tại kêt thức tập tin."
                            syn match diffCommon	"^Thư mục con chung: .* và .*"

                            " zh_CN
                            syn match diffOnly	"^只在 .* 存在：.*"
                            syn match diffIdentical	"^檔案 .* 和 .* 相同$"
                            syn match diffDiffer	"^文件 .* 和 .* 不同$"
                            syn match diffBDiffer	"^文件 .* 和 .* 不同$"
                            syn match diffIsA	"^文件 .* 是.*而文件 .* 是.*"
                            syn match diffNoEOL	"^\\ 文件尾没有 newline 字符"
                            syn match diffCommon	"^.* 和 .* 有共同的子目录$"

                            " zh_TW
                            syn match diffOnly	"^只在 .* 存在：.*"
                            syn match diffIdentical	"^檔案 .* 和 .* 相同$"
                            syn match diffDiffer	"^檔案 .* 與 .* 不同$"
                            syn match diffBDiffer	"^二元碼檔 .* 與 .* 不同$"
                            syn match diffIsA	"^檔案 .* 是.*而檔案 .* 是.*"
                            syn match diffNoEOL	"^\\ 檔案末沒有 newline 字元"
                            syn match diffCommon	"^.* 和 .* 有共同的副目錄$"

                            endif


                            syn match diffRemoved	"^-.*"
                            syn match diffRemoved	"^<.*"
                            syn match diffAdded	"^+.*"
                            syn match diffAdded	"^>.*"
                            syn match diffChanged	"^! .*"

                            syn match diffSubname	" @@..*"ms=s+3 contained
                            syn match diffLine	"^@.*" contains=diffSubname
                            syn match diffLine	"^\<\d\+\>.*"
                            syn match diffLine	"^\*\*\*\*.*"
                            syn match diffLine	"^---$"

                            " Some versions of diff have lines like "#c#" and "#d#" (where # is a number)
                            syn match diffLine	"^\d\+\(,\d\+\)\=[cda]\d\+\>.*"

                            syn match diffFile	"^diff\>.*"
                            syn match diffFile	"^+++ .*"
                            syn match diffFile	"^Index: .*"
                            syn match diffFile	"^==== .*"
                            syn match diffOldFile	"^\*\*\* .*"
                            syn match diffNewFile	"^--- .*"

                            " Used by git
                            syn match diffIndexLine	"^index \x\x\x\x.*"

                            syn match diffComment	"^#.*"

                            " Define the default highlighting.
                            " Only used when an item doesn't have highlighting yet
                            hi def link diffOldFile		diffFile
                            hi def link diffNewFile		diffFile
                            hi def link diffIndexLine	PreProc
                            hi def link diffFile		Type
                            hi def link diffOnly		Constant
                            hi def link diffIdentical	Constant
                            hi def link diffDiffer		Constant
                            hi def link diffBDiffer		Constant
                            hi def link diffIsA		Constant
                            hi def link diffNoEOL		Constant
                            hi def link diffCommon		Constant
                            hi def link diffRemoved		Special
                            hi def link diffChanged		PreProc
                            hi def link diffAdded		Identifier
                            hi def link diffLine		Statement
                            hi def link diffSubname		PreProc
                            hi def link diffComment		Comment

                            let b:current_syntax = "diff"

                            " vim: ts=8 sw=2

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim
Sourced 1 time
Total time:   0.085006
 Self time:   0.003444

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/EasyMotion/command_line.vim
                            " AUTHOR: haya14busa
                            " Reference: https://github.com/osyo-manga/vim-over
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
    1              0.000007 scriptencoding utf-8
                            " Saving 'cpoptions' {{{
    1              0.000017 let s:save_cpo = &cpo
    1   0.000024   0.000016 set cpo&vim
                            " }}}

                            " CommandLine:
    1   0.004099   0.000344 let s:V = vital#easymotion#new()
    1   0.026148   0.000018 let s:cmdline = s:V.import('Over.Commandline.Base')
    1   0.000095   0.000019 let s:modules = s:V.import("Over.Commandline.Modules")
    1   0.000215   0.000011 let s:search = s:cmdline.make()
    1              0.000004 let s:search.highlights.prompt = 'Question'

                            " Add Module: {{{
    1   0.002593   0.000008 call s:search.connect('Exit')
    1   0.002304   0.000010 call s:search.connect('Cancel')
    1   0.002447   0.000009 call s:search.connect('Redraw')
    1   0.002952   0.000011 call s:search.connect('DrawCommandline')
    1   0.003791   0.000016 call s:search.connect('Delete')
    1   0.003220   0.000015 call s:search.connect('CursorMove')
    1   0.002468   0.000034 call s:search.connect('Paste')
    1   0.004036   0.000010 call s:search.connect('BufferComplete')
    1   0.003424   0.000010 call s:search.connect('InsertRegister')
    1   0.002343   0.000010 call s:search.connect('ExceptionExit')
    1   0.002446   0.000098 call s:search.connect(s:modules.get('ExceptionMessage').make('EasyMotion: ', 'echom'))
    1   0.002443   0.000030 call s:search.connect(s:modules.get('History').make('/'))
    1   0.002655   0.000031 call s:search.connect(s:modules.get('NoInsert').make_special_chars())
    1   0.006953   0.000030 call s:search.connect(s:modules.get('KeyMapping').make_emacs())
    1   0.006842   0.000043 call s:search.connect(s:modules.get('Doautocmd').make('EMCommandLine'))

    1              0.000010 let s:module = {
                            \   "name" : "EasyMotion",
                            \}
    1              0.000006 function! s:module.on_char_pre(cmdline)
                                if a:cmdline.is_input("<Over>(em-scroll-f)")
                                    call s:scroll(0)
                                    call a:cmdline.setchar('')
                                elseif a:cmdline.is_input("<Over>(em-scroll-b)")
                                    call s:scroll(1)
                                    call a:cmdline.setchar('')
                                elseif a:cmdline.is_input("<Over>(em-jumpback)")
                                    keepjumps call setpos('.', s:save_orig_pos)
                                    let s:orig_pos = s:save_orig_pos
                                    let s:orig_line_start = getpos('w0')
                                    let s:orig_line_end = getpos('w$')
                                    let s:direction = s:save_direction
                                    call a:cmdline.setchar('')
                                elseif a:cmdline.is_input("<Over>(em-openallfold)")
                                    " TODO: better solution
                                    normal! zR
                                    call a:cmdline.setchar('')
                                endif
                            endfunction
    1   0.000265   0.000014 call s:search.connect(s:module)
                            "}}}

                            " CommandLine Keymap: {{{
                            " .keymapping() won't be remapped by user defined KeyMappings.
    1              0.000004 function! s:search.keymapping() "{{{
                                return {
                            \       "\<CR>"   : {
                            \           "key" : "<Over>(exit)",
                            \           "noremap" : 1,
                            \           "lock" : 1,
                            \       },
                            \   }
                            endfunction "}}}

    1   0.000095   0.000019 call s:search.cnoremap("\<C-l>", '<Over>(buffer-complete)')
    1   0.000080   0.000015 call s:search.cnoremap("\<Tab>", '<Over>(em-scroll-f)')
    1   0.000075   0.000014 call s:search.cnoremap("\<S-Tab>", '<Over>(em-scroll-b)')
    1   0.000073   0.000013 call s:search.cnoremap("\<C-o>", '<Over>(em-jumpback)')
    1   0.000325   0.000013 call s:search.cnoremap("\<C-z>", '<Over>(em-openallfold)')

                            " Fins Motion CommandLine Mapping Command: {{{
    1              0.000005 function! EasyMotion#command_line#cmap(args)
                                let lhs = s:as_keymapping(a:args[0])
                                let rhs = s:as_keymapping(a:args[1])
                                call s:search.cmap(lhs, rhs)
                            endfunction
    1              0.000012 function! EasyMotion#command_line#cnoremap(args)
                                let lhs = s:as_keymapping(a:args[0])
                                let rhs = s:as_keymapping(a:args[1])
                                call s:search.cnoremap(lhs, rhs)
                            endfunction
    1              0.000008 function! EasyMotion#command_line#cunmap(lhs)
                                let lhs = s:as_keymapping(a:lhs)
                                call s:search.cunmap(lhs)
                            endfunction
    1              0.000006 function! s:as_keymapping(key)
                                execute 'let result = "' . substitute(a:key, '\(<.\{-}>\)', '\\\1', 'g') . '"'
                                return result
                            endfunction
                            "}}}
                            "}}}

                            " Event: {{{
    1              0.000004 function! s:search.on_enter(cmdline) "{{{
                                if s:num_strokes == -1
                                    call EasyMotion#highlight#delete_highlight()
                                    call EasyMotion#helper#VarReset('&scrolloff', 0)
                                    if g:EasyMotion_do_shade
                                        call EasyMotion#highlight#add_highlight('\_.*',
                                                                            \ g:EasyMotion_hl_group_shade)
                                    endif
                                endif
                                if g:EasyMotion_cursor_highlight
                                    call EasyMotion#highlight#add_highlight('\%#',
                                                                          \ g:EasyMotion_hl_inc_cursor)
                                endif
                            endfunction "}}}
    1              0.000002 function! s:search.on_leave(cmdline) "{{{
                                if s:num_strokes == -1
                                    call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_inc_search)
                                    if g:EasyMotion_do_shade
                                        call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_group_shade)
                                    endif
                                endif
                                if g:EasyMotion_cursor_highlight
                                    call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_inc_cursor)
                                endif
                            endfunction "}}}
    1              0.000002 function! s:search.on_char(cmdline) "{{{
                                if s:num_strokes == -1
                                    let re = s:search.getline()
                                    if EasyMotion#helper#should_case_sensitive(re, 1)
                                        let case_flag = '\c'
                                    else
                                        let case_flag = '\C'
                                    endif
                                    let re .= case_flag
                                    if g:EasyMotion_inc_highlight
                                        call s:inc_highlight(re)
                                    endif
                                    if g:EasyMotion_off_screen_search
                                        call s:off_screen_search(re)
                                    endif
                                elseif s:search.line.length() >=  s:num_strokes
                                    call s:search.exit()
                                endif
                            endfunction "}}}
                            "}}}

                            " Main:
    1              0.000004 function! EasyMotion#command_line#GetInput(num_strokes, prev, direction) "{{{
                                let s:num_strokes = a:num_strokes

                                let s:prompt_base = s:getPromptMessage(a:num_strokes)
                                call s:search.set_prompt(s:prompt_base)

                                " Screen: cursor position, first and last line
                                let s:orig_pos = getpos('.')
                                let s:orig_line_start = getpos('w0')
                                let s:orig_line_end = getpos('w$')
                                let s:save_orig_pos = deepcopy(s:orig_pos)

                                " Direction:
                                let s:direction = a:direction == 1 ? 'b' : ''
                                let s:save_direction = deepcopy(s:direction)

                                let input = s:search.get()
                                if input == '' && ! s:search.exit_code()
                                    return a:prev
                                elseif s:search.exit_code() == 1 || s:search.exit_code() == -1
                                    call s:Cancell()
                                    return ''
                                else
                                    return input
                                endif
                            endfunction "}}}

                            " Helper:
    1              0.000002 function! s:Cancell() " {{{
                                call EasyMotion#highlight#delete_highlight()
                                call EasyMotion#helper#VarReset('&scrolloff')
                                keepjumps call setpos('.', s:save_orig_pos)
                                if g:EasyMotion_verbose
                                    echo 'EasyMotion: Cancelled'
                                endif
                                return ''
                            endfunction " }}}
    1              0.000003 function! s:getPromptMessage(num_strokes) "{{{
                                if a:num_strokes == 1
                                    let prompt = substitute(
                                        \ substitute(g:EasyMotion_prompt,'{n}', a:num_strokes, 'g'),
                                        \ '(s)', '', 'g')
                                elseif a:num_strokes == -1
                                    let prompt = substitute(
                                        \ substitute(g:EasyMotion_prompt, '{n}\s\{0,1}', '', 'g'),
                                        \ '(s)', 's', 'g')
                                else
                                    let prompt = substitute(
                                        \ substitute(g:EasyMotion_prompt,'{n}', a:num_strokes, 'g'),
                                        \ '(s)', 's', 'g')
                                endif
                                return prompt
                            endfunction "}}}

    1              0.000002 function! s:off_screen_search(re) "{{{
                                " First: search within visible screen range
                                call s:adjust_screen()
                                " Error occur when '\zs' without '!'
                                silent! let pos = searchpos(a:re, s:direction . 'n', s:orig_line_end[1])
                                if pos != [0, 0]
                                    " Restore cursor posision
                                    keepjumps call setpos('.', s:orig_pos)
                                else
                                    " Second: if there were no much, search off screen
                                    silent! let pos = searchpos(a:re, s:direction)
                                    if pos != [0, 0]
                                        " Match
                                        keepjumps call setpos('.', pos)
                                        " Move cursor
                                        if s:save_direction != 'b'
                                            normal! zzH0
                                        else
                                            normal! zzL0
                                        endif
                                    else
                                        " No much
                                        call s:adjust_screen()
                                        keepjumps call setpos('.', s:orig_pos)
                                    endif
                                endif
                                " redraw
                            endfunction "}}}
    1              0.000003 function! s:adjust_screen() "{{{
                                if s:save_direction != 'b'
                                    " Forward
                                    keepjumps call setpos('.', s:orig_line_start)
                                    normal! zt
                                else
                                    " Backward
                                    keepjumps call setpos('.', s:orig_line_end)
                                    normal! zb
                                endif
                            endfunction "}}}
    1              0.000002 function! s:scroll(direction) "{{{
                                " direction: 0 -> forward, 1 -> backward
                                exec a:direction == 0 ? "normal! \<C-f>" : "normal! \<C-b>"
                                let s:orig_pos = getpos('.')
                                let s:orig_line_start = getpos('w0')
                                let s:orig_line_end = getpos('w$')
                                let s:direction = a:direction == 0 ? '' : 'b'
                            endfunction "}}}
    1              0.000002 function! s:inc_highlight(re) "{{{
                                call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_inc_search)
                                if s:search.line.length() > 0
                                    " Error occur when '\zs' without '!'
                                    silent! call EasyMotion#highlight#add_highlight(a:re, g:EasyMotion_hl_inc_search)
                                endif
                            endfunction "}}}

                            " Restore 'cpoptions' {{{
    1   0.000032   0.000024 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            " }}}
                            " vim: fdm=marker:et:ts=4:sw=4:sts=4

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim
Sourced 1 time
Total time:   0.003670
 Self time:   0.003576

count  total (s)   self (s)
    1              0.000026 let s:plugin_name = expand('<sfile>:t:r')
    1              0.000007 let s:vital_base_dir = expand('<sfile>:h')
    1              0.000006 let s:project_root = expand('<sfile>:h:h:h')
    1              0.000005 let s:is_vital_vim = s:plugin_name is# 'vital'

    1              0.000003 let s:loaded = {}
    1              0.000003 let s:cache_sid = {}

                            " function() wrapper
    1              0.000006 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! s:_function(fstr) abort
                                return function(a:fstr)
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              let s:_s = '<SNR>' . s:_SID() . '_'
                              function! s:_function(fstr) abort
                                return function(substitute(a:fstr, 's:', s:_s, 'g'))
                              endfunction
    1              0.000001 endif

    1              0.000006 function! vital#{s:plugin_name}#new() abort
                              return s:new(s:plugin_name)
                            endfunction

    1              0.000005 function! vital#{s:plugin_name}#import(...) abort
                              if !exists('s:V')
                                let s:V = s:new(s:plugin_name)
                              endif
                              return call(s:V.import, a:000, s:V)
                            endfunction

    1              0.000003 let s:Vital = {}

    1              0.000002 function! s:new(plugin_name) abort
                              let base = deepcopy(s:Vital)
                              let base._plugin_name = a:plugin_name
                              return base
                            endfunction

    1              0.000002 function! s:vital_files() abort
                              if !exists('s:vital_files')
                                let s:vital_files = map(
                                \   s:is_vital_vim ? s:_global_vital_files() : s:_self_vital_files(),
                                \   'fnamemodify(v:val, ":p:gs?[\\\\/]?/?")')
                              endif
                              return copy(s:vital_files)
                            endfunction
    1   0.000033   0.000022 let s:Vital.vital_files = s:_function('s:vital_files')

    1              0.000003 function! s:import(name, ...) abort dict
                              let target = {}
                              let functions = []
                              for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
                              let module = self._import(a:name)
                              if empty(functions)
                                call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
                              return target
                            endfunction
    1   0.000084   0.000064 let s:Vital.import = s:_function('s:import')

    1              0.000006 function! s:load(...) abort dict
                              for arg in a:000
                                let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
                                let target = split(join(as, ''), '\W\+')
                                let dict = self
                                let dict_type = type({})
                                while !empty(target)
                                  let ns = remove(target, 0)
                                  if !has_key(dict, ns)
                                    let dict[ns] = {}
                                  endif
                                  if type(dict[ns]) == dict_type
                                    let dict = dict[ns]
                                  else
                                    unlet dict
                                    break
                                  endif
                                endwhile
                                if exists('dict')
                                  call extend(dict, self._import(name))
                                endif
                                unlet arg
                              endfor
                              return self
                            endfunction
    1   0.000057   0.000044 let s:Vital.load = s:_function('s:load')

    1              0.000003 function! s:unload() abort dict
                              let s:loaded = {}
                              let s:cache_sid = {}
                              unlet! s:vital_files
                            endfunction
    1   0.000021   0.000015 let s:Vital.unload = s:_function('s:unload')

    1              0.000003 function! s:exists(name) abort dict
                              if a:name !~# '\v^\u\w*%(\.\u\w*)*$'
                                throw 'vital: Invalid module name: ' . a:name
                              endif
                              return s:_module_path(a:name) isnot# ''
                            endfunction
    1   0.000016   0.000010 let s:Vital.exists = s:_function('s:exists')

    1              0.000002 function! s:search(pattern) abort dict
                              let paths = s:_extract_files(a:pattern, self.vital_files())
                              let modules = sort(map(paths, 's:_file2module(v:val)'))
                              return s:_uniq(modules)
                            endfunction
    1   0.000018   0.000013 let s:Vital.search = s:_function('s:search')

    1              0.000040 function! s:plugin_name() abort dict
                              return self._plugin_name
                            endfunction
    1   0.000052   0.000038 let s:Vital.plugin_name = s:_function('s:plugin_name')

    1              0.000003 function! s:_self_vital_files() abort
                              let builtin = printf('%s/__%s__/', s:vital_base_dir, s:plugin_name)
                              let installed = printf('%s/_%s/', s:vital_base_dir, s:plugin_name)
                              let base = builtin . ',' . installed
                              return split(globpath(base, '**/*.vim', 1), "\n")
                            endfunction

    1              0.000002 function! s:_global_vital_files() abort
                              let pattern = 'autoload/vital/__*__/**/*.vim'
                              return split(globpath(&runtimepath, pattern, 1), "\n")
                            endfunction

    1              0.000003 function! s:_extract_files(pattern, files) abort
                              let tr = {'.': '/', '*': '[^/]*', '**': '.*'}
                              let target = substitute(a:pattern, '\.\|\*\*\?', '\=tr[submatch(0)]', 'g')
                              let regexp = printf('autoload/vital/[^/]\+/%s.vim$', target)
                              return filter(a:files, 'v:val =~# regexp')
                            endfunction

    1              0.001264 function! s:_file2module(file) abort
                              let filename = fnamemodify(a:file, ':p:gs?[\\/]?/?')
                              let tail = matchstr(filename, 'autoload/vital/_\w\+/\zs.*\ze\.vim$')
                              return join(split(tail, '[\\/]\+'), '.')
                            endfunction

                            " @param {string} name e.g. Data.List
    1              0.000003 function! s:_import(name) abort dict
                              if has_key(s:loaded, a:name)
                                return copy(s:loaded[a:name])
                              endif
                              let module = self._get_module(a:name)
                              if has_key(module, '_vital_created')
                                call module._vital_created(module)
                              endif
                              let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module.vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
                              let s:loaded[a:name] = export_module
                              if has_key(module, '_vital_loaded')
                                try
                                  call module._vital_loaded(vital#{s:plugin_name}#new())
                                catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception
                                endtry
                              endif
                              return copy(s:loaded[a:name])
                            endfunction
    1   0.000040   0.000028 let s:Vital._import = s:_function('s:_import')

                            " s:_get_module() returns module object wihch has all script local functions.
    1              0.000003 function! s:_get_module(name) abort dict
                              let funcname = s:_import_func_name(self.plugin_name(), a:name)
                              if s:_exists_autoload_func_with_source(funcname)
                                return call(funcname, [])
                              else
                                return s:_get_builtin_module(a:name)
                              endif
                            endfunction

    1              0.000003 function! s:_get_builtin_module(name) abort
                             return s:sid2sfuncs(s:_module_sid(a:name))
                            endfunction

    1              0.000003 if s:is_vital_vim
                              " For vital.vim, we can use s:_get_builtin_module directly
                              let s:Vital._get_module = s:_function('s:_get_builtin_module')
    1              0.000002 else
    1   0.000020   0.000013   let s:Vital._get_module = s:_function('s:_get_module')
    1              0.000001 endif

    1              0.000003 function! s:_import_func_name(plugin_name, module_name) abort
                              return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))
                            endfunction

    1              0.000002 function! s:_module_sid(name) abort
                              let path = s:_module_path(a:name)
                              if !filereadable(path)
                                throw 'vital: module not found: ' . a:name
                              endif
                              let vital_dir = s:is_vital_vim ? '__\w\+__' : printf('_\{1,2}%s\%%(__\)\?', s:plugin_name)
                              let base = join([vital_dir, ''], '[/\\]\+')
                              let p = base . substitute('' . a:name, '\.', '[/\\\\]\\+', 'g')
                              let sid = s:_sid(path, p)
                              if !sid
                                call s:_source(path)
                                let sid = s:_sid(path, p)
                                if !sid
                                  throw printf('vital: cannot get <SID> from path: %s', path)
                                endif
                              endif
                              return sid
                            endfunction

    1              0.000002 function! s:_module_path(name) abort
                              return get(s:_extract_files(a:name, s:vital_files()), 0, '')
                            endfunction

    1              0.000002 function! s:_module_sid_base_dir() abort
                              return s:is_vital_vim ? &rtp : s:project_root
                            endfunction

    1              0.000002 function! s:_dot_to_sharp(name) abort
                              return substitute(a:name, '\.', '#', 'g')
                            endfunction

                            " It will sources autoload file if a given func is not already defined.
    1              0.000003 function! s:_exists_autoload_func_with_source(funcname) abort
                              if exists('*' . a:funcname)
                                " Return true if a given func is already defined
                                return 1
                              endif
                              " source a file which may include a given func definition and try again.
                              let path = 'autoload/' . substitute(substitute(a:funcname, '#[^#]*$', '.vim', ''), '#', '/', 'g')
                              call s:_runtime(path)
                              return exists('*' . a:funcname)
                            endfunction

    1              0.000002 function! s:_runtime(path) abort
                              execute 'runtime' fnameescape(a:path)
                            endfunction

    1              0.000002 function! s:_source(path) abort
                              execute 'source' fnameescape(a:path)
                            endfunction

                            " @vimlint(EVL102, 1, l:_)
                            " @vimlint(EVL102, 1, l:__)
    1              0.000003 function! s:_sid(path, filter_pattern) abort
                              let unified_path = s:_unify_path(a:path)
                              if has_key(s:cache_sid, unified_path)
                                return s:cache_sid[unified_path]
                              endif
                              for line in filter(split(s:_redir(':scriptnames'), "\n"), 'v:val =~# a:filter_pattern')
                                let [_, sid, path; __] = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
                                if s:_unify_path(path) is# unified_path
                                  let s:cache_sid[unified_path] = sid
                                  return s:cache_sid[unified_path]
                                endif
                              endfor
                              return 0
                            endfunction

    1              0.000002 function! s:_redir(cmd) abort
                              let [save_verbose, save_verbosefile] = [&verbose, &verbosefile]
                              set verbose=0 verbosefile=
                              redir => res
                                silent! execute a:cmd
                              redir END
                              let [&verbose, &verbosefile] = [save_verbose, save_verbosefile]
                              return res
                            endfunction

    1              0.000098 if filereadable(expand('<sfile>:r') . '.VIM') " is case-insensitive or not
    1              0.000007   let s:_unify_path_cache = {}
                              " resolve() is slow, so we cache results.
                              " Note: On windows, vim can't expand path names from 8.3 formats.
                              " So if getting full path via <sfile> and $HOME was set as 8.3 format,
                              " vital load duplicated scripts. Below's :~ avoid this issue.
    1              0.000004   function! s:_unify_path(path) abort
                                if has_key(s:_unify_path_cache, a:path)
                                  return s:_unify_path_cache[a:path]
                                endif
                                let value = tolower(fnamemodify(resolve(fnamemodify(
                                \                   a:path, ':p')), ':~:gs?[\\/]?/?'))
                                let s:_unify_path_cache[a:path] = value
                                return value
                              endfunction
                            else
                              function! s:_unify_path(path) abort
                                return resolve(fnamemodify(a:path, ':p:gs?[\\/]?/?'))
                              endfunction
    1              0.000001 endif

                            " copied and modified from Vim.ScriptLocal
    1              0.000052 let s:SNR = join(map(range(len("\<SNR>")), '"[\\x" . printf("%0x", char2nr("\<SNR>"[v:val])) . "]"'), '')
    1              0.000003 function! s:sid2sfuncs(sid) abort
                              let fs = split(s:_redir(printf(':function /^%s%s_', s:SNR, a:sid)), "\n")
                              let r = {}
                              let pattern = printf('\m^function\s<SNR>%d_\zs\w\{-}\ze(', a:sid)
                              for fname in map(fs, 'matchstr(v:val, pattern)')
                                let r[fname] = function(s:_sfuncname(a:sid, fname))
                              endfor
                              return r
                            endfunction

                            "" Return funcname of script local functions with SID
    1              0.000003 function! s:_sfuncname(sid, funcname) abort
                              return printf('<SNR>%s_%s', a:sid, a:funcname)
                            endfunction

    1              0.000005 if exists('*uniq')
    1              0.000002   function! s:_uniq(list) abort
                                return uniq(a:list)
                              endfunction
                            else
                              function! s:_uniq(list) abort
                                let i = len(a:list) - 1
                                while 0 < i
                                  if a:list[i] ==# a:list[i - 1]
                                    call remove(a:list, i)
                                  endif
                                  let i -= 1
                                endwhile
                                return a:list
                              endfunction
    1              0.000004 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim
Sourced 1 time
Total time:   0.003418
 Self time:   0.003401

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000016 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Over#Commandline#Base#import() abort
                                return map({'_vital_depends': '', 'make_plain': '', 'is_input_waiting': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Base#import() abort', printf("return map({'_vital_depends': '', 'make_plain': '', 'is_input_waiting': '', 'make': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000022   0.000014 set cpo&vim


    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:String  = s:V.import("Over.String")
                            	let s:Signals = s:V.import("Over.Signals")
                            	let s:Input = s:V.import("Over.Input")
                            	let s:Keymapping = s:V.import("Over.Keymapping")
                            	let s:Module = s:V.import("Over.Commandline.Modules")
                            	let s:base.variables.modules = s:Signals.make()
                            	function! s:base.variables.modules.get_slot(val)
                            		return a:val.slot.module
                            	endfunction

                            	let s:Highlight = s:V.import("Palette.Highlight")
                            endfunction


    1              0.000002 function! s:_vital_depends()
                            	return [
                            \		"Over.String",
                            \		"Over.Signals",
                            \		"Over.Input",
                            \		"Over.Keymapping",
                            \		"Over.Commandline.Modules",
                            \		"Palette.Highlight",
                            \	]
                            endfunction


    1              0.000002 function! s:make(...)
                            	let result = deepcopy(s:base)
                            	call result.set_prompt(get(a:, 1, ":"))
                            	call result.connect(result, "_")
                            	return result
                            endfunction


    1              0.000002 function! s:make_plain()
                            	return deepcopy(s:base)
                            endfunction


    1              0.000082 let s:base = {
                            \	"line" : {},
                            \	"variables" : {
                            \		"prompt" : "",
                            \		"char" : "",
                            \		"input" : "",
                            \		"tap_key" : "",
                            \		"exit" : 0,
                            \		"keymapping" : {},
                            \		"suffix" : "",
                            \		"is_setted" : 0,
                            \	},
                            \	"highlights" : {
                            \		"prompt" : "NONE",
                            \		"cursor" : "VitalOverCommandLineCursor",
                            \		"cursor_on" : "VitalOverCommandLineCursorOn",
                            \		"cursor_insert" : "VitalOverCommandLineOnCursor",
                            \	},
                            \}

    1              0.000005 if exists("s:Signals")
                            	let s:base.variables.modules = s:Signals.make()
                            	function! s:base.variables.modules.get_slot(val)
                            		return a:val.slot.module
                            	endfunction
    1              0.000001 endif


    1              0.000002 function! s:base.getline()
                            	return self.line.str()
                            endfunction


    1              0.000002 function! s:base.setline(line)
                            	return self.line.set(a:line)
                            endfunction


    1              0.000002 function! s:base.char()
                            	return self.variables.char
                            endfunction


    1              0.000002 function! s:base.setchar(char, ...)
                            	" 1 の場合は既に設定されていても上書きする
                            	" 0 の場合は既に設定されていれば上書きしない
                            	let overwrite = get(a:, 1, 1)
                            	if overwrite || self.variables.is_setted == 0
                            		let self.variables.input = a:char
                            		let self.variables.is_setted = 1
                            	endif
                            endfunction


    1              0.000002 function! s:base.getpos()
                            	return self.line.pos()
                            endfunction


    1              0.000002 function! s:base.setpos(pos)
                            	return self.line.set_pos(a:pos)
                            endfunction


    1              0.000002 function! s:base.tap_keyinput(key)
                            	let self.variables.tap_key = a:key
                            endfunction


    1              0.000002 function! s:base.untap_keyinput(key)
                            	if self.variables.tap_key == a:key
                            		let self.variables.tap_key = ""
                            		return 1
                            	endif
                            endfunction


    1              0.000002 function! s:base.get_tap_key()
                            	return self.variables.tap_key
                            endfunction


    1              0.000002 function! s:base.is_input(key, ...)
                            	let prekey = get(a:, 1, "")
                            	return self.get_tap_key() ==# prekey
                            \		&& self.char() ==# a:key
                            " \		&& self.char() == (prekey . a:key)
                            endfunction


    1              0.000002 function! s:base.input_key()
                            	return self.variables.input_key
                            endfunction


    1              0.000002 function! s:base.set_prompt(prompt)
                            	let self.variables.prompt = a:prompt
                            endfunction


    1              0.000001 function! s:base.get_prompt()
                            	return self.variables.prompt
                            endfunction


    1              0.000002 function! s:base.set_suffix(str)
                            	let self.variables.suffix = a:str
                            endfunction


    1              0.000002 function! s:base.get_suffix()
                            	return self.variables.suffix
                            endfunction


    1              0.000002 function! s:base.insert(word, ...)
                            	if a:0
                            		call self.line.set(a:1)
                            	endif
                            	call self.line.input(a:word)
                            endfunction

    1              0.001335 function! s:base.forward()
                            	return self.line.forward()
                            endfunction

    1              0.000002 function! s:base.backward()
                            	return self.line.backward()
                            endfunction


    1              0.000002 function! s:base.backward_word(...)
                            	let pat = get(a:, 1, '\k\+\s*\|.')
                            	return matchstr(self.backward(), '\%(' . pat . '\)$')
                            endfunction


    1              0.000002 function! s:base.connect(module, ...)
                            	if type(a:module) == type("")
                            		return call(self.connect, [s:Module.make(a:module)] + a:000, self)
                            	endif
                            	if empty(a:module)
                            		return
                            	endif
                            	let name = a:0 > 0 ? a:1 : a:module.name
                            	let slot = self.variables.modules.find_first_by("get(v:val.slot, 'name', '') == " . string(name))
                            	if empty(slot)
                            		call self.variables.modules.connect({ "name" : name, "module" : a:module })
                            	else
                            		let slot.slot.module = a:module
                            	endif
                            " 	let self.variables.modules[name] = a:module
                            endfunction


    1              0.000002 function! s:base.disconnect(name)
                            	return self.variables.modules.disconnect_by(
                            \		"get(v:val.slot, 'name', '') == " . string(a:name)
                            \	)
                            " 	unlet self.variables.modules[a:name]
                            endfunction


    1              0.000002 function! s:base.get_module(name)
                            	let slot = self.variables.modules.find_first_by("get(v:val.slot, 'name', '') == " . string(a:name))
                            	return empty(slot) ? {} : slot.slot.module
                            endfunction


    1              0.000002 function! s:base.callevent(event)
                            	call self.variables.modules.sort_by("has_key(v:val.slot.module, 'priority') ? v:val.slot.module.priority('" . a:event . "') : 0")
                            	return self.variables.modules.call(a:event, [self])
                            " 	call map(filter(copy(self.variables.modules), "has_key(v:val, a:event)"), "v:val." . a:event . "(self)")
                            endfunction


    1              0.000003 function! s:base.cmap(lhs, rhs)
                            	let self.variables.keymapping[a:lhs] = a:rhs
                            endfunction


    1              0.000002 function! s:base.cnoremap(lhs, rhs)
                            	let key = s:Keymapping.as_key_config(a:rhs)
                            	let key.noremap = 1
                            	let self.variables.keymapping[a:lhs] = key
                            endfunction


    1              0.000002 function! s:base.cunmap(lhs)
                            	unlet self.variables.keymapping[a:lhs]
                            endfunction


    1              0.000002 function! s:base.keymapping()
                            	return self.__keymapping__()
                            endfunction


    1              0.000002 function! s:base.__keymapping__()
                            	return {}
                            endfunction


    1              0.000002 function! s:base.execute(...)
                            	let command = get(a:, 1, self.getline())
                            	call self.__execute(command)
                            endfunction


    1              0.000001 function! s:base.draw()
                            	call self.callevent("on_draw_pre")
                            	call self.callevent("on_draw")
                            endfunction


    1              0.000001 function! s:base.exit(...)
                            	let self.variables.exit = 1
                            	let self.variables.exit_code = get(a:, 1, 0)
                            endfunction


    1              0.000002 function! s:base.enable_keymapping()
                            	let self.variables.enable_keymapping = 1
                            endfunction


    1              0.000002 function! s:base.disable_keymapping()
                            	let self.variables.enable_keymapping = 0
                            endfunction


    1              0.000002 function! s:base.is_enable_keymapping()
                            	return self.variables.enable_keymapping
                            endfunction

                            " function! s:base.cancel()
                            " 	call self.exit(1)
                            " 	call self.__on_cancel()
                            " endfunction


    1              0.000002 function! s:base.exit_code()
                            	return self.variables.exit_code
                            endfunction


    1              0.000002 function! s:base.hl_cursor_on()
                            	if exists("self.variables.old_guicursor")
                            		set guicursor&
                            		let &guicursor = self.variables.old_guicursor
                            		unlet self.variables.old_guicursor
                            	endif

                            	if exists("self.variables.old_t_ve")
                            		let &t_ve = self.variables.old_t_ve
                            		unlet self.variables.old_t_ve
                            	endif
                            endfunction


    1              0.000002 function! s:base.hl_cursor_off()
                            	if exists("self.variables.old_t_ve")
                            		return
                            	endif

                            	let self.variables.old_guicursor = &guicursor
                            	set guicursor=n:block-NONE
                            	let self.variables.old_t_ve = &t_ve
                            	set t_ve=
                            endfunction


    1              0.000002 function! s:base.start(...)
                            	let exit_code = call(self.__main, a:000, self)
                            	return exit_code
                            endfunction


    1              0.000002 function! s:base.__empty(...)
                            endfunction


    1              0.000001 function! s:base.get(...)
                            	let Old_execute = self.execute
                            	let self.execute = self.__empty
                            	try
                            		let exit_code = call(self.start, a:000, self)
                            		if exit_code == 0
                            			return self.getline()
                            		endif
                            	finally
                            		let self.execute = Old_execute
                            	endtry
                            	return ""
                            endfunction


    1              0.000002 function! s:base.input_key_stack()
                            	return self.variables.input_key_stack
                            endfunction


    1              0.000002 function! s:base.input_key_stack_string()
                            	return join(self.variables.input_key_stack, "")
                            endfunction


    1              0.000002 function! s:base.set_input_key_stack(stack)
                            	let self.variables.input_key_stack = a:stack
                            	return self.variables.input_key_stack
                            endfunction


    1              0.000068 function! s:base.input_key_stack_pop()
                            	return remove(self.input_key_stack(), 0)
                            endfunction


    1              0.000002 function! s:base.getchar(...)
                            	if empty(self.input_key_stack())
                            		return call(s:Input.getchar, a:000, s:Input)
                            	endif
                            	return self.input_key_stack_pop()
                            endfunction


    1              0.000002 function! s:base.__init_variables()
                            	let self.variables.tap_key = ""
                            	let self.variables.char = ""
                            	let self.variables.input = ""
                            	let self.variables.exit = 0
                            	let self.variables.exit_code = 1
                            	let self.variables.enable_keymapping = 1
                            	let self.variables.input_key_stack = []
                            	let self.line = deepcopy(s:String.make())
                            endfunction


    1              0.000003 function! s:_is_valid_highlight(name)
                            	let highlight = s:Highlight.get(a:name)
                            	if empty(highlight)
                            		return 0
                            	endif

                            	if has("gui_running")
                            \	&& (has_key(highlight, "guifg") || has_key(highlight, "guibg"))
                            		return 1
                            	elseif (has_key(highlight, "ctermfg") || has_key(highlight, "ctermbg"))
                            		return 1
                            	endif
                            	return 0
                            endfunction


    1              0.000002 function! s:base.__init()
                            	call self.__init_variables()
                            	call self.hl_cursor_off()
                            	if !hlexists(self.highlights.cursor)
                            		if s:_is_valid_highlight("Cursor")
                            			execute "highlight link " . self.highlights.cursor . " Cursor"
                            		else
                            			" Workaround by CUI Vim Cursor Highlight
                            			" issues #92
                            			" https://github.com/osyo-manga/vital-over/issues/92
                            			execute "highlight " . self.highlights.cursor . " term=reverse cterm=reverse gui=reverse"
                            		endif
                            	endif
                            	if !hlexists(self.highlights.cursor_on)
                            		execute "highlight link " . self.highlights.cursor_on . " " . self.highlights.cursor
                            	endif
                            	if !hlexists(self.highlights.cursor_insert)
                            		execute "highlight " . self.highlights.cursor_insert . " cterm=underline term=underline gui=underline"
                            	endif
                            endfunction


    1              0.000002 function! s:base.__execute(command)
                            	call self.callevent("on_execute_pre")
                            	try
                            		call self.__execute__(a:command)
                            	catch
                            		echohl ErrorMsg
                            		echom matchstr(v:exception, 'Vim\((\w*)\)\?:\zs.*\ze')
                            		echohl None
                            		call self.callevent("on_execute_failed")
                            	finally
                            		call self.callevent("on_execute")
                            	endtry
                            endfunction


    1              0.000002 function! s:base.__execute__(cmd)
                            	execute a:cmd
                            endfunction


    1              0.000002 function! s:base.__input_char(char)
                            	let char = a:char
                            	let self.variables.input_key = char
                            	let self.variables.char = char
                            	call self.setchar(self.variables.char)
                            	let self.variables.is_setted = 0
                            	call self.callevent("on_char_pre")
                            	call self.insert(self.variables.input)
                            	call self.callevent("on_char")
                            endfunction


    1              0.000002 function! s:base.__input(input, ...)
                            	if a:input == ""
                            		return
                            	endif

                            	let self.variables.input_key = a:input
                            	if a:0 == 0
                            		let keymapping = self.__get_keymapping()
                            	else
                            		let keymapping = a:1
                            	endif
                            	if self.is_enable_keymapping()
                            		let key = s:Keymapping.unmapping(keymapping, a:input)
                            	else
                            		let key = a:input
                            	endif
                            	if key == ""
                            		return
                            	endif

                            	call self.set_input_key_stack(s:String.split_by_keys(key))
                            	while !(empty(self.input_key_stack()) || self.is_exit())
                            		call self.__input_char(self.input_key_stack_pop())
                            	endwhile
                            endfunction


    1              0.000003 function! s:is_input_waiting(keymapping, input)
                            	let num = len(filter(copy(a:keymapping), 'stridx(v:key, a:input) == 0'))
                            	return num > 1 || (num == 1 && !has_key(a:keymapping, a:input))
                            endfunction


    1              0.000002 function! s:base.__inputting()
                            	if !self.is_enable_keymapping()
                            		return self.__input(s:Input.getchar())
                            	endif

                            	let input = s:Input.getchar()
                            	let old_line = self.getline()
                            	let old_pos  = self.getpos()
                            	let keymapping = self.__get_keymapping()
                            	try
                            		let t = reltime()
                            		while s:is_input_waiting(keymapping, input)
                            \		&& str2nr(reltimestr(reltime(t))) * 1000 < &timeoutlen
                            			call self.setline(old_line)
                            			call self.insert(input)
                            			call self.setpos(old_pos)
                            			call self.draw()
                            			let input .= s:Input.getchar(0)
                            		endwhile
                            	finally
                            		call self.setline(old_line)
                            		call self.setpos(old_pos)
                            	endtry
                            	call self.__input(input, keymapping)
                            endfunction


    1              0.000006 function! s:base.__update()
                            " 	call self.callevent("on_update")
                            " 	if !getchar(1)
                            " 		continue
                            " 	endif
                            "
                            " 	call self.__input(s:getchar(0))
                            " 	call self.draw()

                            	call self.callevent("on_update")
                            	call self.__inputting()
                            " 	call self.__input(s:Input.getchar())
                            	if self.is_exit()
                            		return -1
                            	endif
                            	call self.draw()
                            endfunction


    1              0.000009 function! s:base.__main(...)
                            	try
                            		call self.__init()
                            		call self.callevent("on_enter")

                            		call self.__input(get(a:, 1, ""))
                            		call self.draw()
                            		while !self.is_exit()
                            			try
                            				if self.__update()
                            					break
                            				endif
                            			catch
                            				call self.callevent("on_exception")
                            			endtry
                            		endwhile
                            	catch
                            		echohl ErrorMsg | echom v:throwpoint . " " . v:exception | echohl None
                            		let self.variables.exit_code = -1
                            	finally
                            		call self.__finish()
                            		call self.callevent("on_leave")
                            	endtry
                            	return self.exit_code()
                            endfunction


    1              0.000002 function! s:base.__finish()
                            	call self.hl_cursor_on()
                            endfunction


    1              0.000002 function! s:base.__is_exit()
                            	return self.is_exit()
                            endfunction


    1              0.000002 function! s:base.is_exit()
                            	return self.variables.exit
                            endfunction


    1              0.000002 function! s:base.__get_keymapping()
                            	let result = {}
                            " 	for module in values(self.variables.modules)
                            	for module in self.variables.modules.slots()
                            		if has_key(module, "keymapping")
                            			if module isnot self
                            				call extend(result, module.keymapping(self))
                            			endif
                            		endif
                            	endfor
                            	return extend(extend(result, self.variables.keymapping), self.keymapping())
                            endfunction


    1   0.000033   0.000024 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim
Sourced 1 time
Total time:   0.001693
 Self time:   0.001652

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000019 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Over#String#import() abort
                                return map({'_vital_depends': '', 'length': '', 'index': '', 'split_by_keys': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#String#import() abort', printf("return map({'_vital_depends': '', 'length': '', 'index': '', 'split_by_keys': '', 'make': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000032   0.000020 set cpo&vim


    1              0.000005 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:List = s:V.import("Data.List")
                            endfunction


    1              0.000002 function! s:_vital_depends()
                            	return [
                            \		"Data.List",
                            \	]
                            endfunction


    1              0.000003 function! s:_clamp(x, max, min)
                            	return min([max([a:x, a:max]), a:min])
                            endfunction


    1              0.000004 let s:base = {}

    1              0.000003 function! s:base.set(item)
                            	return type(a:item) == type("") ? self.set_str(a:item)
                            \		 : type(a:item) == type(0)  ? self.set_pos(a:item)
                            \		 : self
                            endfunction

    1              0.000001 function! s:base.str()
                            	return join(self.list, "")
                            endfunction

    1              0.000002 function! s:base.set_pos(pos)
                            	let self.col = s:_clamp(a:pos, 0, self.length())
                            	return self
                            endfunction

    1              0.000002 function! s:base.backward()
                            	return self.col > 0 ? join(self.list[ : self.col-1], '') : ""
                            endfunction

    1              0.000002 function! s:base.forward()
                            	return join(self.list[self.col+1 : ], '')
                            endfunction

    1              0.000001 function! s:base.pos_char()
                            	return get(self.list, self.col, "")
                            endfunction

    1              0.000002 function! s:base.set_str(str)
                            	let self.list = split(a:str, '\zs')
                            	let self.col  = strchars(a:str)
                            	return self
                            endfunction

    1              0.000001 function! s:base.pos()
                            	return self.col
                            endfunction

    1              0.000002 function! s:base.input(str)
                            	call extend(self.list, split(a:str, '\zs'), self.col)
                            	let self.col += len(split(a:str, '\zs'))
                            	return self
                            endfunction

    1              0.000001 function! s:base.length()
                            	return len(self.list)
                            endfunction

    1              0.000001 function! s:base.next()
                            	return self.set_pos(self.col + 1)
                            endfunction

    1              0.000001 function! s:base.prev()
                            	return self.set_pos(self.col - 1)
                            endfunction

    1              0.000002 function! s:base.remove(index)
                            	if a:index < 0 || self.length() <= a:index
                            		return ""
                            	endif
                            	let result = self.list[a:index]
                            	unlet self.list[a:index]
                            	if a:index < self.col
                            		call self.set(self.col - 1)
                            	endif
                            	return result
                            endfunction

    1              0.000002 function! s:base.remove_pos()
                            	return self.remove(self.col)
                            endfunction

    1              0.000001 function! s:base.remove_prev()
                            	return self.remove(self.col - 1)
                            endfunction

    1              0.000001 function! s:base.remove_next()
                            	return self.remove(self.col + 1)
                            endfunction


    1              0.000002 function! s:make(...)
                            	let default = get(a:, 1, "")
                            	let result = deepcopy(s:base)
                            	call result.set(default)
                            	return result
                            endfunction

                            " NOTE: old regexpengine has a bug with string which contains binary
                            " :echo "\x80" =~ "\\%#=1\x80"   | " => 0
                            " But it matches correctly with :h /collection
                            " :echo "\x80" =~ "\\%#=1[\x80]" | " => 1
                            " http://lingr.com/room/vim/archives/2015/02/13#message-21261450
    1              0.000009 let s:_engine = exists("+regexpengine") ? '\%#=2' : ''
                            " \<A-]> => Û\xfdQ
                            " \<A-@> => À\xfeX
    1              0.000012 let s:_regex = exists("+regexpengine")
                            \	? "\\%(Û\xfdQ\\|À\xfeX\\|\x80\xfc.\\%(\x80..\\|.\\)\\|\x80..\\|.\\)\\zs"
                            \	: "\\%(Û[\xfd]Q\\|À[\xfe]X\\|[\x80][\xfc].\\%([\x80]..\\|.\\)\\|[\x80]..\\|.\\)\\zs"
    1              0.000003 function! s:_split_keystring(str, ...)
                            	return split(a:str, s:_engine . '\m\%(' . get(a:, 1, '') . s:_regex . '\)')
                            endfunction

    1              0.000002 function! s:split_by_keys(str)
                            	return s:_split_keystring(a:str, "\\%(\<Plug>\\|<Over>\\)(.\\{-})\\zs\\|")
                            endfunction

    1              0.000002 function! s:index(haystack, needle, ...)
                            	let start = get(a:, 1, 0)
                            	let ignorecase = get(a:, 2, &ignorecase)
                            	if ignorecase
                            		return stridx(tolower(a:haystack), tolower(a:needle), start)
                            	else
                            		return stridx(a:haystack, a:needle, start)
                            	endif
                            endfunction


    1              0.000002 function! s:length(str)
                            	return len(s:split_by_keys(a:str))
                            endfunction


    1   0.000287   0.000257 let &cpo = s:save_cpo
    1              0.000022 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Data/List.vim
Sourced 1 time
Total time:   0.003166
 Self time:   0.003150

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000016 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000009   function! vital#_easymotion#Data#List#import() abort
                                return map({'combinations': '', 'and': '', 'sort_by': '', 'foldr1': '', 'sort': '', 'flatten': '', 'has_index': '', 'find_indices': '', 'any': '', 'unshift': '', 'span': '', 'pop': '', 'binary_search': '', 'uniq_by': '', 'or': '', 'all': '', 'zip': '', 'find_last_index': '', 'find': '', 'partition': '', 'map_accum': '', 'permutations': '', 'break': '', 'max_by': '', 'foldl': '', 'foldr': '', 'find_index': '', 'group_by': '', 'take_while': '', 'conj': '', 'push': '', 'char_range': '', 'cons': '', 'foldl1': '', 'intersect': '', 'concat': '', 'shift': '', 'clear': '', 'has_common_items': '', 'product': '', 'zip_fill': '', 'uniq': '', 'has': '', 'min_by': '', 'with_index': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Data#List#import() abort', printf("return map({'combinations': '', 'and': '', 'sort_by': '', 'foldr1': '', 'sort': '', 'flatten': '', 'has_index': '', 'find_indices': '', 'any': '', 'unshift': '', 'span': '', 'pop': '', 'binary_search': '', 'uniq_by': '', 'or': '', 'all': '', 'zip': '', 'find_last_index': '', 'find': '', 'partition': '', 'map_accum': '', 'permutations': '', 'break': '', 'max_by': '', 'foldl': '', 'foldr': '', 'find_index': '', 'group_by': '', 'take_while': '', 'conj': '', 'push': '', 'char_range': '', 'cons': '', 'foldl1': '', 'intersect': '', 'concat': '', 'shift': '', 'clear': '', 'has_common_items': '', 'product': '', 'zip_fill': '', 'uniq': '', 'has': '', 'min_by': '', 'with_index': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
                            " Utilities for list.

    1              0.000014 let s:save_cpo = &cpo
    1   0.000024   0.000017 set cpo&vim

    1              0.000004 function! s:pop(list) abort
                              return remove(a:list, -1)
                            endfunction

    1              0.000003 function! s:push(list, val) abort
                              call add(a:list, a:val)
                              return a:list
                            endfunction

    1              0.000002 function! s:shift(list) abort
                              return remove(a:list, 0)
                            endfunction

    1              0.000002 function! s:unshift(list, val) abort
                              return insert(a:list, a:val)
                            endfunction

    1              0.000003 function! s:cons(x, xs) abort
                              return [a:x] + a:xs
                            endfunction

    1              0.000002 function! s:conj(xs, x) abort
                              return a:xs + [a:x]
                            endfunction

                            " Removes duplicates from a list.
    1              0.000002 function! s:uniq(list) abort
                              return s:uniq_by(a:list, 'v:val')
                            endfunction

                            " Removes duplicates from a list.
    1              0.000002 function! s:uniq_by(list, f) abort
                              let list = map(copy(a:list), printf('[v:val, %s]', a:f))
                              let i = 0
                              let seen = {}
                              while i < len(list)
                                let key = string(list[i][1])
                                if has_key(seen, key)
                                  call remove(list, i)
                                else
                                  let seen[key] = 1
                                  let i += 1
                                endif
                              endwhile
                              return map(list, 'v:val[0]')
                            endfunction

    1              0.000002 function! s:clear(list) abort
                              if !empty(a:list)
                                unlet! a:list[0 : len(a:list) - 1]
                              endif
                              return a:list
                            endfunction

                            " Concatenates a list of lists.
                            " XXX: Should we verify the input?
    1              0.000002 function! s:concat(list) abort
                              let memo = []
                              for Value in a:list
                                let memo += Value
                              endfor
                              return memo
                            endfunction

                            " Take each elements from lists to a new list.
    1              0.000002 function! s:flatten(list, ...) abort
                              let limit = a:0 > 0 ? a:1 : -1
                              let memo = []
                              if limit == 0
                                return a:list
                              endif
                              let limit -= 1
                              for Value in a:list
                                let memo +=
                                      \ type(Value) == type([]) ?
                                      \   s:flatten(Value, limit) :
                                      \   [Value]
                                unlet! Value
                              endfor
                              return memo
                            endfunction

                            " Sorts a list with expression to compare each two values.
                            " a:a and a:b can be used in {expr}.
    1              0.000002 function! s:sort(list, expr) abort
                              if type(a:expr) == type(function('function'))
                                return sort(a:list, a:expr)
                              endif
                              let s:expr = a:expr
                              return sort(a:list, 's:_compare')
                            endfunction

    1              0.000002 function! s:_compare(a, b) abort
                              return eval(s:expr)
                            endfunction

                            " Sorts a list using a set of keys generated by mapping the values in the list
                            " through the given expr.
                            " v:val is used in {expr}
    1              0.000014 function! s:sort_by(list, expr) abort
                              let pairs = map(a:list, printf('[v:val, %s]', a:expr))
                              return map(s:sort(pairs,
                              \      'a:a[1] ==# a:b[1] ? 0 : a:a[1] ># a:b[1] ? 1 : -1'), 'v:val[0]')
                            endfunction

                            " Returns a maximum value in {list} through given {expr}.
                            " Returns 0 if {list} is empty.
                            " v:val is used in {expr}
    1              0.000003 function! s:max_by(list, expr) abort
                              if empty(a:list)
                                return 0
                              endif
                              let list = map(copy(a:list), a:expr)
                              return a:list[index(list, max(list))]
                            endfunction

                            " Returns a minimum value in {list} through given {expr}.
                            " Returns 0 if {list} is empty.
                            " v:val is used in {expr}
                            " FIXME: -0x80000000 == 0x80000000
    1              0.000003 function! s:min_by(list, expr) abort
                              return s:max_by(a:list, '-(' . a:expr . ')')
                            endfunction

                            " Returns List of character sequence between [a:from, a:to]
                            " e.g.: s:char_range('a', 'c') returns ['a', 'b', 'c']
    1              0.000003 function! s:char_range(from, to) abort
                              return map(
                              \   range(char2nr(a:from), char2nr(a:to)),
                              \   'nr2char(v:val)'
                              \)
                            endfunction

                            " Returns true if a:list has a:value.
                            " Returns false otherwise.
    1              0.000002 function! s:has(list, value) abort
                              return index(a:list, a:value) isnot -1
                            endfunction

                            " Returns true if a:list[a:index] exists.
                            " Returns false otherwise.
                            " NOTE: Returns false when a:index is negative number.
    1              0.000002 function! s:has_index(list, index) abort
                              " Return true when negative index?
                              " let index = a:index >= 0 ? a:index : len(a:list) + a:index
                              return 0 <= a:index && a:index < len(a:list)
                            endfunction

                            " similar to Haskell's Data.List.span
    1              0.000002 function! s:span(f, xs) abort
                              let border = len(a:xs)
                              for i in range(len(a:xs))
                                if !eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  let border = i
                                  break
                                endif
                              endfor
                              return border == 0 ? [[], copy(a:xs)] : [a:xs[: border - 1], a:xs[border :]]
                            endfunction

                            " similar to Haskell's Data.List.break
    1              0.000002 function! s:break(f, xs) abort
                              return s:span(printf('!(%s)', a:f), a:xs)
                            endfunction

                            " similar to Haskell's Data.List.takeWhile
    1              0.000003 function! s:take_while(f, xs) abort
                              return s:span(a:f, a:xs)[0]
                            endfunction

                            " similar to Haskell's Data.List.partition
    1              0.000002 function! s:partition(f, xs) abort
                              return [filter(copy(a:xs), a:f), filter(copy(a:xs), '!(' . a:f . ')')]
                            endfunction

                            " similar to Haskell's Prelude.all
    1              0.000002 function! s:all(f, xs) abort
                              return !s:any(printf('!(%s)', a:f), a:xs)
                            endfunction

                            " similar to Haskell's Prelude.any
    1              0.000002 function! s:any(f, xs) abort
                              return !empty(filter(map(copy(a:xs), a:f), 'v:val'))
                            endfunction

                            " similar to Haskell's Prelude.and
    1              0.000002 function! s:and(xs) abort
                              return s:all('v:val', a:xs)
                            endfunction

                            " similar to Haskell's Prelude.or
    1              0.000002 function! s:or(xs) abort
                              return s:any('v:val', a:xs)
                            endfunction

    1              0.000003 function! s:map_accum(expr, xs, init) abort
                              let memo = []
                              let init = a:init
                              for x in a:xs
                                let expr = substitute(a:expr, 'v:memo', init, 'g')
                                let expr = substitute(expr, 'v:val', x, 'g')
                                let [tmp, init] = eval(expr)
                                call add(memo, tmp)
                              endfor
                              return memo
                            endfunction

                            " similar to Haskell's Prelude.foldl
    1              0.000002 function! s:foldl(f, init, xs) abort
                              let memo = a:init
                              for x in a:xs
                                let expr = substitute(a:f, 'v:val', string(x), 'g')
                                let expr = substitute(expr, 'v:memo', string(memo), 'g')
                                unlet memo
                                let memo = eval(expr)
                              endfor
                              return memo
                            endfunction

                            " similar to Haskell's Prelude.foldl1
    1              0.000002 function! s:foldl1(f, xs) abort
                              if len(a:xs) == 0
                                throw 'vital: Data.List: foldl1'
                              endif
                              return s:foldl(a:f, a:xs[0], a:xs[1:])
                            endfunction

                            " similar to Haskell's Prelude.foldr
    1              0.000003 function! s:foldr(f, init, xs) abort
                              return s:foldl(a:f, a:init, reverse(copy(a:xs)))
                            endfunction

                            " similar to Haskell's Prelude.fold11
    1              0.000002 function! s:foldr1(f, xs) abort
                              if len(a:xs) == 0
                                throw 'vital: Data.List: foldr1'
                              endif
                              return s:foldr(a:f, a:xs[-1], a:xs[0:-2])
                            endfunction

                            " similar to python's zip()
    1              0.000002 function! s:zip(...) abort
                              return map(range(min(map(copy(a:000), 'len(v:val)'))), "map(copy(a:000), 'v:val['.v:val.']')")
                            endfunction

                            " similar to zip(), but goes until the longer one.
    1              0.000005 function! s:zip_fill(xs, ys, filler) abort
                              if empty(a:xs) && empty(a:ys)
                                return []
                              elseif empty(a:ys)
                                return s:cons([a:xs[0], a:filler], s:zip_fill(a:xs[1 :], [], a:filler))
                              elseif empty(a:xs)
                                return s:cons([a:filler, a:ys[0]], s:zip_fill([], a:ys[1 :], a:filler))
                              else
                                return s:cons([a:xs[0], a:ys[0]], s:zip_fill(a:xs[1 :], a:ys[1: ], a:filler))
                              endif
                            endfunction

                            " Inspired by Ruby's with_index method.
    1              0.000002 function! s:with_index(list, ...) abort
                              let base = a:0 > 0 ? a:1 : 0
                              return map(copy(a:list), '[v:val, v:key + base]')
                            endfunction

                            " similar to Ruby's detect or Haskell's find.
    1              0.000002 function! s:find(list, default, f) abort
                              for x in a:list
                                if eval(substitute(a:f, 'v:val', string(x), 'g'))
                                  return x
                                endif
                              endfor
                              return a:default
                            endfunction

                            " Returns the index of the first element which satisfies the given expr.
    1              0.000002 function! s:find_index(xs, f, ...) abort
                              let len = len(a:xs)
                              let start = a:0 > 0 ? (a:1 < 0 ? len + a:1 : a:1) : 0
                              let default = a:0 > 1 ? a:2 : -1
                              if start >=# len || start < 0
                                return default
                              endif
                              for i in range(start, len - 1)
                                if eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  return i
                                endif
                              endfor
                              return default
                            endfunction

                            " Returns the index of the last element which satisfies the given expr.
    1              0.000002 function! s:find_last_index(xs, f, ...) abort
                              let len = len(a:xs)
                              let start = a:0 > 0 ? (a:1 < 0 ? len + a:1 : a:1) : len - 1
                              let default = a:0 > 1 ? a:2 : -1
                              if start >=# len || start < 0
                                return default
                              endif
                              for i in range(start, 0, -1)
                                if eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  return i
                                endif
                              endfor
                              return default
                            endfunction

                            " Similar to find_index but returns the list of indices satisfying the given expr.
    1              0.000003 function! s:find_indices(xs, f, ...) abort
                              let len = len(a:xs)
                              let start = a:0 > 0 ? (a:1 < 0 ? len + a:1 : a:1) : 0
                              let result = []
                              if start >=# len || start < 0
                                return result
                              endif
                              for i in range(start, len - 1)
                                if eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  call add(result, i)
                                endif
                              endfor
                              return result
                            endfunction

                            " Return non-zero if a:list1 and a:list2 have any common item(s).
                            " Return zero otherwise.
    1              0.000003 function! s:has_common_items(list1, list2) abort
                              return !empty(filter(copy(a:list1), 'index(a:list2, v:val) isnot -1'))
                            endfunction

    1              0.000002 function! s:intersect(list1, list2) abort
                              let items = []
                              " for funcref
                              for X in a:list1
                                if index(a:list2, X) != -1 && index(items, X) == -1
                                  let items += [X]
                                endif
                              endfor
                              return items
                            endfunction

                            " similar to Ruby's group_by.
    1              0.000008 function! s:group_by(xs, f) abort
                              let result = {}
                              let list = map(copy(a:xs), printf('[v:val, %s]', a:f))
                              for x in list
                                let Val = x[0]
                                let key = type(x[1]) !=# type('') ? string(x[1]) : x[1]
                                if has_key(result, key)
                                  call add(result[key], Val)
                                else
                                  let result[key] = [Val]
                                endif
                                unlet Val
                              endfor
                              return result
                            endfunction

    1              0.000003 function! s:_default_compare(a, b) abort
                              return a:a <# a:b ? -1 : a:a ># a:b ? 1 : 0
                            endfunction

    1              0.000003 function! s:binary_search(list, value, ...) abort
                              let Predicate = a:0 >= 1 ? a:1 : 's:_default_compare'
                              let dic = a:0 >= 2 ? a:2 : {}
                              let start = 0
                              let end = len(a:list) - 1

                              while 1
                                if start > end
                                  return -1
                                endif

                                let middle = (start + end) / 2

                                let compared = call(Predicate, [a:value, a:list[middle]], dic)

                                if compared < 0
                                  let end = middle - 1
                                elseif compared > 0
                                  let start = middle + 1
                                else
                                  return middle
                                endif
                              endwhile
                            endfunction

    1              0.000002 function! s:product(lists) abort
                              let result = [[]]
                              for pool in a:lists
                                let tmp = []
                                for x in result
                                  let tmp += map(copy(pool), 'x + [v:val]')
                                endfor
                                let result = tmp
                              endfor
                              return result
                            endfunction

    1              0.000002 function! s:permutations(list, ...) abort
                              if a:0 > 1
                                throw 'vital: Data.List: too many arguments'
                              endif
                              let r = a:0 == 1 ? a:1 : len(a:list)
                              if r > len(a:list)
                                return []
                              elseif r < 0
                                throw 'vital: Data.List: {r} must be non-negative integer'
                              endif
                              let n = len(a:list)
                              let result = []
                              for indices in s:product(map(range(r), 'range(n)'))
                                if len(s:uniq(indices)) == r
                                  call add(result, map(indices, 'a:list[v:val]'))
                                endif
                              endfor
                              return result
                            endfunction

    1              0.000003 function! s:combinations(list, r) abort
                              if a:r > len(a:list)
                                return []
                              elseif a:r < 0
                                throw 'vital: Data:List: {r} must be non-negative integer'
                              endif
                              let n = len(a:list)
                              let result = []
                              for indices in s:permutations(range(n), a:r)
                                if s:sort(copy(indices), 'a:a - a:b') == indices
                                  call add(result, map(indices, 'a:list[v:val]'))
                                endif
                              endfor
                              return result
                            endfunction

    1   0.000033   0.000025 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim
Sourced 1 time
Total time:   0.001606
 Self time:   0.001589

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000024 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000009   function! vital#_easymotion#Over#Signals#import() abort
                                return map({'_vital_depends': '', 'call': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Signals#import() abort', printf("return map({'_vital_depends': '', 'call': '', 'make': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000058 scriptencoding utf-8
    1              0.000019 let s:save_cpo = &cpo
    1   0.000036   0.000024 set cpo&vim


    1              0.000008 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:L = s:V.import("Data.List")
                            endfunction


    1              0.000004 function! s:_vital_depends()
                            	return ["Data.List"]
                            endfunction


    1              0.000019 let s:base = {
                            \	"variables" : {
                            \		"slots" : [],
                            \		"counter" : 0,
                            \	}
                            \}


    1              0.000005 function! s:base.connect(slot)
                            	let self.variables.counter += 1
                            	let slot = { "id" : self.variables.counter, "slot" : a:slot }
                            	call add(self.variables.slots, slot)
                            	return slot
                            endfunction


    1              0.000003 function! s:base.disconnect(slot)
                            	if empty(a:slot)
                            		return -1
                            	endif
                            	for i in range(len(self.variables.slots))
                            		if self.variables.slots[i].id == a:slot.id
                            			unlet self.variables.slots[i]
                            			return
                            		endif
                            	endfor
                            	return -1
                            endfunction


    1              0.000003 function! s:base.disconnect_by(expr)
                            	return self.disconnect(self.find_first_by(a:expr))
                            endfunction


    1              0.000004 function! s:call(list, func, ...)
                            	let args = get(a:, 1, [])
                            	let def = get(a:, 2, 0)
                            	return map(copy(a:list), "has_key(v:val, a:func) ? call(v:val.".a:func.", args, v:val) : def")
                            endfunction

    1              0.000003 function! s:base.call(func, ...)
                            	return call("s:call", [self.slots(), a:func] + a:000)
                            endfunction


    1              0.000003 function! s:base.find_by(expr)
                            	return filter(copy(self.variables.slots), a:expr)
                            endfunction


    1              0.000003 function! s:base.find_first_by(expr)
                            	return get(self.find_by(a:expr), 0, {})
                            endfunction


    1              0.000003 function! s:base.sort_by(expr)
                            	let self.variables.slots = s:L.sort_by(self.variables.slots, a:expr)
                            endfunction


    1              0.000003 function! s:base.get_slot(val)
                            	return a:val.slot
                            endfunction


    1              0.000003 function! s:base.slots()
                            	return map(copy(self.variables.slots), "self.get_slot(v:val)")
                            endfunction


                            " function! s:base.dict()
                            " 	let result = {}
                            " 	for _ in self.variables.slots
                            " 		let result[_.id] = _.value
                            " 	endfor
                            " 	return result
                            " endfunction


    1              0.000003 function! s:make()
                            	let result = deepcopy(s:base)
                            	return result
                            endfunction


    1   0.000025   0.000020 let &cpo = s:save_cpo
    1              0.000015 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Input.vim
Sourced 1 time
Total time:   0.001206
 Self time:   0.001195

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000016 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000005   function! vital#_easymotion#Over#Input#import() abort
                                return map({'getchar': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Input#import() abort', printf("return map({'getchar': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000024   0.000015 set cpo&vim


    1              0.000003 function! s:getchar(...)
                            	let mode = get(a:, 1, 0)
                            	while 1
                            		" Workaround for https://github.com/osyo-manga/vital-over/issues/53
                            		try
                            			let char = call("getchar", a:000)
                            		catch /^Vim:Interrupt$/
                            			let char = 3 " <C-c>
                            		endtry
                            		" Workaround for the <expr> mappings
                            		if string(char) !=# "\x80\xfd`"
                            			return mode == 1 ? !!char
                            \				 : type(char) == type(0) ? nr2char(char) : char
                            		endif
                            	endwhile
                            endfunction


    1   0.000013   0.000011 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Keymapping.vim
Sourced 1 time
Total time:   0.001280
 Self time:   0.001269

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000017 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Over#Keymapping#import() abort
                                return map({'_vital_depends': '', 'unmapping': '', 'as_key_config': '', 'match_key': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Keymapping#import() abort', printf("return map({'_vital_depends': '', 'unmapping': '', 'as_key_config': '', 'match_key': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000022   0.000014 set cpo&vim



    1              0.000005 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:String  = s:V.import("Over.String")
                            endfunction


    1              0.000002 function! s:_vital_depends()
                            	return [
                            \		"Over.String",
                            \	]
                            endfunction


    1              0.000003 function! s:as_key_config(config)
                            	let base = {
                            \		"noremap" : 0,
                            \		"lock"    : 0,
                            \		"expr"    : 0,
                            \	}
                            	return type(a:config) == type({}) ? extend(base, a:config)
                            \		 : extend(base, {
                            \		 	"key" : a:config,
                            \		 })
                            endfunction


    1              0.000002 function! s:match_key(keymapping, key)
                            	let keys = sort(keys(a:keymapping))
                            	return get(filter(keys, 'stridx(a:key, v:val) == 0'), -1, '')
                            endfunction


    1              0.000002 function! s:_safe_eval(expr, ...)
                            	call extend(l:, get(a:, 1, {}))
                            	let result = get(a:, 2, "")
                            	try
                            		let result = eval(a:expr)
                            	catch
                            		echohl ErrorMsg | echom v:exception | echohl None
                            	endtry
                            	return result
                            endfunction


    1              0.000002 function! s:_get_key(conf)
                            " 	call extend(l:, a:conf)
                            	let self = a:conf
                            	return get(a:conf, "expr", 0) ? s:_safe_eval(a:conf.key, l:) : a:conf.key
                            endfunction


    1              0.000002 function! s:unmapping(keymapping, key, ...)
                            	let is_locking = get(a:, 1, 0)
                            	let key = s:match_key(a:keymapping, a:key)
                            	if key == ""
                            		return s:String.length(a:key) <= 1 ? a:key : s:unmapping(a:keymapping, a:key[0], is_locking) . s:unmapping(a:keymapping, a:key[1:], is_locking)
                            	endif

                            	let map_conf = s:as_key_config(a:keymapping[key])

                            	let next_input = s:unmapping(a:keymapping, a:key[len(key) : ], is_locking)
                            	if map_conf.lock == 0 && is_locking
                            		return key . next_input
                            	elseif map_conf.lock
                            		return s:unmapping(a:keymapping, s:_get_key(map_conf), is_locking) . next_input
                            	else
                            		return s:unmapping(a:keymapping, s:_get_key(map_conf), map_conf.noremap) . next_input
                            	endif
                            endfunction



    1   0.000014   0.000012 let &cpo = s:save_cpo
    1              0.000009 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules.vim
Sourced 1 time
Total time:   0.001299
 Self time:   0.001287

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000018 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Modules#import() abort
                                return map({'get': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#import() abort', printf("return map({'get': '', 'make': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000014 let s:save_cpo = &cpo
    1   0.000027   0.000016 set cpo&vim


    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            endfunction


    1              0.000002 function! s:get(name)
                            	if exists("s:" . a:name)
                            		return s:{a:name}
                            	endif
                            	let s:{a:name} = s:V.import('Over.Commandline.Modules.' . a:name)
                            	return s:{a:name}
                            endfunction


    1              0.000002 function! s:make(name, ...)
                            	let module = s:get(a:name)
                            	return call(module.make, a:000, module)
                            endfunction


    1   0.000013   0.000011 let &cpo = s:save_cpo
    1              0.000011 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim
Sourced 1 time
Total time:   0.001576
 Self time:   0.001564

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000017 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Palette#Highlight#import() abort
                                return map({'capture': '', '_vital_depends': '', 'parse': '', 'group_list': '', 'set': '', 'parse_to_name': '', 'links_to': '', 'get': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Palette#Highlight#import() abort', printf("return map({'capture': '', '_vital_depends': '', 'parse': '', 'group_list': '', 'set': '', 'parse_to_name': '', 'links_to': '', 'get': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000025   0.000015 set cpo&vim


    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:Message  = s:V.import("Vim.Message")
                            endfunction


    1              0.000002 function! s:_vital_depends()
                            	return [
                            \		"Vim.Message",
                            \	]
                            endfunction


    1              0.000002 function! s:_execute(cmd)
                            	execute a:cmd
                            endfunction


    1              0.000002 function! s:capture(name)
                            	if hlexists(a:name) == 0
                            		return ""
                            	endif
                            	return s:Message.capture("highlight " . a:name)
                            endfunction


    1              0.000002 function! s:links_to(highlight)
                            	return matchstr(a:highlight, '^\S\+\s\+xxx links to \zs.*\ze$')
                            endfunction


    1              0.000002 function! s:parse_to_name(highlight)
                            	return matchstr(a:highlight, '^\zs\w\+\ze')
                            endfunction


    1              0.000002 function! s:parse(highlight)
                            	let highlight = a:highlight

                            	if highlight !~# '^\w\+\s\+xxx\s'
                            		return {}
                            	endif

                            	let name = s:parse_to_name(a:highlight)
                            	let result = { "_name" : name }

                            	if highlight =~# '^\w\+\s\+xxx cleared'
                            		let result.cleared = 1
                            		return result
                            	endif

                            	let link = s:links_to(highlight)
                            	if link != ""
                            		let result.link = link
                            		return result
                            	endif

                            	let attrs = [
                            \		"term",
                            \		"cterm",
                            \		"ctermfg",
                            \		"ctermbg",
                            \		"gui",
                            \		"font",
                            \		"guifg",
                            \		"guibg",
                            \		"guisp",
                            \	]
                            	for attr in attrs
                            		let item = matchstr(highlight, '\s' . attr . '=\zs#\?\w\+\ze')
                            		if item != ""
                            			let result[attr] = item
                            		endif
                            	endfor
                            	return result
                            endfunction


    1              0.000002 function! s:get(name, ...)
                            	if !hlexists(a:name)
                            		return {}
                            	endif
                            	let result = s:parse(substitute(s:capture(a:name), "\n", "", "g"))
                            	if has_key(result, "link") && get(a:, 1, 0)
                            		return s:get(result.link, get(a:, 1, 0))
                            	else
                            		return result
                            	endif
                            endfunction


    1              0.000002 function! s:set(name, config)
                            	if type(a:config) == type("")
                            		return s:set(a:config, s:get(a:config))
                            	endif
                            	if has_key(a:config, "cleared")
                            		return s:_execute("highlight clear " . a:name)
                            	endif
                            	if has_key(a:config, "link")
                            		return s:_execute("highlight link " . a:name . " " . a:config.link)
                            	endif
                            	return s:_execute("highlight " . a:name . " " . join(map(items(filter(a:config, "v:key !=# '_name'")), "v:val[0] . '=' . v:val[1]"), " "))
                            endfunction


    1              0.000002 function! s:group_list()
                            	let highlights = split(s:Message.capture("highlight"), "\n")
                            	return filter(map(highlights, "s:parse_to_name(v:val)"), "v:val != ''")
                            endfunction


    1   0.000015   0.000012 let &cpo = s:save_cpo
    1              0.000011 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Message.vim
Sourced 1 time
Total time:   0.001299
 Self time:   0.001288

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000017 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Vim#Message#import() abort
                                return map({'capture': '', 'echomsg': '', 'echo': '', 'warn': '', 'get_hit_enter_max_length': '', 'error': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Vim#Message#import() abort', printf("return map({'capture': '', 'echomsg': '', 'echo': '', 'warn': '', 'get_hit_enter_max_length': '', 'error': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000013 let s:save_cpo = &cpo
    1   0.000025   0.000016 set cpo&vim



    1              0.000004 function! s:echo(hl, msg) abort
                              execute 'echohl' a:hl
                              try
                                echo a:msg
                              finally
                                echohl None
                              endtry
                            endfunction

    1              0.000003 function! s:echomsg(hl, msg) abort
                              execute 'echohl' a:hl
                              try
                                for m in split(a:msg, "\n")
                                  echomsg m
                                endfor
                              finally
                                echohl None
                              endtry
                            endfunction

    1              0.000002 function! s:error(msg) abort
                              call s:echomsg('ErrorMsg', a:msg)
                            endfunction

    1              0.000002 function! s:warn(msg) abort
                              call s:echomsg('WarningMsg', a:msg)
                            endfunction

    1              0.000002 function! s:capture(command) abort
                              try
                                redir => out
                                silent execute a:command
                              finally
                                redir END
                              endtry
                              return out
                            endfunction

                            " * Get max length of |hit-enter|.
                            "   If a string length of a message is greater than the max length,
                            "   Vim waits for user input according to |hit-enter|.
                            " XXX: Those fixed values may be different between different OSes?
                            "      Currently tested on only Windows.
    1              0.000003 function! s:get_hit_enter_max_length() abort
                              let maxlen = &columns * &cmdheight - 1
                              if &ruler
                                " TODO
                              endif
                              if &showcmd
                                let maxlen -= 11
                              endif
                              return maxlen
                            endfunction



    1   0.000014   0.000011 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Exit.vim
Sourced 1 time
Total time:   0.001328
 Self time:   0.001317

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000016 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Modules#Exit#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#Exit#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000023   0.000015 set cpo&vim

    1              0.000009 let s:module = {
                            \	"name" : "Exit",
                            \	"exit_code" : 0
                            \}


    1              0.000004 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("<Over>(exit)")
                            		call a:cmdline.setchar("")
                            		call a:cmdline.exit(self.exit_code)
                            	endif
                            endfunction


    1              0.000002 function! s:make()
                            	return deepcopy(s:module)
                            endfunction


    1   0.000014   0.000011 let &cpo = s:save_cpo
    1              0.000011 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Cancel.vim
Sourced 1 time
Total time:   0.001235
 Self time:   0.001225

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000016 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Modules#Cancel#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#Cancel#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000023   0.000015 set cpo&vim

    1              0.000007 let s:module = {
                            \	"name" : "Cancel"
                            \}

    1              0.000004 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<Esc>")
                            \	|| a:cmdline.is_input("\<C-c>")
                            " 		call a:cmdline.cancel()
                            		call a:cmdline.exit(1)
                            		call a:cmdline.setchar("")
                            	endif
                            endfunction


    1              0.000002 function! s:make()
                            	return deepcopy(s:module)
                            endfunction


    1   0.000014   0.000011 let &cpo = s:save_cpo
    1              0.000011 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Redraw.vim
Sourced 1 time
Total time:   0.001362
 Self time:   0.001351

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000016 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Modules#Redraw#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#Redraw#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000023   0.000015 set cpo&vim


    1              0.000008 let s:module = {
                            \	"name" : "Redraw",
                            \}

    1              0.000004 function! s:module.on_execute_pre(cmdline)
                            	call self.redraw(a:cmdline)
                            endfunction

    1              0.000002 function! s:module.on_enter(...)
                            	let self.is_execute = 0
                            endfunction

    1              0.000002 function! s:module.on_execute(...)
                            	let self.is_execute = 1
                            endfunction

    1              0.000002 function! s:module.on_execute_failed(...)
                            	let self.is_execute = 0
                            endfunction

    1              0.000002 function! s:module.on_leave(cmdline)
                            	if self.is_execute == 0 && a:cmdline.exit_code() != -1
                            		call self.redraw(a:cmdline)
                            	endif
                            endfunction


                            " function! s:module.on_draw_pre(cmdline)
                            " 	call self.redraw(a:cmdline)
                            " endfunction


    1              0.000002 function! s:module.redraw(cmdline)
                            	redraw
                            	" Workaround for the :set cedit=<C-c>
                            	" https://github.com/osyo-manga/vital-over/issues/52
                            	" https://github.com/Lokaltog/vim-easymotion/issues/177#issuecomment-53663431
                            	if &cedit != "<C-c>"
                            \	||(v:version > 704 || v:version == 704 && has("patch441"))
                            		normal! :
                            	else
                            		execute "normal! :\<Esc>"
                            	endif
                            endfunction

    1              0.000002 function! s:make()
                            	return deepcopy(s:module)
                            endfunction


    1   0.000014   0.000012 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim
Sourced 1 time
Total time:   0.001581
 Self time:   0.001564

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000024 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000011   function! vital#_easymotion#Over#Commandline#Modules#DrawCommandline#import() abort
                                return map({'suffix': '', 'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#DrawCommandline#import() abort', printf("return map({'suffix': '', 'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000006 scriptencoding utf-8
    1              0.000018 let s:save_cpo = &cpo
    1   0.000036   0.000024 set cpo&vim

    1              0.000014 let s:module = {
                            \	"name" : "DrawCommandline"
                            \}

    1              0.000005 let s:cmdheight = {}

    1              0.000005 function! s:cmdheight.save()
                            	if has_key(self, "value")
                            		return
                            	endif
                            	let self.value = &cmdheight
                            endfunction

    1              0.000003 function! s:cmdheight.restore()
                            	if has_key(self, "value")
                            		let &cmdheight = self.value
                            		unlet self.value
                            	endif
                            endfunction


    1              0.000003 function! s:cmdheight.get()
                            	return self.value
                            endfunction


    1              0.000005 function! s:suffix(left, suffix)
                            	let left_len = strdisplaywidth(a:left)
                            	let len = &columns - left_len % &columns
                            	let len = len + (&columns * (strdisplaywidth(a:suffix) > (len - 1))) - 1
                            	return repeat(" ", len - strdisplaywidth(a:suffix)) . a:suffix
                            " 	return printf("%" . len . "S", a:suffix)
                            endfunction


    1              0.000005 let s:old_width = 0
    1              0.000004 function! s:_redraw(cmdline)
                            	let left = a:cmdline.get_prompt() . a:cmdline.getline() . (empty(a:cmdline.line.pos_char()) ? " " : "")
                            	let width = len(left) + 1

                            	if a:cmdline.get_suffix() != ""
                            		let width += len(s:suffix(left, a:cmdline.get_suffix())) - 1
                            	endif

                            	if &columns >= width && &columns <= s:old_width && s:old_width >= width
                            		redraw
                            		normal! :
                            	elseif &columns <= width
                            		normal! :
                            	else
                            		redraw
                            	endif
                            	let s:old_width = width

                            	call s:cmdheight.save()
                            	let height = max([(width - 1) / (&columns) + 1, s:cmdheight.get()])
                            	if height > &cmdheight || &cmdheight > height
                            		let &cmdheight = height
                            		redraw
                            	endif
                            endfunction


    1              0.000004 function! s:_as_echon(str)
                            	return "echon " . strtrans(string(a:str))
                            endfunction


    1              0.000004 function! s:module.on_draw_pre(cmdline)
                            	if empty(a:cmdline.line.pos_char())
                            		let cursor = "echohl " . a:cmdline.highlights.cursor . " | echon ' '"
                            	else
                            		let cursor = "echohl " . a:cmdline.highlights.cursor_on . " | " . s:_as_echon(a:cmdline.line.pos_char())
                            	endif
                            	let suffix = ""
                            	if	a:cmdline.get_suffix() != ""
                            		let suffix = s:_as_echon(s:suffix(a:cmdline.get_prompt() . a:cmdline.getline() . repeat(" ", empty(a:cmdline.line.pos_char())), a:cmdline.get_suffix()))
                            	endif
                            	let self.draw_command  = join([
                            \		"echohl " . a:cmdline.highlights.prompt,
                            \		s:_as_echon(a:cmdline.get_prompt()),
                            \		"echohl NONE",
                            \		s:_as_echon(a:cmdline.backward()),
                            \		cursor,
                            \		"echohl NONE",
                            \		s:_as_echon(a:cmdline.forward()),
                            \		suffix,
                            \	], " | ")

                            	call s:_redraw(a:cmdline)
                            endfunction


    1              0.000005 function! s:_echon(expr)
                            	echon strtrans(a:expr)
                            endfunction


    1              0.000003 function! s:module.on_draw(cmdline)
                            	execute self.draw_command
                            " 	execute "echohl" a:cmdline.highlights.prompt
                            " 	call s:echon(a:cmdline.get_prompt())
                            " 	echohl NONE
                            " 	call s:echon(a:cmdline.backward())
                            " 	if empty(a:cmdline.line.pos_char())
                            " 		execute "echohl" a:cmdline.highlights.cursor
                            " 		call s:echon(' ')
                            " 	else
                            " 		execute "echohl" a:cmdline.highlights.cursor_on
                            " 		call s:echon(a:cmdline.line.pos_char())
                            " 	endif
                            " 	echohl NONE
                            " 	call s:echon(a:cmdline.forward())
                            " 	if	a:cmdline.get_suffix() != ""
                            " 		call s:echon(s:suffix(a:cmdline.get_prompt() . a:cmdline.getline() . repeat(" ", empty(a:cmdline.line.pos_char())), a:cmdline.get_suffix()))
                            " 	endif
                            endfunction


    1              0.000003 function! s:module.on_execute_pre(...)
                            	call s:cmdheight.restore()
                            endfunction


    1              0.000003 function! s:module.on_leave(...)
                            	call s:cmdheight.restore()
                            endfunction


    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction


    1   0.000024   0.000019 let &cpo = s:save_cpo
    1              0.000016 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Delete.vim
Sourced 1 time
Total time:   0.001964
 Self time:   0.001947

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000026 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000011   function! vital#_easymotion#Over#Commandline#Modules#Delete#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#Delete#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000006 scriptencoding utf-8
    1              0.000019 let s:save_cpo = &cpo
    1   0.000038   0.000024 set cpo&vim


    1              0.000013 let s:module = {
                            \	"name" : "Delete",
                            \}
    1              0.000007 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<C-h>")
                            \	|| a:cmdline.is_input("\<BS>")
                            		if a:cmdline.line.length() == 0
                            			return a:cmdline.exit(1)
                            		else
                            			call a:cmdline.line.remove_prev()
                            			call a:cmdline.setchar('')
                            		endif
                            	elseif a:cmdline.is_input("\<Del>")
                            		call a:cmdline.line.remove_pos()
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-w>")
                            		let word = a:cmdline.backward_word()
                            		let backward = a:cmdline.backward()[ : -strlen(word)-1 ]
                            		call a:cmdline.setline(backward . a:cmdline.line.pos_char() . a:cmdline.forward())
                            		call a:cmdline.setline(strchars(backward))
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-u>")
                            		call a:cmdline.setline(a:cmdline.line.pos_char() . a:cmdline.forward())
                            		call a:cmdline.setline(0)
                            		call a:cmdline.setchar('')
                            	endif
                            endfunction


    1              0.000004 function! s:make()
                            	return deepcopy(s:module)
                            endfunction


    1   0.000023   0.000019 let &cpo = s:save_cpo
    1              0.000015 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/CursorMove.vim
Sourced 1 time
Total time:   0.001463
 Self time:   0.001445

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000026 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000012   function! vital#_easymotion#Over#Commandline#Modules#CursorMove#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#CursorMove#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000006 scriptencoding utf-8
    1              0.000019 let s:save_cpo = &cpo
    1   0.000038   0.000025 set cpo&vim


    1              0.000029 let s:module = {
                            \	"name" : "CursorMove"
                            \}
    1              0.000006 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<Right>")
                            		call a:cmdline.line.next()
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<Left>")
                            		call a:cmdline.line.prev()
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-b>")
                            \		|| a:cmdline.is_input("\<Home>")
                            		call a:cmdline.setline(0)
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-e>")
                            \		|| a:cmdline.is_input("\<End>")
                            		call a:cmdline.setline(a:cmdline.line.length())
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-Left>")
                            \		|| a:cmdline.is_input("\<S-Left>")
                            		call a:cmdline.setline(strridx(a:cmdline.backward()[:-2], ' ') + 1)
                            		call a:cmdline.setchar('')
                            	elseif a:cmdline.is_input("\<C-Right>")
                            \		|| a:cmdline.is_input("\<S-Right>")
                            		let p = stridx(a:cmdline.forward()[1:], ' ')
                            		call a:cmdline.setline(p != -1 ? a:cmdline.line.pos() + p + 2 : a:cmdline.line.length())
                            		call a:cmdline.setchar('')
                            	endif
                            endfunction


    1              0.000004 function! s:make()
                            	return deepcopy(s:module)
                            endfunction


    1   0.000024   0.000019 let &cpo = s:save_cpo
    1              0.000015 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Paste.vim
Sourced 1 time
Total time:   0.001236
 Self time:   0.001225

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000016 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Modules#Paste#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#Paste#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000022   0.000014 set cpo&vim


    1              0.000008 let s:module = {
                            \	"name" : "Paste"
                            \}

    1              0.000004 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("<Over>(paste)")
                            		let register = v:register == "" ? '"' : v:register
                            		call a:cmdline.insert(tr(getreg("*"), "\n", "\r"))
                            		call a:cmdline.setchar('')
                            	endif
                            endfunction


    1              0.000002 function! s:make()
                            	return deepcopy(s:module)
                            endfunction


    1   0.000013   0.000011 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim
Sourced 1 time
Total time:   0.002965
 Self time:   0.002949

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000016 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Modules#BufferComplete#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#BufferComplete#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000022   0.000014 set cpo&vim


    1              0.000004 function! s:_uniq(list)
                            	let dict = {}
                            	for _ in a:list
                            		let dict[_] = 0
                            	endfor
                            	return keys(dict)
                            endfunction


    1              0.000007 let s:module = {
                            \	"name" : "BufferComplete",
                            \}


    1              0.000002 function! s:_buffer_complete()
                            	return sort(s:_uniq(filter(split(join(getline(1, '$')), '\W'), '!empty(v:val)')), 1)
                            endfunction


    1              0.000002 function! s:_parse_line(line)
                            	let keyword = matchstr(a:line, '\zs\w\+\ze$')
                            	let pos = strchars(a:line) - strchars(keyword)
                            	return [pos, keyword]
                            endfunction


    1              0.000003 function! s:_as_statusline(list, count)
                            	if empty(a:list)
                            		return
                            	endif
                            	let hl_none = "%#StatusLine#"
                            	let hl_select = "%#StatusLineNC#"
                            	let tail = " > "
                            	let result = a:list[0]
                            	let pos = 0
                            	for i in range(1, len(a:list)-1)
                            		if strdisplaywidth(result . " " . a:list[i]) > &columns - len(tail)
                            			if a:count < i
                            				break
                            			else
                            				let pos = -i
                            			endif
                            			let result = a:list[i]
                            		else
                            			let result .= (" " . a:list[i])
                            		endif
                            		if a:count == i
                            			let pos = pos + i
                            		endif
                            	endfor
                            	return join(map(split(result, " "), 'v:key == pos ? hl_select . v:val . hl_none : v:val'))
                            endfunction


    1              0.000003 function! s:module.get_complete_words()
                            	return s:_buffer_complete()
                            endfunction


    1              0.000003 function! s:module.complete(cmdline)
                            	call s:_finish()
                            	let s:old_statusline = &statusline

                            	let backward = a:cmdline.backward()
                            	let [pos, keyword] = s:_parse_line(backward)

                            	if !exists("s:complete")
                            		let s:complete = self.get_complete_words()
                            	endif
                            	let s:complete_list = filter(copy(s:complete), 'v:val =~ ''^''.keyword')
                            	if empty(s:complete_list)
                            		return -1
                            	endif

                            	if pos == 0
                            		let backward = ""
                            	else
                            		let backward = join(split(backward, '\zs')[ : pos-1 ], "")
                            	endif
                            	let s:line = backward . a:cmdline.forward()
                            	let s:pos = pos
                            	call a:cmdline.setline(s:line)

                            	let s:count = 0
                            endfunction


    1              0.000003 function! s:_finish()
                            	if exists("s:old_statusline")
                            		let &statusline = s:old_statusline
                            		unlet s:old_statusline
                            		redrawstatus
                            	endif
                            endfunction


    1              0.000002 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("<Over>(buffer-complete)")
                            \		|| a:cmdline.is_input("<Over>(buffer-complete-prev)")
                            		if self.complete(a:cmdline) == -1
                            			call s:_finish()
                            			call a:cmdline.setchar('')
                            			return
                            		endif
                            		if a:cmdline.is_input("<Over>(buffer-complete-prev)")
                            			let s:count = len(s:complete_list) - 1
                            		endif
                            		call a:cmdline.setchar('')
                            		call a:cmdline.tap_keyinput("Completion")
                            " 	elseif a:cmdline.is_input("\<Tab>", "Completion")
                            	elseif a:cmdline.is_input("<Over>(buffer-complete)", "Completion")
                            \		|| a:cmdline.is_input("\<Right>", "Completion")
                            		call a:cmdline.setchar('')
                            		let s:count += 1
                            		if s:count >= len(s:complete_list)
                            			let s:count = 0
                            		endif
                            	elseif a:cmdline.is_input("<Over>(buffer-complete-prev)", "Completion")
                            \		|| a:cmdline.is_input("\<Left>", "Completion")
                            		call a:cmdline.setchar('')
                            		let s:count -= 1
                            		if s:count < 0
                            			let s:count = len(s:complete_list) - 1
                            		endif
                            	else
                            		if a:cmdline.untap_keyinput("Completion")
                            			call a:cmdline.callevent("on_char_pre")
                            		endif
                            		call s:_finish()
                            		return
                            	endif
                            	call a:cmdline.setline(s:line)
                            	call a:cmdline.insert(s:complete_list[s:count], s:pos)
                            	if len(s:complete_list) > 1
                            		let &statusline = s:_as_statusline(s:complete_list, s:count)
                            		redrawstatus
                            	endif
                            	if len(s:complete_list) == 1
                            		call a:cmdline.untap_keyinput("Completion")
                            	endif
                            endfunction


    1              0.000013 function! s:module.on_draw_pre(...)
                            " 	redrawstatus
                            endfunction


    1              0.000003 function! s:module.on_leave(cmdline)
                            	call s:_finish()
                            	unlet! s:complete
                            endfunction

    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction

    1   0.000034   0.000024 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim
Sourced 1 time
Total time:   0.002130
 Self time:   0.002114

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000016 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Modules#InsertRegister#import() abort
                                return map({'_vital_depends': '', 'to_string': '', 'input': '', 'get_cmdline_cword': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#InsertRegister#import() abort', printf("return map({'_vital_depends': '', 'to_string': '', 'input': '', 'get_cmdline_cword': '', 'make': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000022   0.000015 set cpo&vim


    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:String  = s:V.import("Over.String")
                            endfunction


    1              0.000002 function! s:_vital_depends()
                            	return [
                            \		"Over.String",
                            \	]
                            endfunction


    1              0.000002 function! s:to_string(expr)
                            	return type(a:expr) == type("") ? a:expr : string(a:expr)
                            endfunction


    1              0.000002 function! s:input(cmdline)
                            	let CR_index = index(a:cmdline.input_key_stack(), "\<CR>")
                            	if CR_index != -1
                            		let input = a:cmdline.input_key_stack_string()
                            		let input = input[ : CR_index-1]
                            		call a:cmdline.set_input_key_stack(a:cmdline.input_key_stack()[CR_index+1 : ])
                            		return eval(input)
                            	endif

                            	let input_text = ""
                            	if !empty(a:cmdline.input_key_stack())
                            		let input_text = a:cmdline.input_key_stack_string()
                            		call a:cmdline.set_input_key_stack([])
                            	endif

                            	call a:cmdline.hl_cursor_on()
                            	try
                            		redraw
                            		let input = input("=", input_text, "expression")
                            		if !empty(input)
                            			let input = s:to_string(eval(input))
                            		endif
                            	catch
                            		return ""
                            	finally
                            		call a:cmdline.hl_cursor_off()
                            	endtry
                            	return input
                            endfunction


    1              0.000011 let s:module = {
                            \	"name" : "InsertRegister"
                            \}



    1              0.000003 function! s:module.reset()
                            	let self.cword = expand("<cword>")
                            	let self.cWORD = expand("<cWORD>")
                            	let self.cfile = expand("<cfile>")
                            endfunction

    1              0.000002 function! s:module.on_enter(...)
                            	call self.reset()
                            " 	let self.prefix_key = ""
                            endfunction


    1              0.000003 function! s:get_cmdline_cword(backward, cword)
                            " 	let backward = matchstr(a:backward, '.\{-}\zs\k\+$')
                            	let backward = a:backward
                            	if &incsearch == 0 || a:cword == "" || a:backward == "" || s:String.index(a:cword, backward) != 0
                            		return a:cword
                            	endif
                            	return a:cword[len(backward) : ]
                            endfunction


    1              0.000002 function! s:module.on_char_pre(cmdline)
                            	if a:cmdline.is_input("\<C-r>")
                            		call a:cmdline.setchar('"')
                            		let self.prefix_key = a:cmdline.input_key()
                            		let self.old_line = a:cmdline.getline()
                            		let self.old_pos  = a:cmdline.getpos()
                            		return
                            	elseif exists("self.prefix_key")
                            \		&& a:cmdline.get_tap_key() == self.prefix_key
                            		call a:cmdline.setline(self.old_line)
                            		call a:cmdline.setpos(self.old_pos)
                            		let char = a:cmdline.input_key()
                            		if char =~ '^[0-9a-zA-z.%#:/"\-*+]$'
                            			let register = tr(getreg(char), "\n", "\r")
                            			call a:cmdline.setchar(register)
                            		elseif char == "="
                            			call a:cmdline.setchar(s:input(a:cmdline))
                            		elseif char == "\<C-w>"
                            			call a:cmdline.setchar(s:get_cmdline_cword(a:cmdline.backward_word(), self.cword))
                            		elseif char == "\<C-a>"
                            			call a:cmdline.setchar(self.cWORD)
                            		elseif char == "\<C-f>"
                            			call a:cmdline.setchar(self.cfile)
                            		elseif char == "\<C-r>"
                            			call a:cmdline.setchar('"')
                            		else
                            			call a:cmdline.setchar("")
                            		endif
                            " 		elseif a:cmdline.is_input('=', self.prefix_key)
                            " 			call a:cmdline.setchar(s:input(a:cmdline))
                            " 		elseif a:cmdline.is_input("\<C-w>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cword)
                            " 		elseif a:cmdline.is_input("\<C-a>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cWORD)
                            " 		elseif a:cmdline.is_input("\<C-f>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cfile)
                            " 		elseif a:cmdline.is_input("\<C-r>", self.prefix_key)
                            " 			call a:cmdline.setchar('"')
                            " 		else
                            " 			call a:cmdline.setchar("")
                            " 		endif
                            	endif
                            endfunction


    1              0.000014 function! s:module.on_char(cmdline)
                            	if a:cmdline.is_input("\<C-r>")
                            		call a:cmdline.tap_keyinput(self.prefix_key)
                            		call a:cmdline.disable_keymapping()
                            		call a:cmdline.setpos(a:cmdline.getpos()-1)
                            	else
                            		if exists("self.prefix_key")
                            			call a:cmdline.untap_keyinput(self.prefix_key)
                            			call a:cmdline.enable_keymapping()
                            			unlet! self.prefix_key
                            		endif
                            	endif
                            endfunction



    1              0.000003 function! s:make()
                            	return deepcopy(s:module)
                            endfunction

    1   0.000034   0.000026 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionExit.vim
Sourced 1 time
Total time:   0.001270
 Self time:   0.001258

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000017 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Modules#ExceptionExit#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#ExceptionExit#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000025   0.000016 set cpo&vim

    1              0.000008 let s:module = {
                            \	"name" : "ExceptionExit",
                            \}


    1              0.000004 function! s:module.on_exception(cmdline)
                            	call a:cmdline.exit(-1)
                            endfunction


    1              0.000002 function! s:make(...)
                            	let result = deepcopy(s:module)
                            	let result.exit_code = get(a:, 1, 0)
                            	return result
                            endfunction

    1   0.000014   0.000011 let &cpo = s:save_cpo
    1              0.000011 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionMessage.vim
Sourced 1 time
Total time:   0.001286
 Self time:   0.001274

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000017 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Modules#ExceptionMessage#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#ExceptionMessage#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000014 let s:save_cpo = &cpo
    1   0.000024   0.000015 set cpo&vim


    1              0.000011 let s:vname = expand("<sfile>:h:h:h:h:t")


    1              0.000007 let s:module = {
                            \	"name" : "ExceptionMessage",
                            \}


    1              0.000004 function! s:module.on_exception(cmdline)
                            	let self.exception  = v:exception
                            	let self.throwpoint = v:throwpoint
                            endfunction


    1              0.000002 function! s:module.on_draw_pre(cmdline)
                            	if has_key(self, "exception")
                            		call self.message(a:cmdline)
                            		unlet self.exception
                            	endif
                            endfunction

    1              0.000002 function! s:module.message(...)
                            	echohl ErrorMsg
                            	execute self.command string(self.prefix . " : " . self.throwpoint . " " . self.exception)
                            	echohl None
                            endfunction


    1              0.000002 function! s:module.on_leave(cmdline)
                            	if has_key(self, "exception")
                            		call self.message(a:cmdline)
                            		unlet self.exception
                            	endif
                            endfunction


    1              0.000002 function! s:make(...)
                            	let result = deepcopy(s:module)
                            	let result.prefix = get(a:, 1, "vital-over(".s:vname.") Exception")
                            	let result.command = get(a:, 2, "echom")
                            	return result
                            endfunction


    1   0.000015   0.000012 let &cpo = s:save_cpo
    1              0.000012 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/History.vim
Sourced 1 time
Total time:   0.001340
 Self time:   0.001329

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000016 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Modules#History#import() abort
                                return map({'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#History#import() abort', printf("return map({'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000023   0.000014 set cpo&vim

    1              0.000019 let s:module = {
                            \	"name" : "History",
                            \	"mode" : "cmd",
                            \}

    1              0.000003 function! s:module.histories()
                            	return map(range(1, &history), 'histget(self.mode, v:val * -1)')
                            endfunction

    1              0.000003 function! s:_should_match_cmdline(cmdline)
                            	return a:cmdline.is_input("\<Up>")
                            \		|| a:cmdline.is_input("\<Down>")
                            endfunction

    1              0.000002 function! s:_reset()
                            	let s:cmdhist = []
                            	let s:count = 0
                            	let s:is_match_mode = 0 " <Up>/<Down>: true, <C-n>/<C-p>: false
                            endfunction

    1              0.000002 function! s:module.on_enter(...)
                            	call s:_reset()
                            endfunction

    1              0.000002 function! s:module.on_char_pre(cmdline)
                            	if !a:cmdline.is_input("\<Up>") && !a:cmdline.is_input("\<Down>")
                            	\	&& !a:cmdline.is_input("\<C-p>") && !a:cmdline.is_input("\<C-n>")
                            		call s:_reset()
                            		return
                            	else
                            		if s:count == 0 && empty(s:cmdhist)
                            		\	|| s:is_match_mode != s:_should_match_cmdline(a:cmdline)
                            			let cmdline = '^' . a:cmdline.getline()
                            			let s:is_match_mode = s:_should_match_cmdline(a:cmdline)
                            			let s:cmdhist = [a:cmdline.getline()] + (s:is_match_mode ?
                            			\	filter(self.histories(), 'v:val =~ cmdline') : self.histories())
                            		endif
                            	endif
                            	call a:cmdline.setchar("")
                            	if a:cmdline.is_input("\<Down>") || a:cmdline.is_input("\<C-n>")
                            		let s:count = max([s:count - 1, 0])
                            	endif
                            	if a:cmdline.is_input("\<Up>") || a:cmdline.is_input("\<C-p>")
                            		let s:count = min([s:count + 1, len(s:cmdhist)])
                            	endif
                            	call a:cmdline.setline(get(s:cmdhist, s:count, a:cmdline.getline()))
                            endfunction

    1              0.000002 function! s:make(...)
                            	let module = deepcopy(s:module)
                            	let module.mode = get(a:, 1, "cmd")
                            	return module
                            endfunction

    1   0.000014   0.000012 let &cpo = s:save_cpo
    1              0.000011 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/NoInsert.vim
Sourced 1 time
Total time:   0.001421
 Self time:   0.001410

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000016 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Modules#NoInsert#import() abort
                                return map({'make_special_chars': '', 'make': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#NoInsert#import() abort', printf("return map({'make_special_chars': '', 'make': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000022   0.000014 set cpo&vim

    1              0.000009 let s:module = {
                            \	"name" : "NoInsert",
                            \	"chars" : []
                            \}


    1              0.000004 function! s:module.is_no_insert(char)
                            	return index(self.chars, a:char) >= 0
                            endfunction


    1              0.000002 function! s:module.on_char_pre(cmdline)
                            	if self.is_no_insert(a:cmdline.char())
                            		call a:cmdline.setchar("", 0)
                            	endif
                            endfunction


    1              0.000002 function! s:make(chars)
                            	let module = deepcopy(s:module)
                            	let module.chars = type(a:chars) == type([]) ? a:chars : [a:chars]
                            	return module
                            endfunction


    1              0.000002 function! s:make_special_chars()
                            	let module = s:make([])
                            	function! module.is_no_insert(char)
                            		return char2nr(a:char) == 128 || char2nr(a:char) < 27
                            	endfunction
                            	return module
                            endfunction


    1   0.000014   0.000011 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/KeyMapping.vim
Sourced 1 time
Total time:   0.001447
 Self time:   0.001436

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000016 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000007   function! vital#_easymotion#Over#Commandline#Modules#KeyMapping#import() abort
                                return map({'_vital_depends': '', 'make_emacs': '', 'make_vim_cmdline_mapping': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#KeyMapping#import() abort', printf("return map({'_vital_depends': '', 'make_emacs': '', 'make_vim_cmdline_mapping': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000022   0.000015 set cpo&vim


    1              0.000004 function! s:_vital_loaded(V)
                            	let s:Keymapping = a:V.import("Palette.Keymapping")
                            endfunction


    1              0.000002 function! s:_vital_depends()
                            	return [
                            \		"Palette.Keymapping",
                            \	]
                            endfunction


    1              0.000007 let s:emacs = {
                            \	"name" : "KeyMapping_emacs_like"
                            \}

    1              0.000003 function! s:emacs.keymapping(cmdline)
                            	return {
                            \		"\<C-f>" : {
                            \			"key" : "\<Right>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-b>" : {
                            \			"key" : "\<Left>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-n>" : {
                            \			"key" : "\<Down>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-p>" : {
                            \			"key" : "\<Up>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-a>" : {
                            \			"key" : "\<Home>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-e>" : {
                            \			"key" : "\<End>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<C-d>" : {
                            \			"key" : "\<Del>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<A-d>" : {
                            \			"key" : "\<C-w>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<A-b>" : {
                            \			"key" : "\<S-Left>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \		"\<A-f>" : {
                            \			"key" : "\<S-Right>",
                            \			"noremap" : 1,
                            \			"lock" : 1,
                            \		},
                            \	}
                            endfunction


    1              0.000002 function! s:make_emacs()
                            	return deepcopy(s:emacs)
                            endfunction


    1              0.000012 let s:vim_cmdline_mapping = {
                            \	"name" : "KeyMapping_vim_cmdline_mapping",
                            \	"_cmaps" : {}
                            \}

    1              0.000003 function! s:_convert_sid(rhs, sid) abort
                            	return substitute(a:rhs, '<SID>', '<SNR>' . a:sid . '_', 'g')
                            endfunction

    1              0.000002 function! s:_auto_cmap()
                            	let cmaps = {}
                            	let cmap_info = s:Keymapping.rhs_key_list("c", 0, 1)
                            	" vital-over currently doesn't support <buffer> mappings
                            	for c in filter(cmap_info, "v:val['buffer'] ==# 0")
                            		let cmaps[s:Keymapping.escape_special_key(c['lhs'])] = {
                            		\   'noremap' : c['noremap'],
                            		\   'key'  : s:Keymapping.escape_special_key(s:_convert_sid(c['rhs'], c['sid'])),
                            		\   'expr' : s:Keymapping.escape_special_key(c['expr']),
                            		\ }
                            	endfor
                            	return cmaps
                            endfunction


    1              0.000003 function! s:vim_cmdline_mapping.on_enter(cmdline)
                            	let self._cmaps = s:_auto_cmap()
                            endfunction


    1              0.000002 function! s:vim_cmdline_mapping.keymapping(cmdline)
                            	return self._cmaps
                            endfunction


    1              0.000002 function! s:make_vim_cmdline_mapping()
                            	return deepcopy(s:vim_cmdline_mapping)
                            endfunction



    1   0.000015   0.000012 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Keymapping.vim
Sourced 1 time
Total time:   0.001285
 Self time:   0.001275

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000016 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Palette#Keymapping#import() abort
                                return map({'capture': '', '_vital_depends': '', 'escape_special_key': '', 'rhs_key_list': '', 'parse_lhs_list': '', 'lhs_key_list': '', 'capture_list': '', 'parse_lhs': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Palette#Keymapping#import() abort', printf("return map({'capture': '', '_vital_depends': '', 'escape_special_key': '', 'rhs_key_list': '', 'parse_lhs_list': '', 'lhs_key_list': '', 'capture_list': '', 'parse_lhs': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000012 let s:save_cpo = &cpo
    1   0.000022   0.000014 set cpo&vim


    1              0.000004 let s:modep = "[nvoicsxl]"


    1              0.000004 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:Capture  = s:V.import("Palette.Capture")
                            endfunction


    1              0.000002 function! s:_vital_depends()
                            	return [
                            \		"Palette.Capture",
                            \	]
                            endfunction


    1              0.000002 function! s:_capture(mode)
                            	let cmd = "map"
                            	if a:mode ==# "!"
                            		let cmd = cmd . "!"
                            	elseif a:mode =~# "[nvoicsxl]"
                            		let cmd = a:mode . cmd
                            	endif
                            	return s:Capture.command(cmd)
                            endfunction


    1              0.000002 function! s:capture(...)
                            	let mode = get(a:, 1, "")
                            	let modes = split(mode, '\zs')
                            	return join(map(modes, "s:_capture(v:val)"), "\n")
                            endfunction


    1              0.000002 function! s:_keymapping(str)
                            	return a:str =~ '^[!nvoicsxl]\s'
                            endfunction


    1              0.000002 function! s:capture_list(...)
                            	let mode = get(a:, 1, "")
                            	return filter(split(s:capture(mode), "\n"), "s:_keymapping(v:val)")
                            endfunction


    1              0.000002 function! s:escape_special_key(key)
                            	" Workaround : <C-?> https://github.com/osyo-manga/vital-palette/issues/5
                            	if a:key ==# "<^?>"
                            		return "\<C-?>"
                            	endif
                            	execute 'let result = "' . substitute(escape(a:key, '\"'), '\(<.\{-}>\)', '\\\1', 'g') . '"'
                            	return result
                            endfunction


    1              0.000002 function! s:parse_lhs(text, ...)
                            	let mode = get(a:, 1, '[!nvoicsxl]')
                            	" NOTE: :map! Surpport : https://github.com/osyo-manga/vital-palette/issues/4
                            	if get(a:, 1, "") =~# '[!ci]'
                            		let mode = '[!ci]'
                            	endif
                            	return matchstr(a:text, mode . '\{1,3\}\s*\zs\S\{-}\ze\s\+')
                            endfunction


    1              0.000002 function! s:parse_lhs_list(...)
                            	let mode = get(a:, 1, "")
                            	return map(s:capture_list(mode), "s:parse_lhs(v:val, mode)")
                            endfunction


    1              0.000002 function! s:lhs_key_list(...)
                            	let mode = get(a:, 1, "")
                            	return map(s:parse_lhs_list(mode), "s:escape_special_key(v:val)")
                            endfunction


    1              0.000003 function! s:_maparg(name, mode, abbr, dict)
                            	" Workaround : <C-?> https://github.com/osyo-manga/vital-palette/issues/5
                            	if a:name ==# "<^?>"
                            		return maparg("\<C-?>", a:mode, a:abbr, a:dict)
                            	endif
                            	return maparg(a:name, a:mode, a:abbr, a:dict)
                            endfunction


    1              0.000002 function! s:rhs_key_list(...)
                            	let mode = get(a:, 1, "")
                            	let abbr = get(a:, 2, 0)
                            	let dict = get(a:, 3, 0)

                            	let result = []
                            	for m in split(mode, '\zs')
                            		let result += map(s:parse_lhs_list(m), "s:_maparg(v:val, m, abbr, dict)")
                            	endfor
                            	return filter(result, "empty(v:val) == 0")
                            endfunction


    1   0.000014   0.000012 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Capture.vim
Sourced 1 time
Total time:   0.001226
 Self time:   0.001210

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000018 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000006   function! vital#_easymotion#Palette#Capture#import() abort
                                return map({'extend': '', 'command': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Palette#Capture#import() abort', printf("return map({'extend': '', 'command': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000001 endif
                            " ___vital___
    1              0.000004 scriptencoding utf-8
    1              0.000013 let s:save_cpo = &cpo
    1   0.000025   0.000016 set cpo&vim


    1              0.000004 let s:verbosefiles = []

    1              0.000004 function! s:_verbosefile_push(file)
                            	call add(s:verbosefiles, &verbosefile)
                            	let &verbosefile = a:file
                            	return a:file
                            endfunction


    1              0.000002 function! s:_verbosefile_pop()
                            	let filename = &verbosefile
                            	let &verbosefile = get(s:verbosefiles, -1)
                            	call remove(s:verbosefiles, -1)
                            	return filename
                            endfunction


    1              0.000002 function! s:_reset()
                            	let s:verbosefiles = []
                            endfunction


    1              0.000002 function! s:extend(dict, src)
                            	for [key, value] in items(a:src)
                            		let a:dict[key] = value
                            		unlet value
                            	endfor
                            endfunction


    1              0.000003 function! s:command(cmd, ...)
                            	" Workaround : Vim 7.3.xxx in Travis and Ubuntu
                            	" https://github.com/osyo-manga/vital-palette/issues/5
                            " 	call extend(l:, get(a:, 1, {}))
                            	if a:0 > 0
                            		call s:extend(l:, a:1)
                            	endif

                            	call s:_verbosefile_push(tempname())
                            	try
                            		redir =>result
                            		silent execute a:cmd
                            	finally
                            		redir END
                            	endtry
                            	call s:_verbosefile_pop()
                            " 	let result = substitute(result, "<SRN>", "\<SNR>", "g")
                            " 	let result = substitute(result, "<SID>", "\<SID>", "g")
                            	return result
                            endfunction


    1   0.000019   0.000012 let &cpo = s:save_cpo
    1              0.000011 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim
Sourced 1 time
Total time:   0.002110
 Self time:   0.002091

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000030 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000013   function! vital#_easymotion#Over#Commandline#Modules#Doautocmd#import() abort
                                return map({'_vital_depends': '', 'doautocmd_user': '', 'get_cmdline': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Commandline#Modules#Doautocmd#import() abort', printf("return map({'_vital_depends': '', 'doautocmd_user': '', 'get_cmdline': '', 'make': '', '_vital_loaded': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000007 scriptencoding utf-8
    1              0.000023 let s:save_cpo = &cpo
    1   0.000043   0.000029 set cpo&vim


    1              0.000009 function! s:_vital_loaded(V)
                            	let s:V = a:V
                            	let s:E  = s:V.import("Over.Exception")
                            endfunction


    1              0.000005 function! s:_vital_depends()
                            	return [
                            \		"Over.Exception",
                            \	]
                            endfunction


    1              0.000009 let s:cache_command = {}
    1              0.000006 function! s:doautocmd_user(prefix, command)
                            	let group =  a:prefix . "-vital-over-commandline-doautocmd-dummy"
                            	if !has_key(s:cache_command, a:prefix)
                            		let s:cache_command[a:prefix] = {}
                            	endif

                            	if !has_key(s:cache_command[a:prefix], a:command)
                            		execute "autocmd " . group
                            \			. " User " . a:command." silent! execute ''"

                            		if v:version > 703 || v:version == 703 && has("patch438")
                            			let s:cache_command[a:prefix][a:command] = "doautocmd <nomodeline> User " . a:command
                            		else
                            			let s:cache_command[a:prefix][a:command] = "doautocmd User " . a:command
                            		endif
                            	endif

                            	execute s:cache_command[a:prefix][a:command]
                            endfunction


    1              0.000026 let s:hooks = [
                            \	"enter",
                            \	"leave",
                            \	"char",
                            \	"char_pre",
                            \	"draw",
                            \	"draw_pre",
                            \	"execute_pre",
                            \	"execute_failed",
                            \	"execute",
                            \	"exception",
                            \]

    1              0.000024 let s:hooks_camel = [
                            \	"Enter",
                            \	"Leave",
                            \	"Char",
                            \	"CharPre",
                            \	"Draw",
                            \	"DrawPre",
                            \	"ExecutePre",
                            \	"ExecuteFailed",
                            \	"Execute",
                            \	"Exception",
                            \]


    1              0.000011 let s:module = {
                            \	"name" : "Doautocmd",
                            \}


   11              0.000045 for s:i in range(len(s:hooks))
   10              0.000437 	execute join([
                            \		"function! s:module.on_" . s:hooks[s:i] . "(cmdline, ...)",
                            \		"	let s:cmdline = a:cmdline",
                            \		"	call s:doautocmd_user(self.prefix, self.prefix . " . string(s:hooks_camel[s:i]) . ")",
                            \		"endfunction",
                            \	], "\n")
   11              0.000020 endfor


    1              0.000004 function! s:get_cmdline()
                            	if !exists("s:cmdline")
                            		execute s:E.throw_cmd("Undefined cmdline object.", "Over.Commandline.Modules.Doautocmd")
                            	endif
                            	return s:cmdline
                            endfunction


    1              0.000004 function! s:make(prefix)
                            	if has_key(s:cache_command, a:prefix)
                            		unlet! s:cache_command[a:prefix]
                            	endif
                            	execute "augroup " a:prefix . "-vital-over-commandline-doautocmd-dummy"
                            		autocmd!
                            	augroup END

                            	let module = deepcopy(s:module)
                            	let module.prefix = a:prefix
                            	return module
                            endfunction


    1   0.000025   0.000020 let &cpo = s:save_cpo
    1              0.000018 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Exception.vim
Sourced 1 time
Total time:   0.001367
 Self time:   0.001350

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not mofidify the code nor insert new lines before '" ___vital___'
    1              0.000025 if v:version > 703 || v:version == 703 && has('patch1170')
    1              0.000010   function! vital#_easymotion#Over#Exception#import() abort
                                return map({'throw': '', 'throw_cmd': '', 'set_prefix': '', 'error': ''},  'function("s:" . v:key)')
                              endfunction
                            else
                              function! s:_SID() abort
                                return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                              endfunction
                              execute join(['function! vital#_easymotion#Over#Exception#import() abort', printf("return map({'throw': '', 'throw_cmd': '', 'set_prefix': '', 'error': ''}, \"function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
                              delfunction s:_SID
    1              0.000002 endif
                            " ___vital___
    1              0.000006 scriptencoding utf-8
    1              0.000018 let s:save_cpo = &cpo
    1   0.000038   0.000025 set cpo&vim


    1              0.000017 let s:vname = expand("<sfile>:h:h:t")
    1              0.000011 let s:prefix = printf("vital-over(%s) Exception", s:vname)

    1              0.000007 function! s:set_prefix(prefix)
                            	let s:prefix = a:prefix
                            endfunction

    1              0.000005 function! s:throw_cmd(exp, where)
                            	return 'throw ' . string(s:prefix . " : " . a:exp . " in " . a:where)
                            endfunction


    1              0.000004 function! s:throw(exp, where)
                            	execute s:throw_cmd(a:exp, a:where)
                            endfunction


    1              0.000004 function! s:error(text, where)
                            	echohl ErrorMsg
                            	echom s:prefix . " : " . a:text . " in " . a:where
                            	echohl None
                            endfunction


    1   0.000023   0.000019 let &cpo = s:save_cpo
    1              0.000015 unlet s:save_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-easymotion/autoload/EasyMotion/helper.vim
Sourced 1 time
Total time:   0.003400
 Self time:   0.003384

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/EasyMotion/helper.vim
                            " AUTHOR: haya14busa
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
    1              0.000007 scriptencoding utf-8
                            " Saving 'cpoptions' {{{
    1              0.000016 let s:save_cpo = &cpo
    1   0.000023   0.000015 set cpo&vim
                            " }}}

    1              0.000006 function! EasyMotion#helper#mode(flag) "{{{
                                return mode(a:flag) == "\<C-v>" ? "C-v" : mode(a:flag)
                            endfunction "}}}

    1              0.000004 function! EasyMotion#helper#get_char_by_coord(coord) "{{{
                                " @param coord: [lnum, col] or [bufnum, lnum, col, off]
                                if len(a:coord) == 4
                                    let [line_num, col_num] = [a:coord[1], a:coord[2]]
                                else
                                    let [line_num, col_num] = a:coord
                                endif
                                let target_col_regexp = '\%' . (col_num) . 'c.'
                                return matchstr(getline(line_num), target_col_regexp)
                            endfunction "}}}

    1              0.000004 function! EasyMotion#helper#is_greater_coords(coords1, coords2) "{{{
                                " [line_num, col_num] < [line_num, col_num]
                                "
                                " coords1 < coords2  : return 1
                                " coords1 > coords2  : return -1
                                " coords1 == coords2 : return 0
                                if a:coords1 == a:coords2 | return 0 | endif

                                if a:coords1[0] < a:coords2[0]
                                    return 1
                                elseif a:coords1[0] > a:coords2[0]
                                    return -1
                                endif

                                " Same line
                                if a:coords1[1] < a:coords2[1]
                                    return 1
                                elseif a:coords1[1] > a:coords2[1]
                                    return -1
                                endif
                            endfunction "}}}

    1              0.000003 function! EasyMotion#helper#is_folded(line) "{{{
                                " Return false if g:EasyMotion_skipfoldedline == 1
                                " and line is start of folded lines
                                let _foldclosed = foldclosed(a:line)
                                return _foldclosed != -1 &&
                                    \ (g:EasyMotion_skipfoldedline == 1 || a:line != _foldclosed)
                            endfunction "}}}
    1              0.000003 function! EasyMotion#helper#should_case_sensitive(input, is_search) "{{{
                                if !a:is_search
                                    if g:EasyMotion_smartcase == 0
                                        return 0
                                    else
                                        " return 1 if input didn't match uppercase letter
                                        return match(a:input, '\u') == -1
                                    endif
                                endif

                                if (g:EasyMotion_smartcase == 1 && match(a:input, '\u') == -1) ||
                                \  (&ignorecase && &smartcase && match(a:input, '\u') == -1) ||
                                \  (&ignorecase && !&smartcase)
                                    return 1
                                endif
                                return 0
                            endfunction "}}}
    1              0.000003 function! EasyMotion#helper#silent_feedkeys(expr, name, ...) "{{{
                                " Ref:
                                " https://github.com/osyo-manga/vim-over/blob/d51b028c29661d4a5f5b79438ad6d69266753711/autoload/over.vim#L6
                                let mode = get(a:, 1, "m")
                                let name = "easymotion-" . a:name
                                let map = printf("<Plug>(%s)", name)
                                if mode == "n"
                                    let command = "nnoremap"
                                else
                                    let command = "nmap"
                                endif
                                execute command "<silent>" map printf("%s:nunmap %s<CR>", a:expr, map)
                                if mode(1) !=# 'ce'
                                    " FIXME: mode(1) !=# 'ce' exists only for the test
                                    "        :h feedkeys() doesn't work while runnning a test script
                                    "        https://github.com/kana/vim-vspec/issues/27
                                    call feedkeys(printf("\<Plug>(%s)", name))
                                endif
                            endfunction "}}}
    1              0.000010 function! EasyMotion#helper#VarReset(var, ...) "{{{
                                if ! exists('s:var_reset')
                                    let s:var_reset = {}
                                endif

                                if a:0 == 0 && has_key(s:var_reset, a:var)
                                    " Reset var to original value
                                    " setbufvar( or bufname): '' or '%' can be used for the current buffer
                                    call setbufvar('%', a:var, s:var_reset[a:var])
                                elseif a:0 == 1
                                    " Save original value and set new var value

                                    let new_value = a:0 == 1 ? a:1 : ''

                                    " Store original value
                                    let s:var_reset[a:var] = getbufvar("", a:var)

                                    " Set new var value
                                    call setbufvar('%', a:var, new_value)
                                endif
                            endfunction "}}}

                            " Migemo {{{
    1              0.000004 function! EasyMotion#helper#load_migemo_dict() "{{{
                                let enc = &l:encoding
                                if enc ==# 'utf-8'
                                    return EasyMotion#migemo#utf8#load_dict()
                                elseif enc ==# 'cp932'
                                    return EasyMotion#migemo#cp932#load_dict()
                                elseif enc ==# 'euc-jp'
                                    return EasyMotion#migemo#eucjp#load_dict()
                                else
                                    let g:EasyMotion_use_migemo = 0
                                    throw "Error: ".enc." is not supported. Migemo is made disabled."
                                endif
                            endfunction "}}}

                            " EasyMotion#helper#strchars() {{{
    1              0.000011 if exists('*strchars')
    1              0.000003     function! EasyMotion#helper#strchars(str)
                                    return strchars(a:str)
                                endfunction
                            else
                                function! EasyMotion#helper#strchars(str)
                                    return strlen(substitute(a:str, ".", "x", "g"))
                                endfunction
    1              0.000002 endif "}}}
    1              0.000003 function! EasyMotion#helper#include_multibyte_char(str) "{{{
                                return strlen(a:str) != EasyMotion#helper#strchars(a:str)
                            endfunction "}}}

    1              0.000003 function! EasyMotion#helper#vcol(expr) abort
                                let col_num = col(a:expr)
                                let line = getline(a:expr)
                                let before_line = col_num > 2 ? line[: col_num - 2]
                                \   : col_num is# 2 ? line[0]
                                \   : ''
                                let vcol_num = 1
                                for c in split(before_line, '\zs')
                                    let vcol_num += c is# "\t" ? s:_virtual_tab2spacelen(vcol_num) : len(c)
                                endfor
                                return vcol_num
                            endfunction

    1              0.000006 function! s:_virtual_tab2spacelen(col_num) abort
                                return &tabstop - ((a:col_num - 1) % &tabstop)
                            endfunction

                            "}}}

                            " Restore 'cpoptions' {{{
    1   0.000031   0.000023 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            " }}}
                            " vim: fdm=marker:et:ts=4:sw=4:sts=4

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/typescriptreact.vim
Sourced 1 time
Total time:   0.159808
 Self time:   0.002675

count  total (s)   self (s)
    1              0.000030 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000005 if !exists("main_syntax")
    1              0.000004   if exists("b:current_syntax")
                                finish
    1              0.000001   endif
    1              0.000008   let main_syntax = 'typescriptreact'
    1              0.000001 endif

    1              0.000182 syntax region tsxTag
                                  \ start=+<\([^/!?<>="':]\+\)\@=+
                                  \ skip=+</[^ /!?<>"']\+>+
                                  \ end=+/\@<!>+
                                  \ end=+\(/>\)\@=+
                                  \ contained
                                  \ contains=tsxTagName,tsxIntrinsicTagName,tsxAttrib,tsxEscJs,
                                            \tsxCloseString,@tsxComment

    1              0.000006 syntax match tsxTag /<>/ contained


                            " <tag></tag>
                            " s~~~~~~~~~e
                            " and self close tag
                            " <tag/>
                            " s~~~~e
                            " A big start regexp borrowed from https://git.io/vDyxc
    1              0.000116 syntax region tsxRegion
                                  \ start=+<\_s*\z([a-zA-Z1-9\$_-]\+\(\.\k\+\)*\)+
                                  \ skip=+<!--\_.\{-}-->+
                                  \ end=+</\_s*\z1>+
                                  \ matchgroup=tsxCloseString end=+/>+
                                  \ fold
                                  \ contains=tsxRegion,tsxCloseString,tsxCloseTag,tsxTag,tsxCommentInvalid,tsxFragment,tsxEscJs,@Spell
                                  \ keepend
                                  \ extend

                            " <>   </>
                            " s~~~~~~e
                            " A big start regexp borrowed from https://git.io/vDyxc
    1              0.000045 syntax region tsxFragment
                                  \ start=+\(\((\|{\|}\|\[\|,\|&&\|||\|?\|:\|=\|=>\|\Wreturn\|^return\|\Wdefault\|^\|>\)\_s*\)\@<=<>+
                                  \ skip=+<!--\_.\{-}-->+
                                  \ end=+</>+
                                  \ fold
                                  \ contains=tsxRegion,tsxCloseString,tsxCloseTag,tsxTag,tsxCommentInvalid,tsxFragment,tsxEscJs,@Spell
                                  \ keepend
                                  \ extend

                            " </tag>
                            " ~~~~~~
    1              0.000013 syntax match tsxCloseTag
                                  \ +</\_s*[^/!?<>"']\+>+
                                  \ contained
                                  \ contains=tsxTagName,tsxIntrinsicTagName

    1              0.000004 syntax match tsxCloseTag +</>+ contained

    1              0.000005 syntax match tsxCloseString
                                  \ +/>+
                                  \ contained

                            " <!-- -->
                            " ~~~~~~~~
    1              0.000005 syntax match tsxCommentInvalid /<!--\_.\{-}-->/ display

    1              0.000028 syntax region tsxBlockComment
                                \ contained
                                \ start="/\*"
                                \ end="\*/"

    1              0.000025 syntax match tsxLineComment
                                \ "//.*$"
                                \ contained
                                \ display

    1              0.000006 syntax cluster tsxComment contains=tsxBlockComment,tsxLineComment

    1              0.000047 syntax match tsxEntity "&[^; \t]*;" contains=tsxEntityPunct
    1              0.000006 syntax match tsxEntityPunct contained "[&.;]"

                            " <tag key={this.props.key}>
                            "  ~~~
    1              0.000013 syntax match tsxTagName
                                \ +[</]\_s*[^/!?<>"'* ]\++hs=s+1
                                \ contained
                                \ nextgroup=tsxAttrib
                                \ skipwhite
                                \ display
    1              0.000011 syntax match tsxIntrinsicTagName
                                \ +[</]\_s*[a-z1-9-]\++hs=s+1
                                \ contained
                                \ nextgroup=tsxAttrib
                                \ skipwhite
                                \ display

                            " <tag key={this.props.key}>
                            "      ~~~
    1              0.000028 syntax match tsxAttrib
                                \ +[a-zA-Z_][-0-9a-zA-Z_]*+
                                \ nextgroup=tsxEqual skipwhite
                                \ contained
                                \ display

                            " <tag id="sample">
                            "        ~
    1              0.000026 syntax match tsxEqual +=+ display contained
                              \ nextgroup=tsxString skipwhite

                            " <tag id="sample">
                            "         s~~~~~~e
    1              0.000011 syntax region tsxString contained start=+"+ end=+"+ contains=tsxEntity,@Spell display

                            " <tag key={this.props.key}>
                            "          s~~~~~~~~~~~~~~e
    1              0.000024 syntax region tsxEscJs
                                \ contained
                                \ contains=@typescriptValue,@tsxComment
                                \ matchgroup=typescriptBraces
                                \ start=+{+
                                \ end=+}+
                                \ extend

    1   0.157683   0.000551 runtime syntax/common.vim

    1              0.000018 syntax cluster typescriptExpression add=tsxRegion,tsxFragment

    1              0.000017 highlight def link tsxTag htmlTag
    1              0.000021 highlight def link tsxTagName Function
    1              0.000017 highlight def link tsxIntrinsicTagName htmlTagName
    1              0.000022 highlight def link tsxString String
    1              0.000039 highlight def link tsxNameSpace Function
    1              0.000022 highlight def link tsxCommentInvalid Error
    1              0.000021 highlight def link tsxBlockComment Comment
    1              0.000021 highlight def link tsxLineComment Comment
    1              0.000022 highlight def link tsxAttrib Type
    1              0.000031 highlight def link tsxEscJs tsxEscapeJs
    1              0.000028 highlight def link tsxCloseTag htmlTag
    1              0.000035 highlight def link tsxCloseString Identifier

    1              0.000008 let b:current_syntax = "typescriptreact"
    1              0.000007 if main_syntax == 'typescriptreact'
    1              0.000011   unlet main_syntax
    1              0.000002 endif
SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/common.vim
Sourced 1 time
Total time:   0.157096
 Self time:   0.014788

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

                            " Define the default highlighting.
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    1              0.000017 let did_typescript_hilink = 1

    1              0.000005 syntax sync fromstart
    1              0.000021 command -nargs=+ HiLink hi def link <args>

                            "Dollar sign is permitted anywhere in an identifier
    1              0.000065 setlocal iskeyword-=$
    1              0.000007 if main_syntax == 'typescript' || main_syntax == 'typescriptreact'
    1              0.000055   setlocal iskeyword+=$
                              " syntax cluster htmlJavaScript                 contains=TOP
    1              0.000001 endif
                            " For private field added from TypeScript 3.8
    1              0.000053 setlocal iskeyword+=#

                            " lowest priority on least used feature
    1              0.000085 syntax match   typescriptLabel                /[a-zA-Z_$]\k*:/he=e-1 contains=typescriptReserved nextgroup=@typescriptStatement skipwhite skipempty

                            " other keywords like return,case,yield uses containedin
    1              0.000043 syntax region  typescriptBlock                 matchgroup=typescriptBraces start=/{/ end=/}/ contains=@typescriptStatement,@typescriptComments fold


    1   0.002732   0.000535 runtime syntax/basic/identifiers.vim
    1   0.002383   0.000516 runtime syntax/basic/literal.vim
    1   0.002402   0.000831 runtime syntax/basic/object.vim

    1   0.003855   0.001046 runtime syntax/basic/symbols.vim
                            " runtime syntax/basic/reserved.vim
    1   0.005094   0.000844 runtime syntax/basic/keyword.vim
    1   0.004046   0.000494 runtime syntax/basic/doc.vim
    1   0.004675   0.000511 runtime syntax/basic/type.vim

                            " extension
    1              0.000015 if get(g:, 'yats_host_keyword', 1)
    1   0.112067   0.000500   runtime syntax/yats.vim
    1              0.000002 endif

                            " patch
    1   0.001771   0.000507 runtime syntax/basic/patch.vim
    1   0.002367   0.000534 runtime syntax/basic/members.vim
    1   0.002944   0.000517 runtime syntax/basic/class.vim
    1   0.002376   0.000618 runtime syntax/basic/cluster.vim
    1   0.002285   0.000515 runtime syntax/basic/function.vim
    1   0.002141   0.000863 runtime syntax/basic/decorator.vim

    1              0.000007 if exists("did_typescript_hilink")
    1              0.000040   HiLink typescriptReserved             Error

    1              0.000035   HiLink typescriptEndColons            Exception
    1              0.000027   HiLink typescriptSymbols              Normal
    1              0.000035   HiLink typescriptBraces               Function
    1              0.000036   HiLink typescriptParens               Normal
    1              0.000025   HiLink typescriptComment              Comment
    1              0.000025   HiLink typescriptLineComment          Comment
    1              0.000025   HiLink typescriptDocComment           Comment
    1              0.000025   HiLink typescriptCommentTodo          Todo
    1              0.000025   HiLink typescriptMagicComment         SpecialComment
    1              0.000025   HiLink typescriptRef                  Include
    1              0.000025   HiLink typescriptDocNotation          SpecialComment
    1              0.000025   HiLink typescriptDocTags              SpecialComment
    1              0.000029   HiLink typescriptDocNGParam           typescriptDocParam
    1              0.000024   HiLink typescriptDocParam             Function
    1              0.000024   HiLink typescriptDocNumParam          Function
    1              0.000024   HiLink typescriptDocEventRef          Function
    1              0.000026   HiLink typescriptDocNamedParamType    Type
    1              0.000026   HiLink typescriptDocParamName         Type
    1              0.000025   HiLink typescriptDocParamType         Type
    1              0.000026   HiLink typescriptString               String
    1              0.000026   HiLink typescriptSpecial              Special
    1              0.000025   HiLink typescriptStringLiteralType    String
    1              0.000025   HiLink typescriptTemplateLiteralType  String
    1              0.000025   HiLink typescriptStringMember         String
    1              0.000026   HiLink typescriptTemplate             String
    1              0.000026   HiLink typescriptEventString          String
    1              0.000026   HiLink typescriptDestructureString    String
    1              0.000025   HiLink typescriptASCII                Special
    1              0.000034   HiLink typescriptTemplateSB           Label
    1              0.000026   HiLink typescriptRegexpString         String
    1              0.000039   HiLink typescriptGlobal               Constant
    1              0.000024   HiLink typescriptTestGlobal           Function
    1              0.000026   HiLink typescriptPrototype            Type
    1              0.000025   HiLink typescriptConditional          Conditional
    1              0.000025   HiLink typescriptConditionalElse      Conditional
    1              0.000025   HiLink typescriptCase                 Conditional
    1              0.000008   HiLink typescriptDefault              typescriptCase
    1              0.000024   HiLink typescriptBranch               Conditional
    1              0.000034   HiLink typescriptIdentifier           Structure
    1              0.000035   HiLink typescriptVariable             Identifier
    1              0.000025   HiLink typescriptDestructureVariable  PreProc
    1              0.000035   HiLink typescriptEnumKeyword          Identifier
    1              0.000025   HiLink typescriptRepeat               Repeat
    1              0.000025   HiLink typescriptForOperator          Repeat
    1              0.000025   HiLink typescriptStatementKeyword     Statement
    1              0.000034   HiLink typescriptMessage              Keyword
    1              0.000035   HiLink typescriptOperator             Identifier
    1              0.000026   HiLink typescriptKeywordOp            Identifier
    1              0.000034   HiLink typescriptCastKeyword          Special
    1              0.001314   HiLink typescriptType                 Type
    1              0.000036   HiLink typescriptNull                 Boolean
    1              0.000026   HiLink typescriptNumber               Number
    1              0.000024   HiLink typescriptBoolean              Boolean
    1              0.000018   HiLink typescriptObjectLabel          typescriptLabel
    1              0.000024   HiLink typescriptDestructureLabel     Function
    1              0.000024   HiLink typescriptLabel                Label
    1              0.000023   HiLink typescriptTupleLable           Label
    1              0.000033   HiLink typescriptStringProperty       String
    1              0.000033   HiLink typescriptImport               Special
    1              0.000024   HiLink typescriptImportType           Special
    1              0.000033   HiLink typescriptAmbientDeclaration   Special
    1              0.000032   HiLink typescriptExport               Special
    1              0.000024   HiLink typescriptExportType           Special
    1              0.000024   HiLink typescriptModule               Special
    1              0.000024   HiLink typescriptTry                  Special
    1              0.000032   HiLink typescriptExceptions           Special

    1              0.000032   HiLink typescriptMember              Function
    1              0.000034   HiLink typescriptMethodAccessor       Operator

    1              0.000022   HiLink typescriptAsyncFuncKeyword     Keyword
    1              0.000024   HiLink typescriptObjectAsyncKeyword   Keyword
    1              0.000024   HiLink typescriptAsyncFor             Keyword
    1              0.000023   HiLink typescriptFuncKeyword          Keyword
    1              0.000023   HiLink typescriptAsyncFunc            Keyword
    1              0.000034   HiLink typescriptArrowFunc            Type
    1              0.000023   HiLink typescriptFuncName             Function
    1              0.000042   HiLink typescriptFuncArg              PreProc
    1              0.000023   HiLink typescriptArrowFuncArg         PreProc
    1              0.000034   HiLink typescriptFuncComma            Operator

    1              0.000023   HiLink typescriptClassKeyword         Keyword
    1              0.000023   HiLink typescriptClassExtends         Keyword
                              " HiLink typescriptClassName            Function
    1              0.000032   HiLink typescriptAbstract             Special
                              " HiLink typescriptClassHeritage        Function
                              " HiLink typescriptInterfaceHeritage    Function
    1              0.000023   HiLink typescriptClassStatic          StorageClass
    1              0.000032   HiLink typescriptReadonlyModifier     Keyword
    1              0.000024   HiLink typescriptInterfaceKeyword     Keyword
    1              0.000023   HiLink typescriptInterfaceExtends     Keyword
    1              0.000033   HiLink typescriptInterfaceName        Function

    1              0.000023   HiLink shellbang                      Comment

    1              0.000033   HiLink typescriptTypeParameter         Identifier
    1              0.000023   HiLink typescriptConstraint            Keyword
    1              0.000024   HiLink typescriptPredefinedType        Type
    1              0.000024   HiLink typescriptReadonlyArrayKeyword  Keyword
    1              0.000025   HiLink typescriptUnion                 Operator
    1              0.000032   HiLink typescriptFuncTypeArrow         Function
    1              0.000024   HiLink typescriptConstructorType       Function
    1              0.000023   HiLink typescriptTypeQuery             Keyword
    1              0.000033   HiLink typescriptAccessibilityModifier Keyword
    1              0.000032   HiLink typescriptOptionalMark          PreProc
    1              0.000023   HiLink typescriptFuncType              Special
    1              0.000032   HiLink typescriptMappedIn              Special
    1              0.000032   HiLink typescriptCall                  PreProc
    1              0.000022   HiLink typescriptParamImpl             PreProc
    1              0.000024   HiLink typescriptConstructSignature    Identifier
    1              0.000024   HiLink typescriptAliasDeclaration      Identifier
    1              0.000023   HiLink typescriptAliasKeyword          Keyword
    1              0.000023   HiLink typescriptUserDefinedType       Keyword
    1              0.000033   HiLink typescriptTypeReference         Identifier
    1              0.000023   HiLink typescriptConstructor           Keyword
    1              0.000023   HiLink typescriptDecorator             Special
    1              0.000023   HiLink typescriptAssertType            Keyword

    1              0.000022   highlight link typeScript             NONE

    1              0.000004   delcommand HiLink
    1              0.000010   unlet did_typescript_hilink
    1              0.000007 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/basic/identifiers.vim
Sourced 1 time
Total time:   0.002159
 Self time:   0.002159

count  total (s)   self (s)
    1              0.000027 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000133 syntax cluster afterIdentifier contains=
                              \ typescriptDotNotation,
                              \ typescriptFuncCallArg,
                              \ typescriptTemplate,
                              \ typescriptIndexExpr,
                              \ @typescriptSymbols,
                              \ typescriptTypeArguments

    1              0.000030 syntax match   typescriptIdentifierName        /\<\K\k*/
                              \ nextgroup=@afterIdentifier
                              \ transparent
                              \ contains=@_semantic
                              \ skipnl skipwhite

    1              0.000022 syntax match   typescriptProp contained /\K\k*!\?/
                              \ transparent
                              \ contains=@props
                              \ nextgroup=@afterIdentifier
                              \ skipwhite skipempty

    1              0.000061 syntax region  typescriptIndexExpr      contained matchgroup=typescriptProperty start=/\[/rs=s+1 end=/]/he=e-1 contains=@typescriptValue nextgroup=@typescriptSymbols,typescriptDotNotation,typescriptFuncCallArg skipwhite skipempty

    1              0.000033 syntax match   typescriptDotNotation           /\.\|?\.\|!\./ nextgroup=typescriptProp skipnl
    1              0.000043 syntax match   typescriptDotStyleNotation      /\.style\./ nextgroup=typescriptDOMStyle transparent
                            " syntax match   typescriptFuncCall              contained /[a-zA-Z]\k*\ze(/ nextgroup=typescriptFuncCallArg
    1              0.000049 syntax region  typescriptParenExp              matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptComments,@typescriptValue,typescriptCastKeyword nextgroup=@typescriptSymbols skipwhite skipempty
    1              0.000039 syntax region  typescriptFuncCallArg           contained matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptValue,@typescriptComments nextgroup=@typescriptSymbols,typescriptDotNotation skipwhite skipempty skipnl
    1              0.000039 syntax region  typescriptEventFuncCallArg      contained matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptEventExpression
    1              0.000058 syntax region  typescriptEventString           contained start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1\|$/ contains=typescriptASCII,@events

    1              0.000056 syntax region  typescriptDestructureString
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1\|$/
                              \ contains=typescriptASCII
                              \ nextgroup=typescriptDestructureAs
                              \ contained skipwhite skipempty

    1              0.000026 syntax cluster typescriptVariableDeclarations
                              \ contains=typescriptVariableDeclaration,@typescriptDestructures

    1              0.000053 syntax match typescriptVariableDeclaration /[A-Za-z_$]\k*/
                              \ nextgroup=typescriptTypeAnnotation,typescriptAssign
                              \ contained skipwhite skipempty

    1              0.000085 syntax cluster typescriptDestructureVariables contains=
                              \ typescriptRestOrSpread,
                              \ typescriptDestructureComma,
                              \ typescriptDestructureLabel,
                              \ typescriptDestructureVariable,
                              \ @typescriptDestructures

    1              0.000026 syntax match typescriptDestructureVariable    /[A-Za-z_$]\k*/ contained
                              \ nextgroup=typescriptDefaultParam
                              \ contained skipwhite skipempty

    1              0.000011 syntax match typescriptDestructureLabel       /[A-Za-z_$]\k*\ze\_s*:/
                              \ nextgroup=typescriptDestructureAs
                              \ contained skipwhite skipempty

    1              0.000009 syntax match typescriptDestructureAs /:/
                              \ nextgroup=typescriptDestructureVariable,@typescriptDestructures
                              \ contained skipwhite skipempty

    1              0.000003 syntax match typescriptDestructureComma /,/ contained

    1              0.000043 syntax cluster typescriptDestructures contains=
                              \ typescriptArrayDestructure,
                              \ typescriptObjectDestructure

    1              0.000061 syntax region typescriptArrayDestructure matchgroup=typescriptBraces
                              \ start=/\[/ end=/]/
                              \ contains=@typescriptDestructureVariables,@typescriptComments
                              \ nextgroup=typescriptTypeAnnotation,typescriptAssign
                              \ transparent contained skipwhite skipempty fold

    1              0.000070 syntax region typescriptObjectDestructure matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contains=typescriptDestructureString,@typescriptDestructureVariables,@typescriptComments
                              \ nextgroup=typescriptTypeAnnotation,typescriptAssign
                              \ transparent contained skipwhite skipempty fold

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/basic/literal.vim
Sourced 1 time
Total time:   0.001831
 Self time:   0.001831

count  total (s)   self (s)
    1              0.000035 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000003 endif

                            "Syntax in the JavaScript code

                            " String
    1              0.000025 syntax match   typescriptASCII                 contained /\\\d\d\d/

    1              0.000076 syntax region  typescriptTemplateSubstitution matchgroup=typescriptTemplateSB
                              \ start=/\${/ end=/}/
                              \ contains=@typescriptValue
                              \ contained


    1              0.000118 syntax region  typescriptString
                              \ start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1+ end=+$+
                              \ contains=typescriptSpecial,@Spell
                              \ extend

    1              0.000022 syntax match   typescriptSpecial            contained "\v\\%(x\x\x|u%(\x{4}|\{\x{1,6}})|c\u|.)"

                            " From vim runtime
                            " <https://github.com/vim/vim/blob/master/runtime/syntax/javascript.vim#L48>
    1              0.000110 syntax region  typescriptRegexpString          start=+/[^/*]+me=e-1 skip=+\\\\\|\\/+ end=+/[gimuy]\{0,5\}\s*$+ end=+/[gimuy]\{0,5\}\s*[;.,)\]}:]+me=e-1 nextgroup=typescriptDotNotation oneline

    1              0.000071 syntax region  typescriptTemplate
                              \ start=/`/  skip=/\\\\\|\\`\|\n/  end=/`\|$/
                              \ contains=typescriptTemplateSubstitution,typescriptSpecial,@Spell
                              \ nextgroup=@typescriptSymbols
                              \ skipwhite skipempty

                            "Array
    1              0.000106 syntax region  typescriptArray matchgroup=typescriptBraces
                              \ start=/\[/ end=/]/
                              \ contains=@typescriptValue,@typescriptComments
                              \ nextgroup=@typescriptSymbols,typescriptDotNotation
                              \ skipwhite skipempty fold

                            " Number
    1              0.000049 syntax match typescriptNumber /\<0[bB][01][01_]*\>/        nextgroup=@typescriptSymbols skipwhite skipempty
    1              0.000017 syntax match typescriptNumber /\<0[oO][0-7][0-7_]*\>/       nextgroup=@typescriptSymbols skipwhite skipempty
    1              0.000016 syntax match typescriptNumber /\<0[xX][0-9a-fA-F][0-9a-fA-F_]*\>/ nextgroup=@typescriptSymbols skipwhite skipempty
    1              0.000070 syntax match typescriptNumber /\<\%(\d[0-9_]*\%(\.\d[0-9_]*\)\=\|\.\d[0-9_]*\)\%([eE][+-]\=\d[0-9_]*\)\=\>/
                              \ nextgroup=typescriptSymbols skipwhite skipempty

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/basic/object.vim
Sourced 1 time
Total time:   0.001484
 Self time:   0.001484

count  total (s)   self (s)
    1              0.000031 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000196 syntax region  typescriptObjectLiteral         matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contains=@typescriptComments,typescriptObjectLabel,typescriptStringProperty,typescriptComputedPropertyName,typescriptObjectAsyncKeyword,typescriptTernary
                              \ fold contained

    1              0.000005 syntax keyword typescriptObjectAsyncKeyword async contained

    1              0.000041 syntax match   typescriptObjectLabel  contained /\k\+\_s*/
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty

    1              0.000049 syntax region  typescriptStringProperty   contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1/
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty

                            " syntax region  typescriptPropertyName    contained start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1(/me=e-1 nextgroup=@typescriptCallSignature skipwhite skipempty oneline
    1              0.000045 syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptBraces
                              \ start=/\[/rs=s+1 end=/]/
                              \ contains=@typescriptValue
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty

                            " syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptPropertyName start=/\[/rs=s+1 end=/]\_s*:/he=e-1 contains=@typescriptValue nextgroup=@typescriptValue skipwhite skipempty
                            " syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptPropertyName start=/\[/rs=s+1 end=/]\_s*(/me=e-1 contains=@typescriptValue nextgroup=@typescriptCallSignature skipwhite skipempty
                            " Value for object, statement for label statement
    1              0.000006 syntax match typescriptRestOrSpread /\.\.\./ contained
    1              0.000029 syntax match typescriptObjectSpread /\.\.\./ contained containedin=typescriptObjectLiteral,typescriptArray nextgroup=@typescriptValue

    1              0.000026 syntax match typescriptObjectColon contained /:/ nextgroup=@typescriptValue skipwhite skipempty

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/basic/symbols.vim
Sourced 1 time
Total time:   0.002650
 Self time:   0.002650

count  total (s)   self (s)
    1              0.000068 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

                            " + - ^ ~
    1              0.000134 syntax match typescriptUnaryOp /[+\-~!]/
                             \ nextgroup=@typescriptValue
                             \ skipwhite

    1              0.000105 syntax region typescriptTernary matchgroup=typescriptTernaryOp start=/?[.?]\@!/ end=/:/ contained contains=@typescriptValue,@typescriptComments nextgroup=@typescriptValue skipwhite skipempty

    1              0.000053 syntax match   typescriptAssign  /=/ nextgroup=@typescriptValue
                              \ skipwhite skipempty

                            " 2: ==, ===
    1              0.000032 syntax match   typescriptBinaryOp contained /===\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 6: >>>=, >>>, >>=, >>, >=, >
    1              0.000038 syntax match   typescriptBinaryOp contained />\(>>=\|>>\|>=\|>\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 4: <<=, <<, <=, <
    1              0.000058 syntax match   typescriptBinaryOp contained /<\(<=\|<\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: ||, |=, |, ||=
    1              0.000059 syntax match   typescriptBinaryOp contained /||\?=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 4: &&, &=, &, &&=
    1              0.000047 syntax match   typescriptBinaryOp contained /&&\?=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: ??, ??=
    1              0.000046 syntax match   typescriptBinaryOp contained /??=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: *=, *
    1              0.000040 syntax match   typescriptBinaryOp contained /\*=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: %=, %
    1              0.000038 syntax match   typescriptBinaryOp contained /%=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: /=, /
    1              0.000039 syntax match   typescriptBinaryOp contained +/\(=\|[^\*/]\@=\)+ nextgroup=@typescriptValue skipwhite skipempty
    1              0.000029 syntax match   typescriptBinaryOp contained /!==\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: !=, !==
    1              0.000028 syntax match   typescriptBinaryOp contained /+\(+\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: +, ++, +=
    1              0.000027 syntax match   typescriptBinaryOp contained /-\(-\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: -, --, -=

                            " exponentiation operator
                            " 2: **, **=
    1              0.000026 syntax match typescriptBinaryOp contained /\*\*=\?/ nextgroup=@typescriptValue

    1              0.000234 syntax cluster typescriptSymbols               contains=typescriptBinaryOp,typescriptKeywordOp,typescriptTernary,typescriptAssign,typescriptCastKeyword

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/basic/keyword.vim
Sourced 1 time
Total time:   0.004176
 Self time:   0.004176

count  total (s)   self (s)
    1              0.000044 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

                            "Import
    1              0.000082 syntax keyword typescriptImport                from as
    1              0.000108 syntax keyword typescriptImport                import
                              \ nextgroup=typescriptImportType
                              \ skipwhite
    1              0.000008 syntax keyword typescriptImportType            type
                              \ contained
    1              0.000084 syntax keyword typescriptExport                export
                              \ nextgroup=typescriptExportType
                              \ skipwhite
    1              0.000028 syntax match typescriptExportType              /\<type\s*{\@=/
                              \ contained skipwhite skipempty skipnl
    1              0.000050 syntax keyword typescriptModule                namespace module

                            "this

                            "JavaScript Prototype
    1              0.000049 syntax keyword typescriptPrototype             prototype
                              \ nextgroup=@afterIdentifier

    1              0.000028 syntax keyword typescriptCastKeyword           as
                              \ nextgroup=@typescriptType
                              \ skipwhite

                            "Program Keywords
    1              0.000023 syntax keyword typescriptIdentifier            arguments this super
                              \ nextgroup=@afterIdentifier

    1              0.000023 syntax keyword typescriptVariable              let var
                              \ nextgroup=@typescriptVariableDeclarations
                              \ skipwhite skipempty

    1              0.000048 syntax keyword typescriptVariable const
                              \ nextgroup=typescriptEnum,@typescriptVariableDeclarations
                              \ skipwhite skipempty

    1              0.000050 syntax region typescriptEnum matchgroup=typescriptEnumKeyword start=/enum / end=/\ze{/
                              \ nextgroup=typescriptBlock
                              \ skipwhite

    1              0.000010 syntax keyword typescriptKeywordOp
                              \ contained in instanceof nextgroup=@typescriptValue
    1              0.000025 syntax keyword typescriptOperator              delete new typeof void
                              \ nextgroup=@typescriptValue
                              \ skipwhite skipempty

    1              0.000038 syntax keyword typescriptForOperator           contained in of
    1              0.000047 syntax keyword typescriptBoolean               true false nextgroup=@typescriptSymbols skipwhite skipempty
    1              0.000024 syntax keyword typescriptNull                  null undefined nextgroup=@typescriptSymbols skipwhite skipempty
    1              0.000049 syntax keyword typescriptMessage               alert confirm prompt status
                              \ nextgroup=typescriptDotNotation,typescriptFuncCallArg
    1              0.000022 syntax keyword typescriptGlobal                self top parent
                              \ nextgroup=@afterIdentifier

                            "Statement Keywords
    1              0.000078 syntax keyword typescriptConditional           if else switch
                              \ nextgroup=typescriptConditionalParen
                              \ skipwhite skipempty skipnl
    1              0.000043 syntax keyword typescriptConditionalElse       else
    1              0.000080 syntax keyword typescriptRepeat                do while for nextgroup=typescriptLoopParen skipwhite skipempty
    1              0.000049 syntax keyword typescriptRepeat                for nextgroup=typescriptLoopParen,typescriptAsyncFor skipwhite skipempty
    1              0.000045 syntax keyword typescriptBranch                break continue containedin=typescriptBlock
    1              0.000052 syntax keyword typescriptCase                  case nextgroup=@typescriptPrimitive skipwhite containedin=typescriptBlock
    1              0.000124 syntax keyword typescriptDefault               default containedin=typescriptBlock nextgroup=@typescriptValue,typescriptClassKeyword,typescriptInterfaceKeyword skipwhite oneline
    1              0.000048 syntax keyword typescriptStatementKeyword      with
    1              0.000013 syntax keyword typescriptStatementKeyword      yield skipwhite nextgroup=@typescriptValue containedin=typescriptBlock
    1              0.000010 syntax keyword typescriptStatementKeyword      return skipwhite contained nextgroup=@typescriptValue containedin=typescriptBlock

    1              0.000041 syntax keyword typescriptTry                   try
    1              0.000029 syntax keyword typescriptExceptions            catch throw finally
    1              0.000041 syntax keyword typescriptDebugger              debugger

    1              0.000007 syntax keyword typescriptAsyncFor              await nextgroup=typescriptLoopParen skipwhite skipempty contained

    1              0.000125 syntax region  typescriptLoopParen             contained matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptVariable,typescriptForOperator,typescriptEndColons,@typescriptValue,@typescriptComments
                              \ nextgroup=typescriptBlock
                              \ skipwhite skipempty
    1              0.000039 syntax region  typescriptConditionalParen             contained matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=@typescriptValue,@typescriptComments
                              \ nextgroup=typescriptBlock
                              \ skipwhite skipempty
    1              0.000050 syntax match   typescriptEndColons             /[;,]/ contained

    1              0.000024 syntax keyword typescriptAmbientDeclaration declare nextgroup=@typescriptAmbients
                              \ skipwhite skipempty

    1              0.000150 syntax cluster typescriptAmbients contains=
                              \ typescriptVariable,
                              \ typescriptFuncKeyword,
                              \ typescriptClassKeyword,
                              \ typescriptAbstract,
                              \ typescriptEnumKeyword,typescriptEnum,
                              \ typescriptModule

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/basic/doc.vim
Sourced 1 time
Total time:   0.003515
 Self time:   0.003515

count  total (s)   self (s)
    1              0.000026 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

                            "Syntax coloring for Node.js shebang line
    1              0.000061 syntax match   shellbang "^#!.*node\>"
    1              0.000007 syntax match   shellbang "^#!.*iojs\>"


                            "JavaScript comments
    1              0.000026 syntax keyword typescriptCommentTodo TODO FIXME XXX TBD
    1              0.000039 syntax match typescriptMagicComment "@ts-\%(ignore\|expect-error\)\>"
    1              0.000055 syntax match   typescriptLineComment "//.*"
                              \ contains=@Spell,typescriptCommentTodo,typescriptRef,typescriptMagicComment
    1              0.000037 syntax region  typescriptComment
                              \ start="/\*"  end="\*/"
                              \ contains=@Spell,typescriptCommentTodo extend
    1              0.000030 syntax cluster typescriptComments
                              \ contains=typescriptDocComment,typescriptComment,typescriptLineComment

    1              0.000012 syntax match   typescriptRef  +///\s*<reference\s\+.*\/>$+
                              \ contains=typescriptString
    1              0.000011 syntax match   typescriptRef  +///\s*<amd-dependency\s\+.*\/>$+
                              \ contains=typescriptString
    1              0.000010 syntax match   typescriptRef  +///\s*<amd-module\s\+.*\/>$+
                              \ contains=typescriptString

                            "JSDoc
    1              0.000002 syntax case ignore

    1              0.000037 syntax region  typescriptDocComment            matchgroup=typescriptComment
                              \ start="/\*\*"  end="\*/"
                              \ contains=typescriptDocNotation,typescriptCommentTodo,@Spell
                              \ fold keepend
    1              0.000027 syntax match   typescriptDocNotation           contained /@/ nextgroup=typescriptDocTags

    1              0.000010 syntax keyword typescriptDocTags               contained constant constructor constructs function ignore inner private public readonly static
    1              0.000010 syntax keyword typescriptDocTags               contained const dict expose inheritDoc interface nosideeffects override protected struct internal
    1              0.000004 syntax keyword typescriptDocTags               contained example global
    1              0.000006 syntax keyword typescriptDocTags               contained alpha beta defaultValue eventProperty experimental label
    1              0.000006 syntax keyword typescriptDocTags               contained packageDocumentation privateRemarks remarks sealed typeParam

                            " syntax keyword typescriptDocTags               contained ngdoc nextgroup=typescriptDocNGDirective
    1              0.000004 syntax keyword typescriptDocTags               contained ngdoc scope priority animations
    1              0.000029 syntax keyword typescriptDocTags               contained ngdoc restrict methodOf propertyOf eventOf eventType nextgroup=typescriptDocParam skipwhite
    1              0.000041 syntax keyword typescriptDocNGDirective        contained overview service object function method property event directive filter inputType error

    1              0.000005 syntax keyword typescriptDocTags               contained abstract virtual access augments

    1              0.000012 syntax keyword typescriptDocTags               contained arguments callback lends memberOf name type kind link mixes mixin tutorial nextgroup=typescriptDocParam skipwhite
    1              0.000025 syntax keyword typescriptDocTags               contained variation nextgroup=typescriptDocNumParam skipwhite

    1              0.000029 syntax keyword typescriptDocTags               contained author class classdesc copyright default defaultvalue nextgroup=typescriptDocDesc skipwhite
    1              0.000008 syntax keyword typescriptDocTags               contained deprecated description external host nextgroup=typescriptDocDesc skipwhite
    1              0.000009 syntax keyword typescriptDocTags               contained file fileOverview overview namespace requires since version nextgroup=typescriptDocDesc skipwhite
    1              0.000007 syntax keyword typescriptDocTags               contained summary todo license preserve nextgroup=typescriptDocDesc skipwhite

    1              0.000025 syntax keyword typescriptDocTags               contained borrows exports nextgroup=typescriptDocA skipwhite
    1              0.000052 syntax keyword typescriptDocTags               contained param arg argument property prop module nextgroup=typescriptDocNamedParamType,typescriptDocParamName skipwhite
    1              0.000029 syntax keyword typescriptDocTags               contained define enum extends implements this typedef nextgroup=typescriptDocParamType skipwhite
    1              0.000009 syntax keyword typescriptDocTags               contained return returns throws exception nextgroup=typescriptDocParamType,typescriptDocParamName skipwhite
    1              0.000028 syntax keyword typescriptDocTags               contained see nextgroup=typescriptDocRef skipwhite

    1              0.001319 syntax keyword typescriptDocTags               contained function func method nextgroup=typescriptDocName skipwhite
    1              0.000021 syntax match   typescriptDocName               contained /\h\w*/

    1              0.000028 syntax keyword typescriptDocTags               contained fires event nextgroup=typescriptDocEventRef skipwhite
    1              0.000009 syntax match   typescriptDocEventRef           contained /\h\w*#\(\h\w*\:\)\?\h\w*/

    1              0.000008 syntax match   typescriptDocNamedParamType     contained /{.\+}/ nextgroup=typescriptDocParamName skipwhite
    1              0.000009 syntax match   typescriptDocParamName          contained /\[\?0-9a-zA-Z_\.]\+\]\?/ nextgroup=typescriptDocDesc skipwhite
    1              0.000006 syntax match   typescriptDocParamType          contained /{.\+}/ nextgroup=typescriptDocDesc skipwhite
    1              0.000030 syntax match   typescriptDocA                  contained /\%(#\|\w\|\.\|:\|\/\)\+/ nextgroup=typescriptDocAs skipwhite
    1              0.000031 syntax match   typescriptDocAs                 contained /\s*as\s*/ nextgroup=typescriptDocB skipwhite
    1              0.000008 syntax match   typescriptDocB                  contained /\%(#\|\w\|\.\|:\|\/\)\+/
    1              0.000010 syntax match   typescriptDocParam              contained /\%(#\|\w\|\.\|:\|\/\|-\)\+/
    1              0.000004 syntax match   typescriptDocNumParam           contained /\d\+/
    1              0.000012 syntax match   typescriptDocRef                contained /\%(#\|\w\|\.\|:\|\/\)\+/
    1              0.000058 syntax region  typescriptDocLinkTag            contained matchgroup=typescriptDocLinkTag start=/{/ end=/}/ contains=typescriptDocTags

    1              0.000010 syntax cluster typescriptDocs                  contains=typescriptDocParamType,typescriptDocNamedParamType,typescriptDocParam

    1              0.000015 if exists("main_syntax") && main_syntax == "typescript"
                              syntax sync clear
                              syntax sync ccomment typescriptComment minlines=200
    1              0.000002 endif

    1              0.000007 syntax case match

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/basic/type.vim
Sourced 1 time
Total time:   0.004127
 Self time:   0.004127

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

                            " Types
    1              0.000036 syntax match typescriptOptionalMark /?/ contained

    1              0.000058 syntax cluster typescriptTypeParameterCluster contains=
                              \ typescriptTypeParameter,
                              \ typescriptGenericDefault

    1              0.000054 syntax region typescriptTypeParameters matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=@typescriptTypeParameterCluster
                              \ contained

    1              0.000040 syntax match typescriptTypeParameter /\K\k*/
                              \ nextgroup=typescriptConstraint
                              \ contained skipwhite skipnl

    1              0.000008 syntax keyword typescriptConstraint extends
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl

    1              0.000007 syntax match typescriptGenericDefault /=/
                              \ nextgroup=@typescriptType
                              \ contained skipwhite

                            "><
                            " class A extend B<T> {} // ClassBlock
                            " func<T>() // FuncCallArg
    1              0.000028 syntax region typescriptTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/\></ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptFuncCallArg,@typescriptTypeOperator
                              \ contained skipwhite


    1              0.000052 syntax cluster typescriptType contains=
                              \ @typescriptPrimaryType,
                              \ typescriptUnion,
                              \ @typescriptFunctionType,
                              \ typescriptConstructorType

                            " array type: A[]
                            " type indexing A['key']
    1              0.000037 syntax region typescriptTypeBracket contained
                              \ start=/\[/ end=/\]/
                              \ contains=typescriptString,typescriptNumber
                              \ nextgroup=@typescriptTypeOperator
                              \ skipwhite skipempty

    1              0.000290 syntax cluster typescriptPrimaryType contains=
                              \ typescriptParenthesizedType,
                              \ typescriptPredefinedType,
                              \ typescriptTypeReference,
                              \ typescriptObjectType,
                              \ typescriptTupleType,
                              \ typescriptTypeQuery,
                              \ typescriptStringLiteralType,
                              \ typescriptTemplateLiteralType,
                              \ typescriptReadonlyArrayKeyword,
                              \ typescriptAssertType

    1              0.000031 syntax region  typescriptStringLiteralType contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1\|$/
                              \ nextgroup=typescriptUnion
                              \ skipwhite skipempty

    1              0.000058 syntax region  typescriptTemplateLiteralType contained
                              \ start=/`/  skip=/\\\\\|\\`\|\n/  end=/`\|$/
                              \ contains=typescriptTemplateSubstitutionType
                              \ nextgroup=typescriptTypeOperator
                              \ skipwhite skipempty

    1              0.000029 syntax region  typescriptTemplateSubstitutionType matchgroup=typescriptTemplateSB
                              \ start=/\${/ end=/}/
                              \ contains=@typescriptType
                              \ contained

    1              0.000025 syntax region typescriptParenthesizedType matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=@typescriptType
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty fold

    1              0.000044 syntax match typescriptTypeReference /\K\k*\(\.\K\k*\)*/
                              \ nextgroup=typescriptTypeArguments,@typescriptTypeOperator,typescriptUserDefinedType
                              \ skipwhite contained skipempty

    1              0.000014 syntax keyword typescriptPredefinedType any number boolean string void never undefined null object unknown
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty

    1              0.000010 syntax match typescriptPredefinedType /unique symbol/
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty

    1              0.000087 syntax region typescriptObjectType matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contains=@typescriptTypeMember,typescriptEndColons,@typescriptComments,typescriptAccessibilityModifier,typescriptReadonlyModifier
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipnl fold

    1              0.000050 syntax cluster typescriptTypeMember contains=
                              \ @typescriptCallSignature,
                              \ typescriptConstructSignature,
                              \ typescriptIndexSignature,
                              \ @typescriptMembers

    1              0.000026 syntax match typescriptTupleLable /\K\k*?\?:/
                                \ contained

    1              0.000030 syntax region typescriptTupleType matchgroup=typescriptBraces
                              \ start=/\[/ end=/\]/
                              \ contains=@typescriptType,@typescriptComments,typescriptRestOrSpread,typescriptTupleLable
                              \ contained skipwhite

    1              0.000030 syntax cluster typescriptTypeOperator
                              \ contains=typescriptUnion,typescriptTypeBracket,typescriptConstraint,typescriptConditionalType

    1              0.000008 syntax match typescriptUnion /|\|&/ contained nextgroup=@typescriptPrimaryType skipwhite skipempty

    1              0.000006 syntax match typescriptConditionalType /?\|:/ contained nextgroup=@typescriptPrimaryType skipwhite skipempty

    1              0.001192 syntax cluster typescriptFunctionType contains=typescriptGenericFunc,typescriptFuncType
    1              0.000075 syntax region typescriptGenericFunc matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptFuncType
                              \ containedin=typescriptFunctionType
                              \ contained skipwhite skipnl

    1              0.000055 syntax region typescriptFuncType matchgroup=typescriptParens
                              \ start=/(/ end=/)\s*=>/me=e-2
                              \ contains=@typescriptParameterList
                              \ nextgroup=typescriptFuncTypeArrow
                              \ contained skipwhite skipnl oneline

    1              0.000038 syntax match typescriptFuncTypeArrow /=>/
                              \ nextgroup=@typescriptType
                              \ containedin=typescriptFuncType
                              \ contained skipwhite skipnl


    1              0.000010 syntax keyword typescriptConstructorType new
                              \ nextgroup=@typescriptFunctionType
                              \ contained skipwhite skipnl

    1              0.000007 syntax keyword typescriptUserDefinedType is
                              \ contained nextgroup=@typescriptType skipwhite skipempty

    1              0.000027 syntax keyword typescriptTypeQuery typeof keyof
                              \ nextgroup=typescriptTypeReference
                              \ contained skipwhite skipnl

    1              0.000026 syntax keyword typescriptAssertType asserts
                              \ nextgroup=typescriptTypeReference
                              \ contained skipwhite skipnl

    1              0.000052 syntax cluster typescriptCallSignature contains=typescriptGenericCall,typescriptCall
    1              0.000052 syntax region typescriptGenericCall matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptCall
                              \ contained skipwhite skipnl
    1              0.000078 syntax region typescriptCall matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptDecorator,@typescriptParameterList,@typescriptComments
                              \ nextgroup=typescriptTypeAnnotation,typescriptBlock
                              \ contained skipwhite skipnl

    1              0.000018 syntax match typescriptTypeAnnotation /:/
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl

    1              0.000126 syntax cluster typescriptParameterList contains=
                              \ typescriptTypeAnnotation,
                              \ typescriptAccessibilityModifier,
                              \ typescriptReadonlyModifier,
                              \ typescriptOptionalMark,
                              \ typescriptRestOrSpread,
                              \ typescriptFuncComma,
                              \ typescriptDefaultParam

    1              0.000013 syntax match typescriptFuncComma /,/ contained

    1              0.000017 syntax match typescriptDefaultParam /=/
                              \ nextgroup=@typescriptValue
                              \ contained skipwhite

    1              0.000007 syntax keyword typescriptConstructSignature new
                              \ nextgroup=@typescriptCallSignature
                              \ contained skipwhite

    1              0.000065 syntax region typescriptIndexSignature matchgroup=typescriptBraces
                              \ start=/\[/ end=/\]/
                              \ contains=typescriptPredefinedType,typescriptMappedIn,typescriptString
                              \ nextgroup=typescriptTypeAnnotation
                              \ contained skipwhite oneline

    1              0.000016 syntax keyword typescriptMappedIn in
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl skipempty

    1              0.000044 syntax keyword typescriptAliasKeyword type
                              \ nextgroup=typescriptAliasDeclaration
                              \ skipwhite skipnl skipempty

    1              0.000017 syntax region typescriptAliasDeclaration matchgroup=typescriptUnion
                              \ start=/ / end=/=/
                              \ nextgroup=@typescriptType
                              \ contains=typescriptConstraint,typescriptTypeParameters
                              \ contained skipwhite skipempty

    1              0.000016 syntax keyword typescriptReadonlyArrayKeyword readonly
                              \ nextgroup=@typescriptPrimaryType
                              \ skipwhite

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats.vim
Sourced 1 time
Total time:   0.111527
 Self time:   0.022739

count  total (s)   self (s)
    1              0.000022 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1   0.002753   0.000517 runtime syntax/yats/typescript.vim
    1   0.002328   0.000500 runtime syntax/yats/es6-number.vim
    1   0.002150   0.000502 runtime syntax/yats/es6-string.vim
    1   0.002259   0.000507 runtime syntax/yats/es6-array.vim
    1   0.002167   0.000513 runtime syntax/yats/es6-object.vim
    1   0.002015   0.000500 runtime syntax/yats/es6-symbol.vim
    1   0.002336   0.000542 runtime syntax/yats/es6-function.vim
    1   0.002382   0.000733 runtime syntax/yats/es6-math.vim
    1   0.002240   0.000496 runtime syntax/yats/es6-date.vim
    1   0.001909   0.000499 runtime syntax/yats/es6-json.vim
    1   0.002081   0.000513 runtime syntax/yats/es6-regexp.vim
    1   0.002058   0.000529 runtime syntax/yats/es6-map.vim
    1   0.001843   0.000503 runtime syntax/yats/es6-set.vim
    1   0.001948   0.000510 runtime syntax/yats/es6-proxy.vim
    1   0.002125   0.000523 runtime syntax/yats/es6-promise.vim
    1   0.001837   0.000520 runtime syntax/yats/es6-reflect.vim
    1   0.001851   0.000497 runtime syntax/yats/ecma-402.vim
    1   0.002047   0.000493 runtime syntax/yats/node.vim
    1   0.001964   0.000500 runtime syntax/yats/test.vim
    1   0.009814   0.000496 runtime syntax/yats/web.vim
    1   0.009068   0.000468 runtime syntax/yats/web-window.vim
    1   0.002164   0.000493 runtime syntax/yats/web-navigator.vim
    1   0.001988   0.000505 runtime syntax/yats/web-location.vim
    1   0.001905   0.000501 runtime syntax/yats/web-history.vim
    1   0.001973   0.000558 runtime syntax/yats/web-console.vim
    1   0.002023   0.000504 runtime syntax/yats/web-xhr.vim
    1   0.002803   0.000501 runtime syntax/yats/web-blob.vim
    1   0.002230   0.000509 runtime syntax/yats/web-crypto.vim
    1   0.002381   0.000514 runtime syntax/yats/web-fetch.vim
    1   0.002019   0.000526 runtime syntax/yats/web-service-worker.vim
    1   0.002555   0.000513 runtime syntax/yats/web-encoding.vim
    1   0.001926   0.000509 runtime syntax/yats/web-geo.vim
    1   0.001991   0.000511 runtime syntax/yats/web-network.vim
    1   0.002490   0.000604 runtime syntax/yats/web-payment.vim
    1   0.002072   0.000503 runtime syntax/yats/dom-node.vim
    1   0.001951   0.000503 runtime syntax/yats/dom-elem.vim
    1   0.002343   0.000507 runtime syntax/yats/dom-document.vim
    1   0.004363   0.000506 runtime syntax/yats/dom-event.vim
    1   0.001975   0.000501 runtime syntax/yats/dom-storage.vim
    1   0.001762   0.000510 runtime syntax/yats/dom-form.vim
    1   0.003585   0.000483 runtime syntax/yats/css.vim


    1              0.000014 let typescript_props = 1

    1   0.004745   0.000509 runtime syntax/yats/event.vim

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/typescript.vim
Sourced 1 time
Total time:   0.002200
 Self time:   0.002200

count  total (s)   self (s)
    1              0.000026 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000053 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Function Boolean
    1              0.000035 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Error EvalError
    1              0.000033 syntax keyword typescriptGlobal containedin=typescriptIdentifierName InternalError
    1              0.000033 syntax keyword typescriptGlobal containedin=typescriptIdentifierName RangeError ReferenceError
    1              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName StopIteration
    1              0.000033 syntax keyword typescriptGlobal containedin=typescriptIdentifierName SyntaxError TypeError
    1              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName URIError Date
    1              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Float32Array
    1              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Float64Array
    1              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Int16Array Int32Array
    1              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Int8Array Uint16Array
    1              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Uint32Array Uint8Array
    1              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Uint8ClampedArray
    1              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName ParallelArray
    1              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName ArrayBuffer DataView
    1              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Iterator Generator
    1              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Reflect Proxy
    1              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName arguments
    1              0.000050 if exists("did_typescript_hilink") | HiLink typescriptGlobal Structure
    1              0.000002 endif
    1              0.000038 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName eval uneval nextgroup=typescriptFuncCallArg
    1              0.000036 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName isFinite nextgroup=typescriptFuncCallArg
    1              0.000036 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName isNaN parseFloat nextgroup=typescriptFuncCallArg
    1              0.000035 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName parseInt nextgroup=typescriptFuncCallArg
    1              0.000036 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName decodeURI nextgroup=typescriptFuncCallArg
    1              0.000035 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName decodeURIComponent nextgroup=typescriptFuncCallArg
    1              0.000035 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName encodeURI nextgroup=typescriptFuncCallArg
    1              0.000035 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName encodeURIComponent nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptGlobalMethod
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptGlobalMethod Structure
    1              0.000008 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-number.vim
Sourced 1 time
Total time:   0.001727
 Self time:   0.001727

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000080 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Number nextgroup=typescriptGlobalNumberDot,typescriptFuncCallArg
    1              0.000091 syntax match   typescriptGlobalNumberDot /\./ contained nextgroup=typescriptNumberStaticProp,typescriptNumberStaticMethod,typescriptProp
    1              0.000015 syntax keyword typescriptNumberStaticProp contained EPSILON MAX_SAFE_INTEGER MAX_VALUE
    1              0.000014 syntax keyword typescriptNumberStaticProp contained MIN_SAFE_INTEGER MIN_VALUE NEGATIVE_INFINITY
    1              0.000013 syntax keyword typescriptNumberStaticProp contained NaN POSITIVE_INFINITY
    1              0.000051 if exists("did_typescript_hilink") | HiLink typescriptNumberStaticProp Keyword
    1              0.000002 endif
    1              0.000019 syntax keyword typescriptNumberStaticMethod contained isFinite isInteger isNaN isSafeInteger nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptNumberStaticMethod contained parseFloat parseInt nextgroup=typescriptFuncCallArg
    1              0.000038 if exists("did_typescript_hilink") | HiLink typescriptNumberStaticMethod Keyword
    1              0.000002 endif
    1              0.000019 syntax keyword typescriptNumberMethod contained toExponential toFixed toLocaleString nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptNumberMethod contained toPrecision toSource toString valueOf nextgroup=typescriptFuncCallArg
    1              0.000025 syntax cluster props add=typescriptNumberMethod
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptNumberMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-string.vim
Sourced 1 time
Total time:   0.001608
 Self time:   0.001608

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000080 syntax keyword typescriptGlobal containedin=typescriptIdentifierName String nextgroup=typescriptGlobalStringDot,typescriptFuncCallArg
    1              0.000062 syntax match   typescriptGlobalStringDot /\./ contained nextgroup=typescriptStringStaticMethod,typescriptProp
    1              0.000019 syntax keyword typescriptStringStaticMethod contained fromCharCode fromCodePoint raw nextgroup=typescriptFuncCallArg
    1              0.000052 if exists("did_typescript_hilink") | HiLink typescriptStringStaticMethod Keyword
    1              0.000002 endif
    1              0.000020 syntax keyword typescriptStringMethod contained anchor charAt charCodeAt codePointAt nextgroup=typescriptFuncCallArg
    1              0.000019 syntax keyword typescriptStringMethod contained concat endsWith includes indexOf lastIndexOf nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptStringMethod contained link localeCompare match normalize nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptStringMethod contained padStart padEnd repeat replace search nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptStringMethod contained slice split startsWith substr substring nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptStringMethod contained toLocaleLowerCase toLocaleUpperCase nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptStringMethod contained toLowerCase toString toUpperCase trim nextgroup=typescriptFuncCallArg
    1              0.000016 syntax keyword typescriptStringMethod contained valueOf nextgroup=typescriptFuncCallArg
    1              0.000025 syntax cluster props add=typescriptStringMethod
    1              0.000038 if exists("did_typescript_hilink") | HiLink typescriptStringMethod Keyword
    1              0.000008 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-array.vim
Sourced 1 time
Total time:   0.001712
 Self time:   0.001712

count  total (s)   self (s)
    1              0.000026 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000089 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Array nextgroup=typescriptGlobalArrayDot,typescriptFuncCallArg
    1              0.000060 syntax match   typescriptGlobalArrayDot /\./ contained nextgroup=typescriptArrayStaticMethod,typescriptProp
    1              0.000019 syntax keyword typescriptArrayStaticMethod contained from isArray of nextgroup=typescriptFuncCallArg
    1              0.000051 if exists("did_typescript_hilink") | HiLink typescriptArrayStaticMethod Keyword
    1              0.000002 endif
    1              0.000020 syntax keyword typescriptArrayMethod contained concat copyWithin entries every fill nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptArrayMethod contained filter find findIndex forEach indexOf nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptArrayMethod contained includes join keys lastIndexOf map nextgroup=typescriptFuncCallArg
    1              0.000045 syntax keyword typescriptArrayMethod contained pop push reduce reduceRight reverse nextgroup=typescriptFuncCallArg
    1              0.000048 syntax keyword typescriptArrayMethod contained shift slice some sort splice toLocaleString nextgroup=typescriptFuncCallArg
    1              0.000022 syntax keyword typescriptArrayMethod contained toSource toString unshift nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptArrayMethod
    1              0.000040 if exists("did_typescript_hilink") | HiLink typescriptArrayMethod Keyword
    1              0.000010 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-object.vim
Sourced 1 time
Total time:   0.001615
 Self time:   0.001615

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000089 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Object nextgroup=typescriptGlobalObjectDot,typescriptFuncCallArg
    1              0.000061 syntax match   typescriptGlobalObjectDot /\./ contained nextgroup=typescriptObjectStaticMethod,typescriptProp
    1              0.000036 syntax keyword typescriptObjectStaticMethod contained create defineProperties defineProperty nextgroup=typescriptFuncCallArg
    1              0.000028 syntax keyword typescriptObjectStaticMethod contained entries freeze getOwnPropertyDescriptors nextgroup=typescriptFuncCallArg
    1              0.000026 syntax keyword typescriptObjectStaticMethod contained getOwnPropertyDescriptor getOwnPropertyNames nextgroup=typescriptFuncCallArg
    1              0.000026 syntax keyword typescriptObjectStaticMethod contained getOwnPropertySymbols getPrototypeOf nextgroup=typescriptFuncCallArg
    1              0.000030 syntax keyword typescriptObjectStaticMethod contained is isExtensible isFrozen isSealed nextgroup=typescriptFuncCallArg
    1              0.000026 syntax keyword typescriptObjectStaticMethod contained keys preventExtensions values nextgroup=typescriptFuncCallArg
    1              0.000052 if exists("did_typescript_hilink") | HiLink typescriptObjectStaticMethod Keyword
    1              0.000002 endif
    1              0.000023 syntax keyword typescriptObjectMethod contained getOwnPropertyDescriptors hasOwnProperty nextgroup=typescriptFuncCallArg
    1              0.000026 syntax keyword typescriptObjectMethod contained isPrototypeOf propertyIsEnumerable nextgroup=typescriptFuncCallArg
    1              0.000023 syntax keyword typescriptObjectMethod contained toLocaleString toString valueOf seal nextgroup=typescriptFuncCallArg
    1              0.000021 syntax keyword typescriptObjectMethod contained setPrototypeOf nextgroup=typescriptFuncCallArg
    1              0.000025 syntax cluster props add=typescriptObjectMethod
    1              0.000038 if exists("did_typescript_hilink") | HiLink typescriptObjectMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-symbol.vim
Sourced 1 time
Total time:   0.001425
 Self time:   0.001425

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000087 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Symbol nextgroup=typescriptGlobalSymbolDot,typescriptFuncCallArg
    1              0.000087 syntax match   typescriptGlobalSymbolDot /\./ contained nextgroup=typescriptSymbolStaticProp,typescriptSymbolStaticMethod,typescriptProp
    1              0.000026 syntax keyword typescriptSymbolStaticProp contained length iterator match replace
    1              0.000018 syntax keyword typescriptSymbolStaticProp contained search split hasInstance isConcatSpreadable
    1              0.000013 syntax keyword typescriptSymbolStaticProp contained unscopables species toPrimitive
    1              0.000011 syntax keyword typescriptSymbolStaticProp contained toStringTag
    1              0.000051 if exists("did_typescript_hilink") | HiLink typescriptSymbolStaticProp Keyword
    1              0.000002 endif
    1              0.000018 syntax keyword typescriptSymbolStaticMethod contained for keyFor nextgroup=typescriptFuncCallArg
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptSymbolStaticMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-function.vim
Sourced 1 time
Total time:   0.001753
 Self time:   0.001753

count  total (s)   self (s)
    1              0.000038 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000003 endif

    1              0.000101 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Function
    1              0.000032 syntax keyword typescriptFunctionMethod contained apply bind call nextgroup=typescriptFuncCallArg
    1              0.000043 syntax cluster props add=typescriptFunctionMethod
    1              0.000084 if exists("did_typescript_hilink") | HiLink typescriptFunctionMethod Keyword
    1              0.000011 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-math.vim
Sourced 1 time
Total time:   0.001611
 Self time:   0.001611

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000077 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Math nextgroup=typescriptGlobalMathDot,typescriptFuncCallArg
    1              0.000076 syntax match   typescriptGlobalMathDot /\./ contained nextgroup=typescriptMathStaticProp,typescriptMathStaticMethod,typescriptProp
    1              0.000016 syntax keyword typescriptMathStaticProp contained E LN10 LN2 LOG10E LOG2E PI SQRT1_2
    1              0.000012 syntax keyword typescriptMathStaticProp contained SQRT2
    1              0.000048 if exists("did_typescript_hilink") | HiLink typescriptMathStaticProp Keyword
    1              0.000002 endif
    1              0.000019 syntax keyword typescriptMathStaticMethod contained abs acos acosh asin asinh atan nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptMathStaticMethod contained atan2 atanh cbrt ceil clz32 cos nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptMathStaticMethod contained cosh exp expm1 floor fround hypot nextgroup=typescriptFuncCallArg
    1              0.000025 syntax keyword typescriptMathStaticMethod contained imul log log10 log1p log2 max nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptMathStaticMethod contained min pow random round sign sin nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptMathStaticMethod contained sinh sqrt tan tanh trunc nextgroup=typescriptFuncCallArg
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptMathStaticMethod Keyword
    1              0.000010 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-date.vim
Sourced 1 time
Total time:   0.001706
 Self time:   0.001706

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000079 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Date nextgroup=typescriptGlobalDateDot,typescriptFuncCallArg
    1              0.000062 syntax match   typescriptGlobalDateDot /\./ contained nextgroup=typescriptDateStaticMethod,typescriptProp
    1              0.000018 syntax keyword typescriptDateStaticMethod contained UTC now parse nextgroup=typescriptFuncCallArg
    1              0.000051 if exists("did_typescript_hilink") | HiLink typescriptDateStaticMethod Keyword
    1              0.000002 endif
    1              0.000019 syntax keyword typescriptDateMethod contained getDate getDay getFullYear getHours nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDateMethod contained getMilliseconds getMinutes getMonth nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDateMethod contained getSeconds getTime getTimezoneOffset nextgroup=typescriptFuncCallArg
    1              0.000016 syntax keyword typescriptDateMethod contained getUTCDate getUTCDay getUTCFullYear nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDateMethod contained getUTCHours getUTCMilliseconds getUTCMinutes nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDateMethod contained getUTCMonth getUTCSeconds setDate setFullYear nextgroup=typescriptFuncCallArg
    1              0.000025 syntax keyword typescriptDateMethod contained setHours setMilliseconds setMinutes nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDateMethod contained setMonth setSeconds setTime setUTCDate nextgroup=typescriptFuncCallArg
    1              0.000016 syntax keyword typescriptDateMethod contained setUTCFullYear setUTCHours setUTCMilliseconds nextgroup=typescriptFuncCallArg
    1              0.000016 syntax keyword typescriptDateMethod contained setUTCMinutes setUTCMonth setUTCSeconds nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDateMethod contained toDateString toISOString toJSON toLocaleDateString nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDateMethod contained toLocaleFormat toLocaleString toLocaleTimeString nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDateMethod contained toSource toString toTimeString toUTCString nextgroup=typescriptFuncCallArg
    1              0.000015 syntax keyword typescriptDateMethod contained valueOf nextgroup=typescriptFuncCallArg
    1              0.000025 syntax cluster props add=typescriptDateMethod
    1              0.000038 if exists("did_typescript_hilink") | HiLink typescriptDateMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-json.vim
Sourced 1 time
Total time:   0.001318
 Self time:   0.001318

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000077 syntax keyword typescriptGlobal containedin=typescriptIdentifierName JSON nextgroup=typescriptGlobalJSONDot,typescriptFuncCallArg
    1              0.000059 syntax match   typescriptGlobalJSONDot /\./ contained nextgroup=typescriptJSONStaticMethod,typescriptProp
    1              0.000018 syntax keyword typescriptJSONStaticMethod contained parse stringify nextgroup=typescriptFuncCallArg
    1              0.000050 if exists("did_typescript_hilink") | HiLink typescriptJSONStaticMethod Keyword
    1              0.000008 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-regexp.vim
Sourced 1 time
Total time:   0.001529
 Self time:   0.001529

count  total (s)   self (s)
    1              0.000027 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000082 syntax keyword typescriptGlobal containedin=typescriptIdentifierName RegExp nextgroup=typescriptGlobalRegExpDot,typescriptFuncCallArg
    1              0.000061 syntax match   typescriptGlobalRegExpDot /\./ contained nextgroup=typescriptRegExpStaticProp,typescriptProp
    1              0.000013 syntax keyword typescriptRegExpStaticProp contained lastIndex
    1              0.000054 if exists("did_typescript_hilink") | HiLink typescriptRegExpStaticProp Keyword
    1              0.000002 endif
    1              0.000015 syntax keyword typescriptRegExpProp contained global ignoreCase multiline source sticky
    1              0.000025 syntax cluster props add=typescriptRegExpProp
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptRegExpProp Keyword
    1              0.000001 endif
    1              0.000018 syntax keyword typescriptRegExpMethod contained exec test nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptRegExpMethod
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptRegExpMethod Keyword
    1              0.000010 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-map.vim
Sourced 1 time
Total time:   0.001488
 Self time:   0.001488

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000055 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Map WeakMap
    1              0.000013 syntax keyword typescriptES6MapProp contained size
    1              0.000026 syntax cluster props add=typescriptES6MapProp
    1              0.000051 if exists("did_typescript_hilink") | HiLink typescriptES6MapProp Keyword
    1              0.000002 endif
    1              0.000022 syntax keyword typescriptES6MapMethod contained clear delete entries forEach get has nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptES6MapMethod contained keys set values nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptES6MapMethod
    1              0.000038 if exists("did_typescript_hilink") | HiLink typescriptES6MapMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-set.vim
Sourced 1 time
Total time:   0.001302
 Self time:   0.001302

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000055 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Set WeakSet
    1              0.000013 syntax keyword typescriptES6SetProp contained size
    1              0.000026 syntax cluster props add=typescriptES6SetProp
    1              0.000049 if exists("did_typescript_hilink") | HiLink typescriptES6SetProp Keyword
    1              0.000002 endif
    1              0.000022 syntax keyword typescriptES6SetMethod contained add clear delete entries forEach has nextgroup=typescriptFuncCallArg
    1              0.000016 syntax keyword typescriptES6SetMethod contained values nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptES6SetMethod
    1              0.000038 if exists("did_typescript_hilink") | HiLink typescriptES6SetMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-proxy.vim
Sourced 1 time
Total time:   0.001338
 Self time:   0.001338

count  total (s)   self (s)
    1              0.000026 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000060 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Proxy
    1              0.000044 syntax keyword typescriptProxyAPI contained getOwnPropertyDescriptor getOwnPropertyNames
    1              0.000006 syntax keyword typescriptProxyAPI contained defineProperty deleteProperty freeze seal
    1              0.000006 syntax keyword typescriptProxyAPI contained preventExtensions has hasOwn get set enumerate
    1              0.000005 syntax keyword typescriptProxyAPI contained iterate ownKeys apply construct
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptProxyAPI Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-promise.vim
Sourced 1 time
Total time:   0.001556
 Self time:   0.001556

count  total (s)   self (s)
    1              0.000025 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000079 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Promise nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg
    1              0.000059 syntax match   typescriptGlobalPromiseDot /\./ contained nextgroup=typescriptPromiseStaticMethod,typescriptProp
    1              0.000019 syntax keyword typescriptPromiseStaticMethod contained resolve reject all race nextgroup=typescriptFuncCallArg
    1              0.000052 if exists("did_typescript_hilink") | HiLink typescriptPromiseStaticMethod Keyword
    1              0.000002 endif
    1              0.000018 syntax keyword typescriptPromiseMethod contained then catch finally nextgroup=typescriptFuncCallArg
    1              0.000025 syntax cluster props add=typescriptPromiseMethod
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptPromiseMethod Keyword
    1              0.000010 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/es6-reflect.vim
Sourced 1 time
Total time:   0.001276
 Self time:   0.001276

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000052 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Reflect
    1              0.000021 syntax keyword typescriptReflectMethod contained apply construct defineProperty deleteProperty nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptReflectMethod contained enumerate get getOwnPropertyDescriptor nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptReflectMethod contained getPrototypeOf has isExtensible ownKeys nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptReflectMethod contained preventExtensions set setPrototypeOf nextgroup=typescriptFuncCallArg
    1              0.000026 syntax cluster props add=typescriptReflectMethod
    1              0.000048 if exists("did_typescript_hilink") | HiLink typescriptReflectMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/ecma-402.vim
Sourced 1 time
Total time:   0.001315
 Self time:   0.001315

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000052 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Intl
    1              0.000019 syntax keyword typescriptIntlMethod contained Collator DateTimeFormat NumberFormat nextgroup=typescriptFuncCallArg
    1              0.000016 syntax keyword typescriptIntlMethod contained PluralRules nextgroup=typescriptFuncCallArg
    1              0.000025 syntax cluster props add=typescriptIntlMethod
    1              0.000048 if exists("did_typescript_hilink") | HiLink typescriptIntlMethod Keyword
    1              0.000008 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/node.vim
Sourced 1 time
Total time:   0.001463
 Self time:   0.001463

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000056 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName global process
    1              0.000036 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName console Buffer
    1              0.000036 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName module exports
    1              0.000034 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName setTimeout
    1              0.000034 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName clearTimeout
    1              0.000034 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName setInterval
    1              0.000034 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName clearInterval
    1              0.000052 if exists("did_typescript_hilink") | HiLink typescriptNodeGlobal Structure
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/test.vim
Sourced 1 time
Total time:   0.001425
 Self time:   0.001425

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000074 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName describe
    1              0.000027 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName it test before
    1              0.000026 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName after beforeEach
    1              0.000025 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName afterEach
    1              0.000024 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName beforeAll
    1              0.000025 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName afterAll
    1              0.000033 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName expect assert

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web.vim
Sourced 1 time
Total time:   0.009276
 Self time:   0.009276

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000078 syntax keyword typescriptBOM containedin=typescriptIdentifierName AbortController
    1              0.000027 syntax keyword typescriptBOM containedin=typescriptIdentifierName AbstractWorker AnalyserNode
    1              0.000027 syntax keyword typescriptBOM containedin=typescriptIdentifierName App Apps ArrayBuffer
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName ArrayBufferView
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName Attr AudioBuffer
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioBufferSourceNode
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioContext AudioDestinationNode
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioListener AudioNode
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioParam BatteryManager
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName BiquadFilterNode
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName BlobEvent BluetoothAdapter
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName BluetoothDevice
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName BluetoothManager
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName CameraCapabilities
    1              0.000026 syntax keyword typescriptBOM containedin=typescriptIdentifierName CameraControl CameraManager
    1              0.000026 syntax keyword typescriptBOM containedin=typescriptIdentifierName CanvasGradient CanvasImageSource
    1              0.000026 syntax keyword typescriptBOM containedin=typescriptIdentifierName CanvasPattern CanvasRenderingContext2D
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName CaretPosition CDATASection
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName ChannelMergerNode
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName ChannelSplitterNode
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName CharacterData ChildNode
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName ChromeWorker Comment
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName Connection Console
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName ContactManager Contacts
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName ConvolverNode Coordinates
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSS CSSConditionRule
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSGroupingRule
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSKeyframeRule
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSKeyframesRule
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSMediaRule CSSNamespaceRule
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSPageRule CSSRule
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSRuleList CSSStyleDeclaration
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSStyleRule CSSStyleSheet
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSSupportsRule
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName DataTransfer DataView
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName DedicatedWorkerGlobalScope
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName DelayNode DeviceAcceleration
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName DeviceRotationRate
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName DeviceStorage DirectoryEntry
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryEntrySync
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryReader
    1              0.000035 syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryReaderSync
    1              0.000026 syntax keyword typescriptBOM containedin=typescriptIdentifierName Document DocumentFragment
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName DocumentTouch DocumentType
    1              0.001157 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMCursor DOMError
    1              0.000028 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMException DOMHighResTimeStamp
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMImplementation
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMImplementationRegistry
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMParser DOMRequest
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMString DOMStringList
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMStringMap DOMTimeStamp
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMTokenList DynamicsCompressorNode
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName Element Entry EntrySync
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName Extensions FileException
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName Float32Array Float64Array
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName FMRadio FormData
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName GainNode Gamepad
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName GamepadButton Geolocation
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName History HTMLAnchorElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLAreaElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLAudioElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBaseElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBodyElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBRElement HTMLButtonElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLCanvasElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLCollection HTMLDataElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDataListElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDivElement HTMLDListElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDocument HTMLElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLEmbedElement
    1              0.000033 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFieldSetElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFormControlsCollection
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFormElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHeadElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHeadingElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHRElement HTMLHtmlElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLIFrameElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLImageElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLInputElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLKeygenElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLabelElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLegendElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLIElement HTMLLinkElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMapElement HTMLMediaElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMetaElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMeterElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLModElement HTMLObjectElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOListElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptGroupElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptionElement
    1              0.000092 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptionsCollection
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOutputElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLParagraphElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLParamElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLPreElement HTMLProgressElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLQuoteElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLScriptElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSelectElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSourceElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSpanElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLStyleElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableCaptionElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableCellElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableColElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableDataCellElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableHeaderCellElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableRowElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableSectionElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTextAreaElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTimeElement
    1              0.000027 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTitleElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTrackElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLUListElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLUnknownElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLVideoElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBCursor IDBCursorSync
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBCursorWithValue
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBDatabase IDBDatabaseSync
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBEnvironment IDBEnvironmentSync
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBFactory IDBFactorySync
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBIndex IDBIndexSync
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBKeyRange IDBObjectStore
    1              0.000036 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBObjectStoreSync
    1              0.000040 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBOpenDBRequest
    1              0.000026 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBRequest IDBTransaction
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBTransactionSync
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBVersionChangeEvent
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName ImageData IndexedDB
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName Int16Array Int32Array
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName Int8Array L10n LinkStyle
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName LocalFileSystem
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName LocalFileSystemSync
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName Location LockedFile
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaQueryList MediaQueryListListener
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaRecorder MediaSource
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaStream MediaStreamTrack
    1              0.000056 syntax keyword typescriptBOM containedin=typescriptIdentifierName MutationObserver
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName Navigator NavigatorGeolocation
    1              0.000028 syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorID NavigatorLanguage
    1              0.000045 syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorOnLine
    1              0.000031 syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorPlugins
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName Node NodeFilter
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName NodeIterator NodeList
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName Notification OfflineAudioContext
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName OscillatorNode PannerNode
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName ParentNode Performance
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName PerformanceNavigation
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName PerformanceTiming
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName Permissions PermissionSettings
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName Plugin PluginArray
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName Position PositionError
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName PositionOptions
    1              0.000028 syntax keyword typescriptBOM containedin=typescriptIdentifierName PowerManager ProcessingInstruction
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName PromiseResolver
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName PushManager Range
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCConfiguration
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCPeerConnection
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCPeerConnectionErrorCallback
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCSessionDescription
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCSessionDescriptionCallback
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName ScriptProcessorNode
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName Selection SettingsLock
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SettingsManager
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName SharedWorker StyleSheet
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName StyleSheetList SVGAElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAngle SVGAnimateColorElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedAngle
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedBoolean
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedEnumeration
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedInteger
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedLength
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedLengthList
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedNumber
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedNumberList
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedPoints
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedPreserveAspectRatio
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedRect
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedString
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedTransformList
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateMotionElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateTransformElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimationElement
    1              0.000031 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGCircleElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGClipPathElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGCursorElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGDefsElement SVGDescElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGElement SVGEllipseElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFilterElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontElement SVGFontFaceElement
    1              0.000026 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceFormatElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceNameElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceSrcElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceUriElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGForeignObjectElement
    1              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGGElement SVGGlyphElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGGradientElement
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGHKernElement
    1              0.000026 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGImageElement
    1              0.000031 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLength SVGLengthList
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLinearGradientElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLineElement SVGMaskElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGMatrix SVGMissingGlyphElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGMPathElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGNumber SVGNumberList
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPathElement SVGPatternElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPoint SVGPolygonElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPolylineElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPreserveAspectRatio
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGRadialGradientElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGRect SVGRectElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGScriptElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSetElement SVGStopElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGStringList SVGStylable
    1              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGStyleElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSVGElement SVGSwitchElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSymbolElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTests SVGTextElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTextPositioningElement
    1              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTitleElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTransform SVGTransformable
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTransformList
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTRefElement SVGTSpanElement
    1              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGUseElement SVGViewElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGVKernElement
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName TCPServerSocket
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName TCPSocket Telephony
    1              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName TelephonyCall Text
    1              0.000051 syntax keyword typescriptBOM containedin=typescriptIdentifierName TextDecoder TextEncoder
    1              0.000140 syntax keyword typescriptBOM containedin=typescriptIdentifierName TextMetrics TimeRanges
    1              0.000074 syntax keyword typescriptBOM containedin=typescriptIdentifierName Touch TouchList
    1              0.000066 syntax keyword typescriptBOM containedin=typescriptIdentifierName Transferable TreeWalker
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName Uint16Array Uint32Array
    1              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName Uint8Array Uint8ClampedArray
    1              0.000043 syntax keyword typescriptBOM containedin=typescriptIdentifierName URLSearchParams
    1              0.000044 syntax keyword typescriptBOM containedin=typescriptIdentifierName URLUtilsReadOnly
    1              0.000044 syntax keyword typescriptBOM containedin=typescriptIdentifierName UserProximityEvent
    1              0.000065 syntax keyword typescriptBOM containedin=typescriptIdentifierName ValidityState VideoPlaybackQuality
    1              0.000064 syntax keyword typescriptBOM containedin=typescriptIdentifierName WaveShaperNode WebBluetooth
    1              0.000044 syntax keyword typescriptBOM containedin=typescriptIdentifierName WebGLRenderingContext
    1              0.000064 syntax keyword typescriptBOM containedin=typescriptIdentifierName WebSMS WebSocket
    1              0.000064 syntax keyword typescriptBOM containedin=typescriptIdentifierName WebVTT WifiManager
    1              0.000086 syntax keyword typescriptBOM containedin=typescriptIdentifierName Window Worker WorkerConsole
    1              0.000064 syntax keyword typescriptBOM containedin=typescriptIdentifierName WorkerLocation WorkerNavigator
    1              0.000064 syntax keyword typescriptBOM containedin=typescriptIdentifierName XDomainRequest XMLDocument
    1              0.000043 syntax keyword typescriptBOM containedin=typescriptIdentifierName XMLHttpRequestEventTarget
    1              0.000045 if exists("did_typescript_hilink") | HiLink typescriptBOM Structure
    1              0.000006 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-window.vim
Sourced 1 time
Total time:   0.008511
 Self time:   0.008511

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000088 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName applicationCache
    1              0.000063 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName closed
    1              0.000061 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName Components
    1              0.000060 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName controllers
    1              0.000059 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName dialogArguments
    1              0.000059 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName document
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName frameElement
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName frames
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName fullScreen
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName history
    1              0.000057 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName innerHeight
    1              0.000057 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName innerWidth
    1              0.000034 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName length
    1              0.000057 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName location
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName locationbar
    1              0.000057 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName menubar
    1              0.000066 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName messageManager
    1              0.000081 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName name navigator
    1              0.000057 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName opener
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName outerHeight
    1              0.000057 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName outerWidth
    1              0.000057 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName pageXOffset
    1              0.000057 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName pageYOffset
    1              0.000034 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName parent
    1              0.000057 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName performance
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName personalbar
    1              0.000057 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName returnValue
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screen
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screenX
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screenY
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollbars
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollMaxX
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollMaxY
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollX
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollY
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName self sidebar
    1              0.000034 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName status
    1              0.000057 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName statusbar
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName toolbar
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName top visualViewport
    1              0.000058 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName window
    1              0.000027 syntax cluster props add=typescriptBOMWindowProp
    1              0.000051 if exists("did_typescript_hilink") | HiLink typescriptBOMWindowProp Structure
    1              0.000002 endif
    1              0.000038 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName alert nextgroup=typescriptFuncCallArg
    1              0.000062 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName atob nextgroup=typescriptFuncCallArg
    1              0.001275 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName blur nextgroup=typescriptFuncCallArg
    1              0.000100 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName btoa nextgroup=typescriptFuncCallArg
    1              0.000068 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearImmediate nextgroup=typescriptFuncCallArg
    1              0.000038 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearInterval nextgroup=typescriptFuncCallArg
    1              0.000036 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearTimeout nextgroup=typescriptFuncCallArg
    1              0.000061 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName close nextgroup=typescriptFuncCallArg
    1              0.000036 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName confirm nextgroup=typescriptFuncCallArg
    1              0.000061 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName dispatchEvent nextgroup=typescriptFuncCallArg
    1              0.000037 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName find nextgroup=typescriptFuncCallArg
    1              0.000060 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName focus nextgroup=typescriptFuncCallArg
    1              0.000061 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getAttention nextgroup=typescriptFuncCallArg
    1              0.000061 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getAttentionWithCycleCount nextgroup=typescriptFuncCallArg
    1              0.000061 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getComputedStyle nextgroup=typescriptFuncCallArg
    1              0.000089 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getDefaulComputedStyle nextgroup=typescriptFuncCallArg
    1              0.000070 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getSelection nextgroup=typescriptFuncCallArg
    1              0.000060 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName matchMedia nextgroup=typescriptFuncCallArg
    1              0.000060 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName maximize nextgroup=typescriptFuncCallArg
    1              0.000070 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName moveBy nextgroup=typescriptFuncCallArg
    1              0.000060 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName moveTo nextgroup=typescriptFuncCallArg
    1              0.000060 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName open nextgroup=typescriptFuncCallArg
    1              0.000060 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName openDialog nextgroup=typescriptFuncCallArg
    1              0.000060 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName postMessage nextgroup=typescriptFuncCallArg
    1              0.000060 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName print nextgroup=typescriptFuncCallArg
    1              0.000037 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName prompt nextgroup=typescriptFuncCallArg
    1              0.000059 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName removeEventListener nextgroup=typescriptFuncCallArg
    1              0.000060 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName resizeBy nextgroup=typescriptFuncCallArg
    1              0.000060 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName resizeTo nextgroup=typescriptFuncCallArg
    1              0.000060 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName restore nextgroup=typescriptFuncCallArg
    1              0.000060 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scroll nextgroup=typescriptFuncCallArg
    1              0.000067 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollBy nextgroup=typescriptFuncCallArg
    1              0.000071 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollByLines nextgroup=typescriptFuncCallArg
    1              0.000056 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollByPages nextgroup=typescriptFuncCallArg
    1              0.000056 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollTo nextgroup=typescriptFuncCallArg
    1              0.000070 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setCursor nextgroup=typescriptFuncCallArg
    1              0.000056 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setImmediate nextgroup=typescriptFuncCallArg
    1              0.000034 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setInterval nextgroup=typescriptFuncCallArg
    1              0.000055 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setResizable nextgroup=typescriptFuncCallArg
    1              0.000034 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setTimeout nextgroup=typescriptFuncCallArg
    1              0.000055 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName showModalDialog nextgroup=typescriptFuncCallArg
    1              0.000056 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName sizeToContent nextgroup=typescriptFuncCallArg
    1              0.000056 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName stop nextgroup=typescriptFuncCallArg
    1              0.000056 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName updateCommands nextgroup=typescriptFuncCallArg
    1              0.000026 syntax cluster props add=typescriptBOMWindowMethod
    1              0.000062 if exists("did_typescript_hilink") | HiLink typescriptBOMWindowMethod Structure
    1              0.000002 endif
    1              0.000113 syntax keyword typescriptBOMWindowEvent contained onabort onbeforeunload onblur onchange
    1              0.000090 syntax keyword typescriptBOMWindowEvent contained onclick onclose oncontextmenu ondevicelight
    1              0.000047 syntax keyword typescriptBOMWindowEvent contained ondevicemotion ondeviceorientation
    1              0.000068 syntax keyword typescriptBOMWindowEvent contained ondeviceproximity ondragdrop onerror
    1              0.000090 syntax keyword typescriptBOMWindowEvent contained onfocus onhashchange onkeydown onkeypress
    1              0.000090 syntax keyword typescriptBOMWindowEvent contained onkeyup onload onmousedown onmousemove
    1              0.000068 syntax keyword typescriptBOMWindowEvent contained onmouseout onmouseover onmouseup
    1              0.000073 syntax keyword typescriptBOMWindowEvent contained onmozbeforepaint onpaint onpopstate
    1              0.000091 syntax keyword typescriptBOMWindowEvent contained onreset onresize onscroll onselect
    1              0.000069 syntax keyword typescriptBOMWindowEvent contained onsubmit onunload onuserproximity
    1              0.000047 syntax keyword typescriptBOMWindowEvent contained onpageshow onpagehide
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptBOMWindowEvent Keyword
    1              0.000001 endif
    1              0.000041 syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName DOMParser
    1              0.000022 syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName QueryInterface
    1              0.000022 syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName XMLSerializer
    1              0.000026 if exists("did_typescript_hilink") | HiLink typescriptBOMWindowCons Structure
    1              0.000004 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-navigator.vim
Sourced 1 time
Total time:   0.001631
 Self time:   0.001631

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000031 syntax keyword typescriptBOMNavigatorProp contained battery buildID connection cookieEnabled
    1              0.000014 syntax keyword typescriptBOMNavigatorProp contained doNotTrack maxTouchPoints oscpu
    1              0.000013 syntax keyword typescriptBOMNavigatorProp contained productSub push serviceWorker
    1              0.000012 syntax keyword typescriptBOMNavigatorProp contained vendor vendorSub
    1              0.000026 syntax cluster props add=typescriptBOMNavigatorProp
    1              0.000048 if exists("did_typescript_hilink") | HiLink typescriptBOMNavigatorProp Keyword
    1              0.000002 endif
    1              0.000018 syntax keyword typescriptBOMNavigatorMethod contained addIdleObserver geolocation nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptBOMNavigatorMethod contained getDeviceStorage getDeviceStorages nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptBOMNavigatorMethod contained getGamepads getUserMedia registerContentHandler nextgroup=typescriptFuncCallArg
    1              0.000016 syntax keyword typescriptBOMNavigatorMethod contained removeIdleObserver requestWakeLock nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptBOMNavigatorMethod contained share vibrate watch registerProtocolHandler nextgroup=typescriptFuncCallArg
    1              0.000015 syntax keyword typescriptBOMNavigatorMethod contained sendBeacon nextgroup=typescriptFuncCallArg
    1              0.000023 syntax cluster props add=typescriptBOMNavigatorMethod
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptBOMNavigatorMethod Keyword
    1              0.000001 endif
    1              0.000017 syntax keyword typescriptServiceWorkerMethod contained register nextgroup=typescriptFuncCallArg
    1              0.000023 syntax cluster props add=typescriptServiceWorkerMethod
    1              0.000035 if exists("did_typescript_hilink") | HiLink typescriptServiceWorkerMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-location.vim
Sourced 1 time
Total time:   0.001442
 Self time:   0.001442

count  total (s)   self (s)
    1              0.000022 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000033 syntax keyword typescriptBOMLocationProp contained href protocol host hostname port
    1              0.000024 syntax keyword typescriptBOMLocationProp contained pathname search hash username password
    1              0.000013 syntax keyword typescriptBOMLocationProp contained origin
    1              0.000027 syntax cluster props add=typescriptBOMLocationProp
    1              0.000052 if exists("did_typescript_hilink") | HiLink typescriptBOMLocationProp Keyword
    1              0.000002 endif
    1              0.000019 syntax keyword typescriptBOMLocationMethod contained assign reload replace toString nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptBOMLocationMethod
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptBOMLocationMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-history.vim
Sourced 1 time
Total time:   0.001364
 Self time:   0.001364

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000034 syntax keyword typescriptBOMHistoryProp contained length current next previous state
    1              0.000013 syntax keyword typescriptBOMHistoryProp contained scrollRestoration
    1              0.000027 syntax cluster props add=typescriptBOMHistoryProp
    1              0.000052 if exists("did_typescript_hilink") | HiLink typescriptBOMHistoryProp Keyword
    1              0.000002 endif
    1              0.000020 syntax keyword typescriptBOMHistoryMethod contained back forward go pushState replaceState nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptBOMHistoryMethod
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptBOMHistoryMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-console.vim
Sourced 1 time
Total time:   0.001375
 Self time:   0.001375

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000056 syntax keyword typescriptGlobal containedin=typescriptIdentifierName console
    1              0.000021 syntax keyword typescriptConsoleMethod contained count dir error group groupCollapsed nextgroup=typescriptFuncCallArg
    1              0.000019 syntax keyword typescriptConsoleMethod contained groupEnd info log time timeEnd trace nextgroup=typescriptFuncCallArg
    1              0.000016 syntax keyword typescriptConsoleMethod contained warn nextgroup=typescriptFuncCallArg
    1              0.000026 syntax cluster props add=typescriptConsoleMethod
    1              0.000051 if exists("did_typescript_hilink") | HiLink typescriptConsoleMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-xhr.vim
Sourced 1 time
Total time:   0.001478
 Self time:   0.001478

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000070 syntax keyword typescriptXHRGlobal containedin=typescriptIdentifierName XMLHttpRequest
    1              0.000035 if exists("did_typescript_hilink") | HiLink typescriptXHRGlobal Structure
    1              0.000002 endif
    1              0.000014 syntax keyword typescriptXHRProp contained onreadystatechange readyState response
    1              0.000023 syntax keyword typescriptXHRProp contained responseText responseType responseXML status
    1              0.000014 syntax keyword typescriptXHRProp contained statusText timeout ontimeout upload withCredentials
    1              0.000025 syntax cluster props add=typescriptXHRProp
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptXHRProp Keyword
    1              0.000001 endif
    1              0.000018 syntax keyword typescriptXHRMethod contained abort getAllResponseHeaders getResponseHeader nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptXHRMethod contained open overrideMimeType send setRequestHeader nextgroup=typescriptFuncCallArg
    1              0.000023 syntax cluster props add=typescriptXHRMethod
    1              0.000035 if exists("did_typescript_hilink") | HiLink typescriptXHRMethod Keyword
    1              0.000008 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-blob.vim
Sourced 1 time
Total time:   0.002262
 Self time:   0.002262

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000056 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Blob BlobBuilder
    1              0.000037 syntax keyword typescriptGlobal containedin=typescriptIdentifierName File FileReader
    1              0.000035 syntax keyword typescriptGlobal containedin=typescriptIdentifierName FileReaderSync
    1              0.000059 syntax keyword typescriptGlobal containedin=typescriptIdentifierName URL nextgroup=typescriptGlobalURLDot,typescriptFuncCallArg
    1              0.000062 syntax match   typescriptGlobalURLDot /\./ contained nextgroup=typescriptURLStaticMethod,typescriptProp
    1              0.000034 syntax keyword typescriptGlobal containedin=typescriptIdentifierName URLUtils
    1              0.000018 syntax keyword typescriptFileMethod contained readAsArrayBuffer readAsBinaryString nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptFileMethod contained readAsDataURL readAsText nextgroup=typescriptFuncCallArg
    1              0.000026 syntax cluster props add=typescriptFileMethod
    1              0.000052 if exists("did_typescript_hilink") | HiLink typescriptFileMethod Keyword
    1              0.000002 endif
    1              0.000014 syntax keyword typescriptFileReaderProp contained error readyState result
    1              0.000024 syntax cluster props add=typescriptFileReaderProp
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptFileReaderProp Keyword
    1              0.000002 endif
    1              0.000018 syntax keyword typescriptFileReaderMethod contained abort readAsArrayBuffer readAsBinaryString nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptFileReaderMethod contained readAsDataURL readAsText nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptFileReaderMethod
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptFileReaderMethod Keyword
    1              0.000001 endif
    1              0.000017 syntax keyword typescriptFileListMethod contained item nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptFileListMethod
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptFileListMethod Keyword
    1              0.000001 endif
    1              0.000018 syntax keyword typescriptBlobMethod contained append getBlob getFile nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptBlobMethod
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptBlobMethod Keyword
    1              0.000001 endif
    1              0.000015 syntax keyword typescriptURLUtilsProp contained hash host hostname href origin password
    1              0.000024 syntax keyword typescriptURLUtilsProp contained pathname port protocol search searchParams
    1              0.000013 syntax keyword typescriptURLUtilsProp contained username
    1              0.000023 syntax cluster props add=typescriptURLUtilsProp
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptURLUtilsProp Keyword
    1              0.000001 endif
    1              0.000018 syntax keyword typescriptURLStaticMethod contained createObjectURL revokeObjectURL nextgroup=typescriptFuncCallArg
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptURLStaticMethod Keyword
    1              0.000008 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-crypto.vim
Sourced 1 time
Total time:   0.001648
 Self time:   0.001648

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000076 syntax keyword typescriptCryptoGlobal containedin=typescriptIdentifierName crypto
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptCryptoGlobal Structure
    1              0.000002 endif
    1              0.000021 syntax keyword typescriptSubtleCryptoMethod contained encrypt decrypt sign verify nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptSubtleCryptoMethod contained digest nextgroup=typescriptFuncCallArg
    1              0.000026 syntax cluster props add=typescriptSubtleCryptoMethod
    1              0.000038 if exists("did_typescript_hilink") | HiLink typescriptSubtleCryptoMethod Keyword
    1              0.000001 endif
    1              0.000013 syntax keyword typescriptCryptoProp contained subtle
    1              0.000023 syntax cluster props add=typescriptCryptoProp
    1              0.000090 if exists("did_typescript_hilink") | HiLink typescriptCryptoProp Keyword
    1              0.000002 endif
    1              0.000018 syntax keyword typescriptCryptoMethod contained getRandomValues nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptCryptoMethod
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptCryptoMethod Keyword
    1              0.000008 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-fetch.vim
Sourced 1 time
Total time:   0.001827
 Self time:   0.001827

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000055 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Headers Request
    1              0.000035 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Response
    1              0.000039 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName fetch nextgroup=typescriptFuncCallArg
    1              0.000027 syntax cluster props add=typescriptGlobalMethod
    1              0.000052 if exists("did_typescript_hilink") | HiLink typescriptGlobalMethod Structure
    1              0.000002 endif
    1              0.000022 syntax keyword typescriptHeadersMethod contained append delete get getAll has set nextgroup=typescriptFuncCallArg
    1              0.000025 syntax cluster props add=typescriptHeadersMethod
    1              0.000038 if exists("did_typescript_hilink") | HiLink typescriptHeadersMethod Keyword
    1              0.000002 endif
    1              0.000015 syntax keyword typescriptRequestProp contained method url headers context referrer
    1              0.000013 syntax keyword typescriptRequestProp contained mode credentials cache
    1              0.000024 syntax cluster props add=typescriptRequestProp
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptRequestProp Keyword
    1              0.000001 endif
    1              0.000018 syntax keyword typescriptRequestMethod contained clone nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptRequestMethod
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptRequestMethod Keyword
    1              0.000001 endif
    1              0.000015 syntax keyword typescriptResponseProp contained type url status statusText headers
    1              0.000012 syntax keyword typescriptResponseProp contained redirected
    1              0.000023 syntax cluster props add=typescriptResponseProp
    1              0.000035 if exists("did_typescript_hilink") | HiLink typescriptResponseProp Keyword
    1              0.000001 endif
    1              0.000017 syntax keyword typescriptResponseMethod contained clone nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptResponseMethod
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptResponseMethod Keyword
    1              0.000008 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-service-worker.vim
Sourced 1 time
Total time:   0.001444
 Self time:   0.001444

count  total (s)   self (s)
    1              0.000022 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000029 syntax keyword typescriptServiceWorkerProp contained controller ready
    1              0.000027 syntax cluster props add=typescriptServiceWorkerProp
    1              0.000048 if exists("did_typescript_hilink") | HiLink typescriptServiceWorkerProp Keyword
    1              0.000002 endif
    1              0.000019 syntax keyword typescriptServiceWorkerMethod contained register getRegistration nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptServiceWorkerMethod
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptServiceWorkerMethod Keyword
    1              0.000001 endif
    1              0.000034 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Cache
    1              0.000019 syntax keyword typescriptCacheMethod contained match matchAll add addAll put delete nextgroup=typescriptFuncCallArg
    1              0.000016 syntax keyword typescriptCacheMethod contained keys nextgroup=typescriptFuncCallArg
    1              0.000023 syntax cluster props add=typescriptCacheMethod
    1              0.000035 if exists("did_typescript_hilink") | HiLink typescriptCacheMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-encoding.vim
Sourced 1 time
Total time:   0.002001
 Self time:   0.002001

count  total (s)   self (s)
    1              0.000031 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000070 syntax keyword typescriptEncodingGlobal containedin=typescriptIdentifierName TextEncoder
    1              0.000025 syntax keyword typescriptEncodingGlobal containedin=typescriptIdentifierName TextDecoder
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptEncodingGlobal Structure
    1              0.000002 endif
    1              0.000015 syntax keyword typescriptEncodingProp contained encoding fatal ignoreBOM
    1              0.000026 syntax cluster props add=typescriptEncodingProp
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptEncodingProp Keyword
    1              0.000001 endif
    1              0.000017 syntax keyword typescriptEncodingMethod contained encode decode nextgroup=typescriptFuncCallArg
    1              0.000024 syntax cluster props add=typescriptEncodingMethod
    1              0.000035 if exists("did_typescript_hilink") | HiLink typescriptEncodingMethod Keyword
    1              0.000008 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-geo.vim
Sourced 1 time
Total time:   0.001325
 Self time:   0.001325

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000056 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Geolocation
    1              0.000019 syntax keyword typescriptGeolocationMethod contained getCurrentPosition watchPosition nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptGeolocationMethod contained clearWatch nextgroup=typescriptFuncCallArg
    1              0.000027 syntax cluster props add=typescriptGeolocationMethod
    1              0.000051 if exists("did_typescript_hilink") | HiLink typescriptGeolocationMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-network.vim
Sourced 1 time
Total time:   0.001439
 Self time:   0.001439

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000058 syntax keyword typescriptGlobal containedin=typescriptIdentifierName NetworkInformation
    1              0.000017 syntax keyword typescriptBOMNetworkProp contained downlink downlinkMax effectiveType
    1              0.000013 syntax keyword typescriptBOMNetworkProp contained rtt type
    1              0.000029 syntax cluster props add=typescriptBOMNetworkProp
    1              0.000099 if exists("did_typescript_hilink") | HiLink typescriptBOMNetworkProp Keyword
    1              0.000013 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/web-payment.vim
Sourced 1 time
Total time:   0.001846
 Self time:   0.001846

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000056 syntax keyword typescriptGlobal containedin=typescriptIdentifierName PaymentRequest
    1              0.000020 syntax keyword typescriptPaymentMethod contained show abort canMakePayment nextgroup=typescriptFuncCallArg
    1              0.000028 syntax cluster props add=typescriptPaymentMethod
    1              0.000051 if exists("did_typescript_hilink") | HiLink typescriptPaymentMethod Keyword
    1              0.000002 endif
    1              0.000015 syntax keyword typescriptPaymentProp contained shippingAddress shippingOption result
    1              0.000024 syntax cluster props add=typescriptPaymentProp
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptPaymentProp Keyword
    1              0.000001 endif
    1              0.000026 syntax keyword typescriptPaymentEvent contained onshippingaddresschange onshippingoptionchange
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptPaymentEvent Keyword
    1              0.000001 endif
    1              0.000018 syntax keyword typescriptPaymentResponseMethod contained complete nextgroup=typescriptFuncCallArg
    1              0.000025 syntax cluster props add=typescriptPaymentResponseMethod
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptPaymentResponseMethod Keyword
    1              0.000001 endif
    1              0.000014 syntax keyword typescriptPaymentResponseProp contained details methodName payerEmail
    1              0.000023 syntax keyword typescriptPaymentResponseProp contained payerPhone shippingAddress
    1              0.000013 syntax keyword typescriptPaymentResponseProp contained shippingOption
    1              0.000024 syntax cluster props add=typescriptPaymentResponseProp
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptPaymentResponseProp Keyword
    1              0.000001 endif
    1              0.000014 syntax keyword typescriptPaymentAddressProp contained addressLine careOf city country
    1              0.000013 syntax keyword typescriptPaymentAddressProp contained country dependentLocality languageCode
    1              0.000013 syntax keyword typescriptPaymentAddressProp contained organization phone postalCode
    1              0.000012 syntax keyword typescriptPaymentAddressProp contained recipient region sortingCode
    1              0.000023 syntax cluster props add=typescriptPaymentAddressProp
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptPaymentAddressProp Keyword
    1              0.000001 endif
    1              0.000014 syntax keyword typescriptPaymentShippingOptionProp contained id label amount selected
    1              0.000024 syntax cluster props add=typescriptPaymentShippingOptionProp
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptPaymentShippingOptionProp Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/dom-node.vim
Sourced 1 time
Total time:   0.001528
 Self time:   0.001528

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000032 syntax keyword typescriptDOMNodeProp contained attributes baseURI baseURIObject childNodes
    1              0.000015 syntax keyword typescriptDOMNodeProp contained firstChild lastChild localName namespaceURI
    1              0.000014 syntax keyword typescriptDOMNodeProp contained nextSibling nodeName nodePrincipal
    1              0.000014 syntax keyword typescriptDOMNodeProp contained nodeType nodeValue ownerDocument parentElement
    1              0.000013 syntax keyword typescriptDOMNodeProp contained parentNode prefix previousSibling textContent
    1              0.000027 syntax cluster props add=typescriptDOMNodeProp
    1              0.000052 if exists("did_typescript_hilink") | HiLink typescriptDOMNodeProp Keyword
    1              0.000002 endif
    1              0.000020 syntax keyword typescriptDOMNodeMethod contained appendChild cloneNode compareDocumentPosition nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptDOMNodeMethod contained getUserData hasAttributes hasChildNodes nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDOMNodeMethod contained insertBefore isDefaultNamespace isEqualNode nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDOMNodeMethod contained isSameNode isSupported lookupNamespaceURI nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDOMNodeMethod contained lookupPrefix normalize removeChild nextgroup=typescriptFuncCallArg
    1              0.000027 syntax keyword typescriptDOMNodeMethod contained replaceChild setUserData nextgroup=typescriptFuncCallArg
    1              0.000022 syntax match typescriptDOMNodeMethod contained /contains/
    1              0.000026 syntax cluster props add=typescriptDOMNodeMethod
    1              0.000039 if exists("did_typescript_hilink") | HiLink typescriptDOMNodeMethod Keyword
    1              0.000001 endif
    1              0.000027 syntax keyword typescriptDOMNodeType contained ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE
    1              0.000004 syntax keyword typescriptDOMNodeType contained CDATA_SECTION_NODEN_NODE ENTITY_REFERENCE_NODE
    1              0.000003 syntax keyword typescriptDOMNodeType contained ENTITY_NODE PROCESSING_INSTRUCTION_NODEN_NODE
    1              0.000004 syntax keyword typescriptDOMNodeType contained COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE
    1              0.000003 syntax keyword typescriptDOMNodeType contained DOCUMENT_FRAGMENT_NODE NOTATION_NODE
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptDOMNodeType Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/dom-elem.vim
Sourced 1 time
Total time:   0.001343
 Self time:   0.001343

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000049 syntax keyword typescriptDOMElemAttrs contained accessKey clientHeight clientLeft
    1              0.000006 syntax keyword typescriptDOMElemAttrs contained clientTop clientWidth id innerHTML
    1              0.000005 syntax keyword typescriptDOMElemAttrs contained length onafterscriptexecute onbeforescriptexecute
    1              0.000005 syntax keyword typescriptDOMElemAttrs contained oncopy oncut onpaste onwheel scrollHeight
    1              0.000004 syntax keyword typescriptDOMElemAttrs contained scrollLeft scrollTop scrollWidth tagName
    1              0.000004 syntax keyword typescriptDOMElemAttrs contained classList className name outerHTML
    1              0.000003 syntax keyword typescriptDOMElemAttrs contained style
    1              0.000035 if exists("did_typescript_hilink") | HiLink typescriptDOMElemAttrs Keyword
    1              0.000002 endif
    1              0.000024 syntax keyword typescriptDOMElemFuncs contained getAttributeNS getAttributeNode getAttributeNodeNS
    1              0.000004 syntax keyword typescriptDOMElemFuncs contained getBoundingClientRect getClientRects
    1              0.000013 syntax keyword typescriptDOMElemFuncs contained getElementsByClassName getElementsByTagName
    1              0.000003 syntax keyword typescriptDOMElemFuncs contained getElementsByTagNameNS hasAttribute
    1              0.000003 syntax keyword typescriptDOMElemFuncs contained hasAttributeNS insertAdjacentHTML
    1              0.000003 syntax keyword typescriptDOMElemFuncs contained matches querySelector querySelectorAll
    1              0.000003 syntax keyword typescriptDOMElemFuncs contained removeAttribute removeAttributeNS
    1              0.000003 syntax keyword typescriptDOMElemFuncs contained removeAttributeNode requestFullscreen
    1              0.000003 syntax keyword typescriptDOMElemFuncs contained requestPointerLock scrollIntoView
    1              0.000004 syntax keyword typescriptDOMElemFuncs contained setAttribute setAttributeNS setAttributeNode
    1              0.000004 syntax keyword typescriptDOMElemFuncs contained setAttributeNodeNS setCapture supports
    1              0.000003 syntax keyword typescriptDOMElemFuncs contained getAttribute
    1              0.000027 if exists("did_typescript_hilink") | HiLink typescriptDOMElemFuncs Keyword
    1              0.000008 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/dom-document.vim
Sourced 1 time
Total time:   0.001771
 Self time:   0.001771

count  total (s)   self (s)
    1              0.000022 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000032 syntax keyword typescriptDOMDocProp contained activeElement body cookie defaultView
    1              0.000016 syntax keyword typescriptDOMDocProp contained designMode dir domain embeds forms head
    1              0.000014 syntax keyword typescriptDOMDocProp contained images lastModified links location plugins
    1              0.000014 syntax keyword typescriptDOMDocProp contained postMessage readyState referrer registerElement
    1              0.000014 syntax keyword typescriptDOMDocProp contained scripts styleSheets title vlinkColor
    1              0.000013 syntax keyword typescriptDOMDocProp contained xmlEncoding characterSet compatMode
    1              0.000014 syntax keyword typescriptDOMDocProp contained contentType currentScript doctype documentElement
    1              0.000013 syntax keyword typescriptDOMDocProp contained documentURI documentURIObject firstChild
    1              0.000023 syntax keyword typescriptDOMDocProp contained implementation lastStyleSheetSet namespaceURI
    1              0.000014 syntax keyword typescriptDOMDocProp contained nodePrincipal ononline pointerLockElement
    1              0.000013 syntax keyword typescriptDOMDocProp contained popupNode preferredStyleSheetSet selectedStyleSheetSet
    1              0.000013 syntax keyword typescriptDOMDocProp contained styleSheetSets textContent tooltipNode
    1              0.000027 syntax cluster props add=typescriptDOMDocProp
    1              0.000053 if exists("did_typescript_hilink") | HiLink typescriptDOMDocProp Keyword
    1              0.000002 endif
    1              0.000019 syntax keyword typescriptDOMDocMethod contained caretPositionFromPoint close createNodeIterator nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptDOMDocMethod contained createRange createTreeWalker elementFromPoint nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDOMDocMethod contained getElementsByName adoptNode createAttribute nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDOMDocMethod contained createCDATASection createComment createDocumentFragment nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptDOMDocMethod contained createElement createElementNS createEvent nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDOMDocMethod contained createExpression createNSResolver nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDOMDocMethod contained createProcessingInstruction createTextNode nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDOMDocMethod contained enableStyleSheetsForSet evaluate execCommand nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDOMDocMethod contained exitPointerLock getBoxObjectFor getElementById nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDOMDocMethod contained getElementsByClassName getElementsByTagName nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDOMDocMethod contained getElementsByTagNameNS getSelection nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDOMDocMethod contained hasFocus importNode loadOverlay open nextgroup=typescriptFuncCallArg
    1              0.000016 syntax keyword typescriptDOMDocMethod contained queryCommandSupported querySelector nextgroup=typescriptFuncCallArg
    1              0.000017 syntax keyword typescriptDOMDocMethod contained querySelectorAll write writeln nextgroup=typescriptFuncCallArg
    1              0.000028 syntax cluster props add=typescriptDOMDocMethod
    1              0.000039 if exists("did_typescript_hilink") | HiLink typescriptDOMDocMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/dom-event.vim
Sourced 1 time
Total time:   0.003816
 Self time:   0.003816

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000036 syntax keyword typescriptDOMEventTargetMethod contained addEventListener removeEventListener nextgroup=typescriptEventFuncCallArg
    1              0.000018 syntax keyword typescriptDOMEventTargetMethod contained dispatchEvent waitUntil nextgroup=typescriptEventFuncCallArg
    1              0.000027 syntax cluster props add=typescriptDOMEventTargetMethod
    1              0.000050 if exists("did_typescript_hilink") | HiLink typescriptDOMEventTargetMethod Keyword
    1              0.000002 endif
    1              0.000046 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName AnimationEvent
    1              0.000024 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName AudioProcessingEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BeforeInputEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BeforeUnloadEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BlobEvent
    1              0.000024 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ClipboardEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CloseEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CompositionEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CSSFontFaceLoadEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CustomEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceLightEvent
    1              0.000024 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceMotionEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceOrientationEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceProximityEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DOMTransactionEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DragEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName EditingBeforeInputEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ErrorEvent
    1              0.000024 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName FocusEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName GamepadEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName HashChangeEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName IDBVersionChangeEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName KeyboardEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MediaStreamEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MessageEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MouseEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MutationEvent
    1              0.000024 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName OfflineAudioCompletionEvent
    1              0.000024 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PageTransitionEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PointerEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PopStateEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ProgressEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName RelatedEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName RTCPeerConnectionIceEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SensorEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName StorageEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SVGEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SVGZoomEvent
    1              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TimeEvent
    1              0.001288 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TouchEvent
    1              0.000037 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TrackEvent
    1              0.000027 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TransitionEvent
    1              0.000025 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName UIEvent
    1              0.000025 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName UserProximityEvent
    1              0.000025 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName WheelEvent
    1              0.000049 if exists("did_typescript_hilink") | HiLink typescriptDOMEventCons Structure
    1              0.000002 endif
    1              0.000016 syntax keyword typescriptDOMEventProp contained bubbles cancelable currentTarget defaultPrevented
    1              0.000015 syntax keyword typescriptDOMEventProp contained eventPhase target timeStamp type isTrusted
    1              0.000012 syntax keyword typescriptDOMEventProp contained isReload
    1              0.000027 syntax cluster props add=typescriptDOMEventProp
    1              0.000038 if exists("did_typescript_hilink") | HiLink typescriptDOMEventProp Keyword
    1              0.000002 endif
    1              0.000019 syntax keyword typescriptDOMEventMethod contained initEvent preventDefault stopImmediatePropagation nextgroup=typescriptEventFuncCallArg
    1              0.000018 syntax keyword typescriptDOMEventMethod contained stopPropagation respondWith default nextgroup=typescriptEventFuncCallArg
    1              0.000025 syntax cluster props add=typescriptDOMEventMethod
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptDOMEventMethod Keyword
    1              0.000008 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/dom-storage.vim
Sourced 1 time
Total time:   0.001434
 Self time:   0.001434

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000052 syntax keyword typescriptDOMStorage contained sessionStorage localStorage
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptDOMStorage Keyword
    1              0.000002 endif
    1              0.000014 syntax keyword typescriptDOMStorageProp contained length
    1              0.000028 syntax cluster props add=typescriptDOMStorageProp
    1              0.000037 if exists("did_typescript_hilink") | HiLink typescriptDOMStorageProp Keyword
    1              0.000002 endif
    1              0.000021 syntax keyword typescriptDOMStorageMethod contained getItem key setItem removeItem nextgroup=typescriptFuncCallArg
    1              0.000018 syntax keyword typescriptDOMStorageMethod contained clear nextgroup=typescriptFuncCallArg
    1              0.000026 syntax cluster props add=typescriptDOMStorageMethod
    1              0.000038 if exists("did_typescript_hilink") | HiLink typescriptDOMStorageMethod Keyword
    1              0.000009 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/dom-form.vim
Sourced 1 time
Total time:   0.001143
 Self time:   0.001143

count  total (s)   self (s)
    1              0.000020 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000029 syntax keyword typescriptDOMFormProp contained acceptCharset action elements encoding
    1              0.000016 syntax keyword typescriptDOMFormProp contained enctype length method name target
    1              0.000028 syntax cluster props add=typescriptDOMFormProp
    1              0.000050 if exists("did_typescript_hilink") | HiLink typescriptDOMFormProp Keyword
    1              0.000002 endif
    1              0.000020 syntax keyword typescriptDOMFormMethod contained reportValidity reset submit nextgroup=typescriptFuncCallArg
    1              0.000025 syntax cluster props add=typescriptDOMFormMethod
    1              0.000038 if exists("did_typescript_hilink") | HiLink typescriptDOMFormMethod Keyword
    1              0.000007 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/css.vim
Sourced 1 time
Total time:   0.003056
 Self time:   0.003056

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000016 syntax keyword typescriptDOMStyle contained alignContent alignItems alignSelf animation
    1              0.000006 syntax keyword typescriptDOMStyle contained animationDelay animationDirection animationDuration
    1              0.000004 syntax keyword typescriptDOMStyle contained animationFillMode animationIterationCount
    1              0.000004 syntax keyword typescriptDOMStyle contained animationName animationPlayState animationTimingFunction
    1              0.000004 syntax keyword typescriptDOMStyle contained appearance backfaceVisibility background
    1              0.000004 syntax keyword typescriptDOMStyle contained backgroundAttachment backgroundBlendMode
    1              0.000004 syntax keyword typescriptDOMStyle contained backgroundClip backgroundColor backgroundImage
    1              0.000004 syntax keyword typescriptDOMStyle contained backgroundOrigin backgroundPosition backgroundRepeat
    1              0.000005 syntax keyword typescriptDOMStyle contained backgroundSize border borderBottom borderBottomColor
    1              0.000004 syntax keyword typescriptDOMStyle contained borderBottomLeftRadius borderBottomRightRadius
    1              0.000004 syntax keyword typescriptDOMStyle contained borderBottomStyle borderBottomWidth borderCollapse
    1              0.000004 syntax keyword typescriptDOMStyle contained borderColor borderImage borderImageOutset
    1              0.000004 syntax keyword typescriptDOMStyle contained borderImageRepeat borderImageSlice borderImageSource
    1              0.000004 syntax keyword typescriptDOMStyle contained borderImageWidth borderLeft borderLeftColor
    1              0.000004 syntax keyword typescriptDOMStyle contained borderLeftStyle borderLeftWidth borderRadius
    1              0.000004 syntax keyword typescriptDOMStyle contained borderRight borderRightColor borderRightStyle
    1              0.000004 syntax keyword typescriptDOMStyle contained borderRightWidth borderSpacing borderStyle
    1              0.000004 syntax keyword typescriptDOMStyle contained borderTop borderTopColor borderTopLeftRadius
    1              0.000004 syntax keyword typescriptDOMStyle contained borderTopRightRadius borderTopStyle borderTopWidth
    1              0.000014 syntax keyword typescriptDOMStyle contained borderWidth bottom boxDecorationBreak
    1              0.000005 syntax keyword typescriptDOMStyle contained boxShadow boxSizing breakAfter breakBefore
    1              0.000005 syntax keyword typescriptDOMStyle contained breakInside captionSide caretColor caretShape
    1              0.000006 syntax keyword typescriptDOMStyle contained caret clear clip clipPath color columns
    1              0.000005 syntax keyword typescriptDOMStyle contained columnCount columnFill columnGap columnRule
    1              0.000005 syntax keyword typescriptDOMStyle contained columnRuleColor columnRuleStyle columnRuleWidth
    1              0.000005 syntax keyword typescriptDOMStyle contained columnSpan columnWidth content counterIncrement
    1              0.000005 syntax keyword typescriptDOMStyle contained counterReset cursor direction display
    1              0.000005 syntax keyword typescriptDOMStyle contained emptyCells flex flexBasis flexDirection
    1              0.000005 syntax keyword typescriptDOMStyle contained flexFlow flexGrow flexShrink flexWrap
    1              0.000005 syntax keyword typescriptDOMStyle contained float font fontFamily fontFeatureSettings
    1              0.000004 syntax keyword typescriptDOMStyle contained fontKerning fontLanguageOverride fontSize
    1              0.000005 syntax keyword typescriptDOMStyle contained fontSizeAdjust fontStretch fontStyle fontSynthesis
    1              0.000005 syntax keyword typescriptDOMStyle contained fontVariant fontVariantAlternates fontVariantCaps
    1              0.000004 syntax keyword typescriptDOMStyle contained fontVariantEastAsian fontVariantLigatures
    1              0.000004 syntax keyword typescriptDOMStyle contained fontVariantNumeric fontVariantPosition
    1              0.000008 syntax keyword typescriptDOMStyle contained fontWeight grad grid gridArea gridAutoColumns
    1              0.000005 syntax keyword typescriptDOMStyle contained gridAutoFlow gridAutoPosition gridAutoRows
    1              0.000004 syntax keyword typescriptDOMStyle contained gridColumn gridColumnStart gridColumnEnd
    1              0.000005 syntax keyword typescriptDOMStyle contained gridRow gridRowStart gridRowEnd gridTemplate
    1              0.000005 syntax keyword typescriptDOMStyle contained gridTemplateAreas gridTemplateRows gridTemplateColumns
    1              0.000005 syntax keyword typescriptDOMStyle contained height hyphens imageRendering imageResolution
    1              0.000004 syntax keyword typescriptDOMStyle contained imageOrientation imeMode inherit justifyContent
    1              0.000004 syntax keyword typescriptDOMStyle contained left letterSpacing lineBreak lineHeight
    1              0.000004 syntax keyword typescriptDOMStyle contained listStyle listStyleImage listStylePosition
    1              0.001434 syntax keyword typescriptDOMStyle contained listStyleType margin marginBottom marginLeft
    1              0.000008 syntax keyword typescriptDOMStyle contained marginRight marginTop marks mask maskType
    1              0.000005 syntax keyword typescriptDOMStyle contained maxHeight maxWidth minHeight minWidth
    1              0.000005 syntax keyword typescriptDOMStyle contained mixBlendMode objectFit objectPosition
    1              0.000006 syntax keyword typescriptDOMStyle contained opacity order orphans outline outlineColor
    1              0.000004 syntax keyword typescriptDOMStyle contained outlineOffset outlineStyle outlineWidth
    1              0.000005 syntax keyword typescriptDOMStyle contained overflow overflowWrap overflowX overflowY
    1              0.000004 syntax keyword typescriptDOMStyle contained overflowClipBox padding paddingBottom
    1              0.000005 syntax keyword typescriptDOMStyle contained paddingLeft paddingRight paddingTop pageBreakAfter
    1              0.000004 syntax keyword typescriptDOMStyle contained pageBreakBefore pageBreakInside perspective
    1              0.000011 syntax keyword typescriptDOMStyle contained perspectiveOrigin pointerEvents position
    1              0.000005 syntax keyword typescriptDOMStyle contained quotes resize right shapeImageThreshold
    1              0.000005 syntax keyword typescriptDOMStyle contained shapeMargin shapeOutside tableLayout tabSize
    1              0.000004 syntax keyword typescriptDOMStyle contained textAlign textAlignLast textCombineHorizontal
    1              0.000005 syntax keyword typescriptDOMStyle contained textDecoration textDecorationColor textDecorationLine
    1              0.000005 syntax keyword typescriptDOMStyle contained textDecorationStyle textIndent textOrientation
    1              0.000005 syntax keyword typescriptDOMStyle contained textOverflow textRendering textShadow
    1              0.000005 syntax keyword typescriptDOMStyle contained textTransform textUnderlinePosition top
    1              0.000004 syntax keyword typescriptDOMStyle contained touchAction transform transformOrigin
    1              0.000005 syntax keyword typescriptDOMStyle contained transformStyle transition transitionDelay
    1              0.000004 syntax keyword typescriptDOMStyle contained transitionDuration transitionProperty
    1              0.000004 syntax keyword typescriptDOMStyle contained transitionTimingFunction unicodeBidi unicodeRange
    1              0.000004 syntax keyword typescriptDOMStyle contained userSelect userZoom verticalAlign visibility
    1              0.000004 syntax keyword typescriptDOMStyle contained whiteSpace width willChange wordBreak
    1              0.000005 syntax keyword typescriptDOMStyle contained wordSpacing wordWrap writingMode zIndex
    1              0.000064 if exists("did_typescript_hilink") | HiLink typescriptDOMStyle Keyword
    1              0.000008 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/yats/event.vim
Sourced 1 time
Total time:   0.004196
 Self time:   0.004196

count  total (s)   self (s)
    1              0.000029 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000047 syntax keyword typescriptAnimationEvent contained animationend animationiteration
    1              0.000005 syntax keyword typescriptAnimationEvent contained animationstart beginEvent endEvent
    1              0.000003 syntax keyword typescriptAnimationEvent contained repeatEvent
    1              0.000006 syntax cluster events add=typescriptAnimationEvent
    1              0.000036 if exists("did_typescript_hilink") | HiLink typescriptAnimationEvent Title
    1              0.000002 endif
    1              0.000024 syntax keyword typescriptCSSEvent contained CssRuleViewRefreshed CssRuleViewChanged
    1              0.000004 syntax keyword typescriptCSSEvent contained CssRuleViewCSSLinkClicked transitionend
    1              0.000006 syntax cluster events add=typescriptCSSEvent
    1              0.000029 if exists("did_typescript_hilink") | HiLink typescriptCSSEvent Title
    1              0.000001 endif
    1              0.000025 syntax keyword typescriptDatabaseEvent contained blocked complete error success upgradeneeded
    1              0.000003 syntax keyword typescriptDatabaseEvent contained versionchange
    1              0.000005 syntax cluster events add=typescriptDatabaseEvent
    1              0.000029 if exists("did_typescript_hilink") | HiLink typescriptDatabaseEvent Title
    1              0.000001 endif
    1              0.000023 syntax keyword typescriptDocumentEvent contained DOMLinkAdded DOMLinkRemoved DOMMetaAdded
    1              0.000004 syntax keyword typescriptDocumentEvent contained DOMMetaRemoved DOMWillOpenModalDialog
    1              0.000003 syntax keyword typescriptDocumentEvent contained DOMModalDialogClosed unload
    1              0.000004 syntax cluster events add=typescriptDocumentEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptDocumentEvent Title
    1              0.000001 endif
    1              0.000023 syntax keyword typescriptDOMMutationEvent contained DOMAttributeNameChanged DOMAttrModified
    1              0.000004 syntax keyword typescriptDOMMutationEvent contained DOMCharacterDataModified DOMContentLoaded
    1              0.000003 syntax keyword typescriptDOMMutationEvent contained DOMElementNameChanged DOMNodeInserted
    1              0.000003 syntax keyword typescriptDOMMutationEvent contained DOMNodeInsertedIntoDocument DOMNodeRemoved
    1              0.000003 syntax keyword typescriptDOMMutationEvent contained DOMNodeRemovedFromDocument DOMSubtreeModified
    1              0.000004 syntax cluster events add=typescriptDOMMutationEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptDOMMutationEvent Title
    1              0.000001 endif
    1              0.000024 syntax keyword typescriptDragEvent contained drag dragdrop dragend dragenter dragexit
    1              0.000005 syntax keyword typescriptDragEvent contained draggesture dragleave dragover dragstart
    1              0.000003 syntax keyword typescriptDragEvent contained drop
    1              0.000004 syntax cluster events add=typescriptDragEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptDragEvent Title
    1              0.000001 endif
    1              0.000024 syntax keyword typescriptElementEvent contained invalid overflow underflow DOMAutoComplete
    1              0.000007 syntax keyword typescriptElementEvent contained command commandupdate
    1              0.000004 syntax cluster events add=typescriptElementEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptElementEvent Title
    1              0.000001 endif
    1              0.000024 syntax keyword typescriptFocusEvent contained blur change DOMFocusIn DOMFocusOut focus
    1              0.000003 syntax keyword typescriptFocusEvent contained focusin focusout
    1              0.000004 syntax cluster events add=typescriptFocusEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptFocusEvent Title
    1              0.000001 endif
    1              0.000023 syntax keyword typescriptFormEvent contained reset submit
    1              0.000005 syntax cluster events add=typescriptFormEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptFormEvent Title
    1              0.000001 endif
    1              0.000022 syntax keyword typescriptFrameEvent contained DOMFrameContentLoaded
    1              0.000005 syntax cluster events add=typescriptFrameEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptFrameEvent Title
    1              0.000001 endif
    1              0.000024 syntax keyword typescriptInputDeviceEvent contained click contextmenu DOMMouseScroll
    1              0.000004 syntax keyword typescriptInputDeviceEvent contained dblclick gamepadconnected gamepaddisconnected
    1              0.000004 syntax keyword typescriptInputDeviceEvent contained keydown keypress keyup MozGamepadButtonDown
    1              0.000004 syntax keyword typescriptInputDeviceEvent contained MozGamepadButtonUp mousedown mouseenter
    1              0.000003 syntax keyword typescriptInputDeviceEvent contained mouseleave mousemove mouseout
    1              0.000004 syntax keyword typescriptInputDeviceEvent contained mouseover mouseup mousewheel MozMousePixelScroll
    1              0.000003 syntax keyword typescriptInputDeviceEvent contained pointerlockchange pointerlockerror
    1              0.000002 syntax keyword typescriptInputDeviceEvent contained wheel
    1              0.001109 syntax cluster events add=typescriptInputDeviceEvent
    1              0.000065 if exists("did_typescript_hilink") | HiLink typescriptInputDeviceEvent Title
    1              0.000002 endif
    1              0.000026 syntax keyword typescriptMediaEvent contained audioprocess canplay canplaythrough
    1              0.000006 syntax keyword typescriptMediaEvent contained durationchange emptied ended ended loadeddata
    1              0.000004 syntax keyword typescriptMediaEvent contained loadedmetadata MozAudioAvailable pause
    1              0.000004 syntax keyword typescriptMediaEvent contained play playing ratechange seeked seeking
    1              0.000004 syntax keyword typescriptMediaEvent contained stalled suspend timeupdate volumechange
    1              0.000003 syntax keyword typescriptMediaEvent contained waiting complete
    1              0.000005 syntax cluster events add=typescriptMediaEvent
    1              0.000030 if exists("did_typescript_hilink") | HiLink typescriptMediaEvent Title
    1              0.000002 endif
    1              0.000023 syntax keyword typescriptMenuEvent contained DOMMenuItemActive DOMMenuItemInactive
    1              0.000005 syntax cluster events add=typescriptMenuEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptMenuEvent Title
    1              0.000001 endif
    1              0.000024 syntax keyword typescriptNetworkEvent contained datachange dataerror disabled enabled
    1              0.000005 syntax keyword typescriptNetworkEvent contained offline online statuschange connectionInfoUpdate
    1              0.000005 syntax cluster events add=typescriptNetworkEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptNetworkEvent Title
    1              0.000001 endif
    1              0.000024 syntax keyword typescriptProgressEvent contained abort error load loadend loadstart
    1              0.000005 syntax keyword typescriptProgressEvent contained progress timeout uploadprogress
    1              0.000005 syntax cluster events add=typescriptProgressEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptProgressEvent Title
    1              0.000001 endif
    1              0.000023 syntax keyword typescriptResourceEvent contained cached error load
    1              0.000005 syntax cluster events add=typescriptResourceEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptResourceEvent Title
    1              0.000001 endif
    1              0.000033 syntax keyword typescriptScriptEvent contained afterscriptexecute beforescriptexecute
    1              0.000005 syntax cluster events add=typescriptScriptEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptScriptEvent Title
    1              0.000001 endif
    1              0.000023 syntax keyword typescriptSensorEvent contained compassneedscalibration devicelight
    1              0.000004 syntax keyword typescriptSensorEvent contained devicemotion deviceorientation deviceproximity
    1              0.000004 syntax keyword typescriptSensorEvent contained orientationchange userproximity
    1              0.000005 syntax cluster events add=typescriptSensorEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptSensorEvent Title
    1              0.000001 endif
    1              0.000023 syntax keyword typescriptSessionHistoryEvent contained pagehide pageshow popstate
    1              0.000005 syntax cluster events add=typescriptSessionHistoryEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptSessionHistoryEvent Title
    1              0.000001 endif
    1              0.000023 syntax keyword typescriptStorageEvent contained change storage
    1              0.000005 syntax cluster events add=typescriptStorageEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptStorageEvent Title
    1              0.000001 endif
    1              0.000025 syntax keyword typescriptSVGEvent contained SVGAbort SVGError SVGLoad SVGResize SVGScroll
    1              0.000004 syntax keyword typescriptSVGEvent contained SVGUnload SVGZoom
    1              0.000005 syntax cluster events add=typescriptSVGEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptSVGEvent Title
    1              0.000001 endif
    1              0.000022 syntax keyword typescriptTabEvent contained visibilitychange
    1              0.000005 syntax cluster events add=typescriptTabEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptTabEvent Title
    1              0.000001 endif
    1              0.000024 syntax keyword typescriptTextEvent contained compositionend compositionstart compositionupdate
    1              0.000005 syntax keyword typescriptTextEvent contained copy cut paste select text
    1              0.000005 syntax cluster events add=typescriptTextEvent
    1              0.000027 if exists("did_typescript_hilink") | HiLink typescriptTextEvent Title
    1              0.000001 endif
    1              0.000029 syntax keyword typescriptTouchEvent contained touchcancel touchend touchenter touchleave
    1              0.000004 syntax keyword typescriptTouchEvent contained touchmove touchstart
    1              0.000005 syntax cluster events add=typescriptTouchEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptTouchEvent Title
    1              0.000001 endif
    1              0.000023 syntax keyword typescriptUpdateEvent contained checking downloading error noupdate
    1              0.000003 syntax keyword typescriptUpdateEvent contained obsolete updateready
    1              0.000005 syntax cluster events add=typescriptUpdateEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptUpdateEvent Title
    1              0.000001 endif
    1              0.000023 syntax keyword typescriptValueChangeEvent contained hashchange input readystatechange
    1              0.000015 syntax cluster events add=typescriptValueChangeEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptValueChangeEvent Title
    1              0.000001 endif
    1              0.000023 syntax keyword typescriptViewEvent contained fullscreen fullscreenchange fullscreenerror
    1              0.000003 syntax keyword typescriptViewEvent contained resize scroll
    1              0.000005 syntax cluster events add=typescriptViewEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptViewEvent Title
    1              0.000001 endif
    1              0.000028 syntax keyword typescriptWebsocketEvent contained close error message open
    1              0.000005 syntax cluster events add=typescriptWebsocketEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptWebsocketEvent Title
    1              0.000001 endif
    1              0.000023 syntax keyword typescriptWindowEvent contained DOMWindowCreated DOMWindowClose DOMTitleChanged
    1              0.000005 syntax cluster events add=typescriptWindowEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptWindowEvent Title
    1              0.000001 endif
    1              0.000023 syntax keyword typescriptUncategorizedEvent contained beforeunload message open show
    1              0.000005 syntax cluster events add=typescriptUncategorizedEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptUncategorizedEvent Title
    1              0.000001 endif
    1              0.000023 syntax keyword typescriptServiceWorkerEvent contained install activate fetch
    1              0.000005 syntax cluster events add=typescriptServiceWorkerEvent
    1              0.000028 if exists("did_typescript_hilink") | HiLink typescriptServiceWorkerEvent Title
    1              0.000004 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/basic/patch.vim
Sourced 1 time
Total time:   0.001144
 Self time:   0.001144

count  total (s)   self (s)
    1              0.000027 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

                            " patch for generated code
    1              0.000070 syntax keyword typescriptGlobal Promise
                              \ nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg,typescriptTypeArguments oneline
    1              0.000053 syntax keyword typescriptGlobal Map WeakMap
                              \ nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg,typescriptTypeArguments oneline

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/basic/members.vim
Sourced 1 time
Total time:   0.001792
 Self time:   0.001792

count  total (s)   self (s)
    1              0.000025 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000057 syntax keyword typescriptConstructor           contained constructor
                              \ nextgroup=@typescriptCallSignature
                              \ skipwhite skipempty


    1              0.000050 syntax cluster memberNextGroup contains=typescriptMemberOptionality,typescriptTypeAnnotation,@typescriptCallSignature

    1              0.000026 syntax match typescriptMember /#\?\K\k*/
                              \ nextgroup=@memberNextGroup
                              \ contained skipwhite

    1              0.000022 syntax match typescriptMethodAccessor contained /\v(get|set)\s\K/me=e-1
                              \ nextgroup=@typescriptMembers

    1              0.000092 syntax cluster typescriptPropertyMemberDeclaration contains=
                              \ typescriptClassStatic,
                              \ typescriptAccessibilityModifier,
                              \ typescriptReadonlyModifier,
                              \ typescriptMethodAccessor,
                              \ @typescriptMembers
                              " \ typescriptMemberVariableDeclaration

    1              0.000041 syntax match typescriptMemberOptionality /?\|!/ contained
                              \ nextgroup=typescriptTypeAnnotation,@typescriptCallSignature
                              \ skipwhite skipempty

    1              0.000066 syntax cluster typescriptMembers contains=typescriptMember,typescriptStringMember,typescriptComputedMember

    1              0.000057 syntax keyword typescriptClassStatic static
                              \ nextgroup=@typescriptMembers,typescriptAsyncFuncKeyword,typescriptReadonlyModifier
                              \ skipwhite contained

    1              0.000014 syntax keyword typescriptAccessibilityModifier public private protected contained

    1              0.000013 syntax keyword typescriptReadonlyModifier readonly contained

    1              0.000021 syntax region  typescriptStringMember   contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1/
                              \ nextgroup=@memberNextGroup
                              \ skipwhite skipempty

    1              0.000067 syntax region  typescriptComputedMember   contained matchgroup=typescriptProperty
                              \ start=/\[/rs=s+1 end=/]/
                              \ contains=@typescriptValue,typescriptMember,typescriptMappedIn
                              \ nextgroup=@memberNextGroup
                              \ skipwhite skipempty

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/basic/class.vim
Sourced 1 time
Total time:   0.002386
 Self time:   0.002386

count  total (s)   self (s)
    1              0.000035 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

                            "don't add typescriptMembers to nextgroup, let outer scope match it
                            " so we won't match abstract method outside abstract class
    1              0.000064 syntax keyword typescriptAbstract              abstract
                              \ nextgroup=typescriptClassKeyword
                              \ skipwhite skipnl
    1              0.000133 syntax keyword typescriptClassKeyword          class
                              \ nextgroup=typescriptClassName,typescriptClassExtends,typescriptClassBlock
                              \ skipwhite

    1              0.000084 syntax match   typescriptClassName             contained /\K\k*/
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends,typescriptClassTypeParameter
                              \ skipwhite skipnl

    1              0.000080 syntax region typescriptClassTypeParameter
                              \ start=/</ end=/>/
                              \ contains=@typescriptTypeParameterCluster
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends
                              \ contained skipwhite skipnl

    1              0.000048 syntax keyword typescriptClassExtends          contained extends implements nextgroup=typescriptClassHeritage skipwhite skipnl

    1              0.000132 syntax match   typescriptClassHeritage         contained /\v(\k|\.|\(|\))+/
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends,typescriptMixinComma,typescriptClassTypeArguments
                              \ contains=@typescriptValue
                              \ skipwhite skipnl
                              \ contained

    1              0.000033 syntax region typescriptClassTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptClassExtends,typescriptClassBlock,typescriptMixinComma
                              \ contained skipwhite skipnl

    1              0.000046 syntax match typescriptMixinComma /,/ contained nextgroup=typescriptClassHeritage skipwhite skipnl

                            " we need add arrowFunc to class block for high order arrow func
                            " see test case
    1              0.000168 syntax region  typescriptClassBlock matchgroup=typescriptBraces start=/{/ end=/}/
                              \ contains=@typescriptPropertyMemberDeclaration,typescriptAbstract,@typescriptComments,typescriptBlock,typescriptAssign,typescriptDecorator,typescriptAsyncFuncKeyword,typescriptArrowFunc
                              \ contained fold

    1              0.000046 syntax keyword typescriptInterfaceKeyword          interface nextgroup=typescriptInterfaceName skipwhite
    1              0.000111 syntax match   typescriptInterfaceName             contained /\k\+/
                              \ nextgroup=typescriptObjectType,typescriptInterfaceExtends,typescriptInterfaceTypeParameter
                              \ skipwhite skipnl
    1              0.000030 syntax region typescriptInterfaceTypeParameter
                              \ start=/</ end=/>/
                              \ contains=@typescriptTypeParameterCluster
                              \ nextgroup=typescriptObjectType,typescriptInterfaceExtends
                              \ contained
                              \ skipwhite skipnl

    1              0.000045 syntax keyword typescriptInterfaceExtends          contained extends nextgroup=typescriptInterfaceHeritage skipwhite skipnl

    1              0.000112 syntax match typescriptInterfaceHeritage contained /\v(\k|\.)+/
                              \ nextgroup=typescriptObjectType,typescriptInterfaceComma,typescriptInterfaceTypeArguments
                              \ skipwhite

    1              0.000043 syntax region typescriptInterfaceTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/ skip=/\s*,\s*/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptObjectType,typescriptInterfaceComma
                              \ contained skipwhite

    1              0.000057 syntax match typescriptInterfaceComma /,/ contained nextgroup=typescriptInterfaceHeritage skipwhite skipnl

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/basic/cluster.vim
Sourced 1 time
Total time:   0.001716
 Self time:   0.001716

count  total (s)   self (s)
    1              0.000022 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

                            "Block VariableStatement EmptyStatement ExpressionStatement IfStatement IterationStatement ContinueStatement BreakStatement ReturnStatement WithStatement LabelledStatement SwitchStatement ThrowStatement TryStatement DebuggerStatement
    1              0.000207 syntax cluster typescriptStatement
                              \ contains=typescriptBlock,typescriptVariable,
                              \ @typescriptTopExpression,typescriptAssign,
                              \ typescriptConditional,typescriptRepeat,typescriptBranch,
                              \ typescriptLabel,typescriptStatementKeyword,
                              \ typescriptFuncKeyword,
                              \ typescriptTry,typescriptExceptions,typescriptDebugger,
                              \ typescriptExport,typescriptInterfaceKeyword,typescriptEnum,
                              \ typescriptModule,typescriptAliasKeyword,typescriptImport

    1              0.000048 syntax cluster typescriptPrimitive  contains=typescriptString,typescriptTemplate,typescriptRegexpString,typescriptNumber,typescriptBoolean,typescriptNull,typescriptArray

    1              0.000041 syntax cluster typescriptEventTypes            contains=typescriptEventString,typescriptTemplate,typescriptNumber,typescriptBoolean,typescriptNull

                            " top level expression: no arrow func
                            " also no func keyword. funcKeyword is contained in statement
                            " funcKeyword allows overloading (func without body)
                            " funcImpl requires body
    1              0.000179 syntax cluster typescriptTopExpression
                              \ contains=@typescriptPrimitive,
                              \ typescriptIdentifier,typescriptIdentifierName,
                              \ typescriptOperator,typescriptUnaryOp,
                              \ typescriptParenExp,typescriptRegexpString,
                              \ typescriptGlobal,typescriptAsyncFuncKeyword,
                              \ typescriptClassKeyword,typescriptTypeCast

                            " no object literal, used in type cast and arrow func
                            " TODO: change func keyword to funcImpl
    1              0.000050 syntax cluster typescriptExpression
                              \ contains=@typescriptTopExpression,
                              \ typescriptArrowFuncDef,
                              \ typescriptFuncImpl

    1              0.000010 syntax cluster typescriptValue
                              \ contains=@typescriptExpression,typescriptObjectLiteral

    1              0.000108 syntax cluster typescriptEventExpression       contains=typescriptArrowFuncDef,typescriptParenExp,@typescriptValue,typescriptRegexpString,@typescriptEventTypes,typescriptOperator,typescriptGlobal,jsxRegion

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/basic/function.vim
Sourced 1 time
Total time:   0.001677
 Self time:   0.001677

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000001 endif

    1              0.000020 syntax keyword typescriptAsyncFuncKeyword      async
                              \ nextgroup=typescriptFuncKeyword,typescriptArrowFuncDef
                              \ skipwhite

    1              0.000009 syntax keyword typescriptAsyncFuncKeyword      await
                              \ nextgroup=@typescriptValue
                              \ skipwhite

    1              0.000074 syntax keyword typescriptFuncKeyword           function
                              \ nextgroup=typescriptAsyncFunc,typescriptFuncName,@typescriptCallSignature
                              \ skipwhite skipempty

    1              0.000016 syntax match   typescriptAsyncFunc             contained /*/
                              \ nextgroup=typescriptFuncName,@typescriptCallSignature
                              \ skipwhite skipempty

    1              0.000010 syntax match   typescriptFuncName              contained /\K\k*/
                              \ nextgroup=@typescriptCallSignature
                              \ skipwhite

    1              0.000060 syntax match   typescriptArrowFuncDef          contained /\K\k*\s*=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty

    1              0.000055 syntax match   typescriptArrowFuncDef          contained /(\%(\_[^()]\+\|(\_[^()]*)\)*)\_s*=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty

    1              0.000069 syntax region  typescriptArrowFuncDef          contained start=/(\%(\_[^()]\+\|(\_[^()]*)\)*):/ end=/=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc,typescriptTypeAnnotation
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty keepend

    1              0.000015 syntax match   typescriptArrowFunc             /=>/
    1              0.000005 syntax match   typescriptArrowFuncArg          contained /\K\k*/
    1              0.000015 syntax region  typescriptArrowFuncArg          contained start=/<\|(/ end=/\ze=>/ contains=@typescriptCallSignature

    1              0.000035 syntax region typescriptReturnAnnotation contained start=/:/ end=/{/me=e-1 contains=@typescriptType nextgroup=typescriptBlock


    1              0.000019 syntax region typescriptFuncImpl contained start=/function\>/ end=/{/me=e-1
                              \ contains=typescriptFuncKeyword
                              \ nextgroup=typescriptBlock

    1              0.000048 syntax cluster typescriptCallImpl contains=typescriptGenericImpl,typescriptParamImpl
    1              0.000044 syntax region typescriptGenericImpl matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/ skip=/\s*,\s*/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptParamImpl
                              \ contained skipwhite
    1              0.000043 syntax region typescriptParamImpl matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptDecorator,@typescriptParameterList,@typescriptComments
                              \ nextgroup=typescriptReturnAnnotation,typescriptBlock
                              \ contained skipwhite skipnl

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/basic/decorator.vim
Sourced 1 time
Total time:   0.001235
 Self time:   0.001235

count  total (s)   self (s)
    1              0.000022 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000083 syntax match typescriptDecorator /@\([_$a-zA-Z][_$a-zA-Z0-9]*\.\)*[_$a-zA-Z][_$a-zA-Z0-9]*\>/
                              \ nextgroup=typescriptFuncCallArg,typescriptTypeArguments
                              \ contains=@_semantic,typescriptDotNotation

SCRIPT  /usr/local/Cellar/neovim/HEAD-759a054/share/nvim/runtime/syntax/typescriptreact.vim
Sourced 1 time
Total time:   0.001083
 Self time:   0.001083

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     TypeScript with React (JSX)
                            " Maintainer:   Bram Moolenaar
                            " Last Change:	2019 Nov 30
                            " Based On:     Herrington Darkholme's yats.vim
                            " Changes:      See https:github.com/HerringtonDarkholme/yats.vim
                            " Credits:      See yats.vim on github

    1              0.000016 if !exists("main_syntax")
    1              0.000006   if exists("b:current_syntax")
    1              0.000003     finish
                              endif
                              let main_syntax = 'typescriptreact'
                            endif

                            let s:cpo_save = &cpo
                            set cpo&vim

                            syntax region tsxTag
                                  \ start=+<\([^/!?<>="':]\+\)\@=+
                                  \ skip=+</[^ /!?<>"']\+>+
                                  \ end=+/\@<!>+
                                  \ end=+\(/>\)\@=+
                                  \ contained
                                  \ contains=tsxTagName,tsxIntrinsicTagName,tsxAttrib,tsxEscJs,
                                            \tsxCloseString,@tsxComment

                            syntax match tsxTag /<>/ contained


                            " <tag></tag>
                            " s~~~~~~~~~e
                            " and self close tag
                            " <tag/>
                            " s~~~~e
                            " A big start regexp borrowed from https://git.io/vDyxc
                            syntax region tsxRegion
                                  \ start=+<\_s*\z([a-zA-Z1-9\$_-]\+\(\.\k\+\)*\)+
                                  \ skip=+<!--\_.\{-}-->+
                                  \ end=+</\_s*\z1>+
                                  \ matchgroup=tsxCloseString end=+/>+
                                  \ fold
                                  \ contains=tsxRegion,tsxCloseString,tsxCloseTag,tsxTag,tsxCommentInvalid,tsxFragment,tsxEscJs,@Spell
                                  \ keepend
                                  \ extend

                            " <>   </>
                            " s~~~~~~e
                            " A big start regexp borrowed from https://git.io/vDyxc
                            syntax region tsxFragment
                                  \ start=+\(\((\|{\|}\|\[\|,\|&&\|||\|?\|:\|=\|=>\|\Wreturn\|^return\|\Wdefault\|^\|>\)\_s*\)\@<=<>+
                                  \ skip=+<!--\_.\{-}-->+
                                  \ end=+</>+
                                  \ fold
                                  \ contains=tsxRegion,tsxCloseString,tsxCloseTag,tsxTag,tsxCommentInvalid,tsxFragment,tsxEscJs,@Spell
                                  \ keepend
                                  \ extend

                            " </tag>
                            " ~~~~~~
                            syntax match tsxCloseTag
                                  \ +</\_s*[^/!?<>"']\+>+
                                  \ contained
                                  \ contains=tsxTagName,tsxIntrinsicTagName

                            syntax match tsxCloseTag +</>+ contained

                            syntax match tsxCloseString
                                  \ +/>+
                                  \ contained

                            " <!-- -->
                            " ~~~~~~~~
                            syntax match tsxCommentInvalid /<!--\_.\{-}-->/ display

                            syntax region tsxBlockComment
                                \ contained
                                \ start="/\*"
                                \ end="\*/"

                            syntax match tsxLineComment
                                \ "//.*$"
                                \ contained
                                \ display

                            syntax cluster tsxComment contains=tsxBlockComment,tsxLineComment

                            syntax match tsxEntity "&[^; \t]*;" contains=tsxEntityPunct
                            syntax match tsxEntityPunct contained "[&.;]"

                            " <tag key={this.props.key}>
                            "  ~~~
                            syntax match tsxTagName
                                \ +[</]\_s*[^/!?<>"'* ]\++hs=s+1
                                \ contained
                                \ nextgroup=tsxAttrib
                                \ skipwhite
                                \ display
                            syntax match tsxIntrinsicTagName
                                \ +[</]\_s*[a-z1-9-]\++hs=s+1
                                \ contained
                                \ nextgroup=tsxAttrib
                                \ skipwhite
                                \ display

                            " <tag key={this.props.key}>
                            "      ~~~
                            syntax match tsxAttrib
                                \ +[a-zA-Z_][-0-9a-zA-Z_]*+
                                \ nextgroup=tsxEqual skipwhite
                                \ contained
                                \ display

                            " <tag id="sample">
                            "        ~
                            syntax match tsxEqual +=+ display contained
                              \ nextgroup=tsxString skipwhite

                            " <tag id="sample">
                            "         s~~~~~~e
                            syntax region tsxString contained start=+"+ end=+"+ contains=tsxEntity,@Spell display

                            " <tag key={this.props.key}>
                            "          s~~~~~~~~~~~~~~e
                            syntax region tsxEscJs
                                \ contained
                                \ contains=@typescriptValue,@tsxComment
                                \ matchgroup=typescriptBraces
                                \ start=+{+
                                \ end=+}+
                                \ extend


                            """""""""""""""""""""""""""""""""""""""""""""""""""
                            " Source the part common with typescriptreact.vim
                            source <sfile>:h/typescriptcommon.vim


                            syntax cluster typescriptExpression add=tsxRegion,tsxFragment

                            hi def link tsxTag htmlTag
                            hi def link tsxTagName Function
                            hi def link tsxIntrinsicTagName htmlTagName
                            hi def link tsxString String
                            hi def link tsxNameSpace Function
                            hi def link tsxCommentInvalid Error
                            hi def link tsxBlockComment Comment
                            hi def link tsxLineComment Comment
                            hi def link tsxAttrib Type
                            hi def link tsxEscJs tsxEscapeJs
                            hi def link tsxCloseTag htmlTag
                            hi def link tsxCloseString Identifier

                            let b:current_syntax = "typescriptreact"
                            if main_syntax == 'typescriptreact'
                              unlet main_syntax
                            endif

                            let &cpo = s:cpo_save
                            unlet s:cpo_save

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/after/syntax/typescriptreact.vim
Sourced 1 time
Total time:   0.008789
 Self time:   0.001468

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'jsx')
                              finish
    1              0.000001 endif

    1   0.007530   0.000209 source <sfile>:h/tsx.vim

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/after/syntax/tsx.vim
Sourced 1 time
Total time:   0.007278
 Self time:   0.003750

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'jsx')
                              finish
    1              0.000001 endif

                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Vim syntax file
                            "
                            " Language: javascript.jsx
                            " Maintainer: MaxMellon <maxmellon1994@gmail.com>
                            " Depends:  leafgarland/typescript-vim
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    1              0.000006 if get(g:, 'vim_jsx_pretty_disable_tsx', 0)
                              finish
    1              0.000001 endif

    1              0.000012 let s:jsx_cpo = &cpo
    1              0.000013 set cpo&vim

    1              0.000003 syntax case match

    1              0.000005 if exists('b:current_syntax')
    1              0.000004   let s:current_syntax = b:current_syntax
    1              0.000003   unlet b:current_syntax
    1              0.000001 endif

    1              0.000004 if exists('s:current_syntax')
    1              0.000004   let b:current_syntax = s:current_syntax
    1              0.000001 endif

                            " refine the typescript line comment
    1              0.000036 syntax region typescriptLineComment start=+//+ end=/$/ contains=@Spell,typescriptCommentTodo,typescriptRef extend keepend

    3              0.000017 for syntax_name in ['tsxRegion', 'tsxFragment']
    2              0.000014   if hlexists(syntax_name)
    2              0.000145     exe 'syntax clear ' . syntax_name
    2              0.000003   endif
    3              0.000004 endfor

    1              0.000004 if !hlexists('typescriptTypeCast')
                              " add a typescriptBlock group for typescript
                              syntax region typescriptBlock
                                    \ matchgroup=typescriptBraces
                                    \ start="{"
                                    \ end="}"
                                    \ contained
                                    \ extend
                                    \ contains=@typescriptExpression,typescriptBlock
                                    \ fold
                              hi def link typescriptTypeBrackets typescriptOpSymbols
    1              0.000001 endif

    1   0.005508   0.001980 runtime syntax/jsx_pretty.vim
    1              0.000033 syntax cluster typescriptExpression add=jsxRegion,typescriptParens
                            " Fix type casting ambiguity with JSX syntax
    1              0.000009 syntax match typescriptTypeBrackets +[<>]+ contained
    1              0.000029 syntax match typescriptTypeCast +<\([_$A-Za-z0-9]\+\)>\%(\s*\%([_$A-Za-z0-9]\+\s*;\?\|(\)\%(\_[^<]*</\1>\)\@!\)\@=+ contains=typescriptTypeBrackets,@typescriptType,typescriptType nextgroup=@typescriptExpression

    1              0.000005 let b:current_syntax = 'typescript.tsx'

    1              0.000016 let &cpo = s:jsx_cpo
    1              0.000006 unlet s:jsx_cpo

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/after/syntax/jsx_pretty.vim
Sourced 1 time
Total time:   0.003484
 Self time:   0.003484

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'jsx')
                              finish
    1              0.000001 endif

    1              0.000011 let s:highlight_close_tag = get(g:, 'vim_jsx_pretty_highlight_close_tag', 0)

                            " detect jsx region
    1              0.000097 syntax region jsxRegion
                                  \ start=+\%(\%(\_[([,?:=+\-*/>{}]\|<\s\+\|&&\|||\|=>\|\<return\|\<default\|\<await\|\<yield\)\_s*\)\@<=<\_s*\%(>\|\z(\%(script\|\s*\<T\>\)\@!\<[_$A-Za-z][-:._$A-Za-z0-9]*\>\)\%(\_s*\%([-+*)\]}&|?,]\|/\%([/*]\|\_s*>\)\@!\)\)\@!\)+
                                  \ end=++
                                  \ contains=jsxElement

                            " <tag id="sample">
                            " ~~~~~~~~~~~~~~~~~
                            " and self close tag
                            " <tag id="sample"   />
                            " ~~~~~~~~~~~~~~~~~~~
    1              0.000253 syntax region jsxTag
                                  \ start=+<+
                                  \ matchgroup=jsxOpenPunct
                                  \ end=+>+
                                  \ matchgroup=NONE
                                  \ end=+\%(/\_s*>\)\@=+
                                  \ contained
                                  \ contains=jsxOpenTag,jsxAttrib,jsxExpressionBlock,jsxSpreadOperator,jsComment,@javascriptComments,javaScriptLineComment,javaScriptComment,typescriptLineComment,typescriptComment
                                  \ keepend
                                  \ extend
                                  \ skipwhite
                                  \ skipempty
                                  \ nextgroup=jsxCloseString

                            " <tag></tag>
                            " ~~~~~~~~~~~
                            " and fragment
                            " <></>
                            " ~~~~~
                            " and self close tag
                            " <tag />
                            " ~~~~~~~
    1              0.000077 syntax region jsxElement
                                  \ start=+<\_s*\%(>\|\${\|\z(\<[-:._$A-Za-z0-9]\+\>\)\)+
                                  \ end=+/\_s*>+
                                  \ end=+<\_s*/\_s*\z1\_s*>+
                                  \ contains=jsxElement,jsxTag,jsxExpressionBlock,jsxComment,jsxCloseTag,@Spell
                                  \ keepend
                                  \ extend
                                  \ contained
                                  \ fold

                            " <tag key={this.props.key}>
                            " ~~~~
                            " and fragment start tag
                            " <>
                            " ~~
    1              0.000086 exe 'syntax region jsxOpenTag
                                  \ matchgroup=jsxOpenPunct
                                  \ start=+<+
                                  \ end=+>+
                                  \ matchgroup=NONE
                                  \ end=+\>+
                                  \ contained
                                  \ contains=jsxTagName
                                  \ nextgroup=jsxAttrib
                                  \ skipwhite
                                  \ skipempty
                                  \ ' .(s:highlight_close_tag ? 'transparent' : '')


                            " <tag key={this.props.key}>
                            "          ~~~~~~~~~~~~~~~~
    1              0.000110 syntax region jsxExpressionBlock
                                  \ matchgroup=jsxBraces
                                  \ start=+{+
                                  \ end=+}+
                                  \ contained
                                  \ extend
                                  \ contains=@jsExpression,jsSpreadExpression,@javascriptExpression,javascriptSpreadOp,@javaScriptEmbededExpr,@typescriptExpression,typescriptObjectSpread,jsComment,@javascriptComments,javaScriptLineComment,javaScriptComment,typescriptLineComment,typescriptComment

                            " <foo.bar>
                            "     ~
    1              0.000025 syntax match jsxDot +\.+ contained

                            " <foo:bar>
                            "     ~
    1              0.000025 syntax match jsxNamespace +:+ contained

                            " <tag id="sample">
                            "        ~
    1              0.000051 syntax match jsxEqual +=+ contained skipwhite skipempty nextgroup=jsxString,jsxExpressionBlock,jsxRegion

                            " <tag />
                            "      ~~
    1              0.000009 syntax match jsxCloseString +/\_s*>+ contained

                            " </tag>
                            " ~~~~~~
                            " and fragment close tag
                            " </>
                            " ~~~
    1              0.000047 syntax region jsxCloseTag
                                  \ matchgroup=jsxClosePunct
                                  \ start=+<\_s*/+
                                  \ end=+>+
                                  \ contained
                                  \ contains=jsxTagName

                            " <tag key={this.props.key}>
                            "      ~~~
    1              0.000048 syntax match jsxAttrib
                                  \ +\<[_$A-Za-z][-:_$A-Za-z0-9]*\>+
                                  \ contained
                                  \ nextgroup=jsxEqual
                                  \ skipwhite
                                  \ skipempty
                                  \ contains=jsxAttribKeyword,jsxNamespace

                            " <MyComponent ...>
                            "  ~~~~~~~~~~~
                            " NOT
                            " <someCamel ...>
                            "      ~~~~~
    1              0.000038 exe 'syntax match jsxComponentName
                                  \ +\<[_$]\?[A-Z][-_$A-Za-z0-9]*\>+
                                  \ contained
                                  \ ' .(s:highlight_close_tag ? 'transparent' : '')

                            " <tag key={this.props.key}>
                            "  ~~~
    1              0.000059 exe 'syntax match jsxTagName
                                  \ +\<[-:._$A-Za-z0-9]\+\>+
                                  \ contained
                                  \ contains=jsxComponentName,jsxDot,jsxNamespace
                                  \ nextgroup=jsxAttrib
                                  \ skipempty
                                  \ skipwhite
                                  \ ' .(s:highlight_close_tag ? 'transparent' : '')

                            " <tag id="sample">
                            "         ~~~~~~~~
                            " and
                            " <tag id='sample'>
                            "         ~~~~~~~~
    1              0.000021 syntax region jsxString start=+\z(["']\)+  skip=+\\\\\|\\\z1\|\\\n+  end=+\z1+ extend contained contains=@Spell

    1              0.000010 let s:tags = get(g:, 'vim_jsx_pretty_template_tags', ['html', 'jsx'])
    1              0.000006 let s:enable_tagged_jsx = !empty(s:tags)

                            " add support to JSX inside the tagged template string
                            " https://github.com/developit/htm
    1              0.001141 if s:enable_tagged_jsx
    1              0.000151   exe 'syntax match jsxRegion +\%(' . join(s:tags, '\|') . '\)\%(\_s*`\)\@=+ contains=jsTemplateStringTag,jsTaggedTemplate,javascriptTagRef skipwhite skipempty nextgroup=jsxTaggedRegion'

    1              0.000041   syntax region jsxTaggedRegion
                                    \ matchgroup=jsxBackticks
                                    \ start=+`+
                                    \ end=+`+
                                    \ extend
                                    \ contained
                                    \ contains=jsxElement,jsxExpressionBlock
                                    \ transparent

    1              0.000054   syntax region jsxExpressionBlock
                                    \ matchgroup=jsxBraces
                                    \ start=+\${+
                                    \ end=+}+
                                    \ extend
                                    \ contained
                                    \ contains=@jsExpression,jsSpreadExpression,@javascriptExpression,javascriptSpreadOp,@javaScriptEmbededExpr,@typescriptExpression,typescriptObjectSpread

    1              0.000053   syntax region jsxOpenTag
                                    \ matchgroup=jsxOpenPunct
                                    \ start=+<\%(\${\)\@=+
                                    \ matchgroup=NONE
                                    \ end=+}\@1<=+
                                    \ contained
                                    \ contains=jsxExpressionBlock
                                    \ skipwhite
                                    \ skipempty
                                    \ nextgroup=jsxAttrib,jsxSpreadOperator

    1              0.000005   syntax keyword jsxAttribKeyword class contained

    1              0.000008   syntax match jsxSpreadOperator +\.\.\.+ contained nextgroup=jsxExpressionBlock skipwhite

    1              0.000015   syntax match jsxCloseTag +<//>+ contained

    1              0.000007   syntax match jsxComment +<!--\_.\{-}-->+
    1              0.000002 endif

                            " Highlight the tag name
    1              0.000021 highlight def link jsxTag Function
    1              0.000031 highlight def link jsxTagName Identifier
    1              0.000020 highlight def link jsxComponentName Function

    1              0.000031 highlight def link jsxAttrib Type
    1              0.000014 highlight def link jsxAttribKeyword jsxAttrib
    1              0.000020 highlight def link jsxString String
    1              0.000020 highlight def link jsxComment Comment

    1              0.000021 highlight def link jsxDot Operator
    1              0.000021 highlight def link jsxNamespace Operator
    1              0.000021 highlight def link jsxEqual Operator
    1              0.000021 highlight def link jsxSpreadOperator Operator
    1              0.000020 highlight def link jsxBraces Special

    1              0.000003 if s:highlight_close_tag
                              highlight def link jsxCloseString Identifier
                              highlight def link jsxOpenPunct jsxTag
    1              0.000002 else
                              " Highlight the jsxCloseString (i.e. />), jsxPunct (i.e. <,>) and jsxCloseTag (i.e. <//>)
    1              0.000020   highlight def link jsxCloseString Comment
    1              0.000033   highlight def link jsxOpenPunct jsxPunct
    1              0.000001 endif

    1              0.000002 highlight def link jsxPunct jsxCloseString
    1              0.000013 highlight def link jsxClosePunct jsxPunct
    1              0.000003 highlight def link jsxCloseTag jsxCloseString

    1              0.000012 let s:vim_jsx_pretty_colorful_config = get(g:, 'vim_jsx_pretty_colorful_config', 0)

    1              0.000003 if s:vim_jsx_pretty_colorful_config == 1
                              highlight def link jsObjectKey Label
                              highlight def link jsArrowFuncArgs Type
                              highlight def link jsFuncArgs Type
    1              0.000008 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/after/syntax/typescriptreact/graphql.vim
Sourced 1 time
Total time:   0.013970
 Self time:   0.002007

count  total (s)   self (s)
    1              0.000022 if has_key(g:polyglot_is_disabled, 'graphql')
                              finish
    1              0.000001 endif

    1   0.012904   0.000941 runtime! after/syntax/typescript/graphql.vim

SCRIPT  /Users/philippe/.vim/plugged/vim-graphql/after/syntax/typescript/graphql.vim
Sourced 2 times
Total time:   0.010382
 Self time:   0.003770

count  total (s)   self (s)
                            " Copyright (c) 2016-2020 Jon Parise <jon@indelible.org>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to
                            " deal in the Software without restriction, including without limitation the
                            " rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                            " sell copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                            " FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
                            " IN THE SOFTWARE.
                            "
                            " Language: GraphQL
                            " Maintainer: Jon Parise <jon@indelible.org>

    2              0.000032 if exists('b:current_syntax')
    2              0.000014   let s:current_syntax = b:current_syntax
    2              0.000007   unlet b:current_syntax
    2              0.000003 endif

    2              0.000008 let b:graphql_nested_syntax = 1
    2   0.006876   0.001558 syn include @GraphQLSyntax syntax/graphql.vim
    2              0.000009 unlet b:graphql_nested_syntax

    2              0.000011 if exists('s:current_syntax')
    2              0.000010   let b:current_syntax = s:current_syntax
    2              0.000002 endif

    2   0.001733   0.000439 let s:tags = '\%(' . join(graphql#javascript_tags(), '\|') . '\)'

    2              0.000171 exec 'syntax region graphqlTemplateString matchgroup=typescriptTemplate start=+' . s:tags . '\@20<=`+ skip=+\\`+ end=+`+ contains=@GraphQLSyntax,typescriptTemplateSubstitution extend'
    2              0.000065 exec 'syntax match graphqlTaggedTemplate +' . s:tags . '\ze`+ nextgroup=graphqlTemplateString'

                            " Support expression interpolation ((${...})) inside template strings.
    2              0.000092 syntax region graphqlTemplateExpression start=+${+ end=+}+ contained contains=typescriptTemplateSubstitution containedin=graphqlFold keepend

    2              0.000013 hi def link graphqlTemplateString typescriptTemplate
    2              0.000027 hi def link graphqlTemplateExpression typescriptTemplateSubstitution

    2              0.000013 syn cluster typescriptExpression add=graphqlTaggedTemplate
    2              0.000017 syn cluster graphqlTaggedTemplate add=graphqlTemplateString

SCRIPT  /Users/philippe/.vim/plugged/vim-graphql/syntax/graphql.vim
Sourced 4 times
Total time:   0.005334
 Self time:   0.005334

count  total (s)   self (s)
                            " Copyright (c) 2016-2020 Jon Parise <jon@indelible.org>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to
                            " deal in the Software without restriction, including without limitation the
                            " rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                            " sell copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                            " FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
                            " IN THE SOFTWARE.
                            "
                            " Language: GraphQL
                            " Maintainer: Jon Parise <jon@indelible.org>

    4              0.000040 if exists('b:current_syntax')
                              finish
    4              0.000005 endif

    4              0.000010 syn case match

    4              0.000118 syn match graphqlComment    "#.*$" contains=@Spell

    4              0.000045 syn match graphqlOperator   "=" display
    4              0.000019 syn match graphqlOperator   "!" display
    4              0.000026 syn match graphqlOperator   "|" display
    4              0.000016 syn match graphqlOperator   "&" display
    4              0.000021 syn match graphqlOperator   "\M..." display

    4              0.000042 syn keyword graphqlBoolean  true false
    4              0.000035 syn keyword graphqlNull     null
    4              0.000090 syn match   graphqlNumber   "-\=\<\%(0\|[1-9]\d*\)\%(\.\d\+\)\=\%([eE][-+]\=\d\+\)\=\>" display
    4              0.000102 syn region  graphqlString   start=+"+  skip=+\\\\\|\\"+  end=+"\|$+
    4              0.000047 syn region  graphqlString   start=+"""+ skip=+\\"""+ end=+"""+

    4              0.000100 syn keyword graphqlKeyword on nextgroup=graphqlType,graphqlDirectiveLocation skipwhite

    4              0.000057 syn keyword graphqlStructure enum scalar type union nextgroup=graphqlType skipwhite
    4              0.000027 syn keyword graphqlStructure input interface subscription nextgroup=graphqlType skipwhite
    4              0.000022 syn keyword graphqlStructure implements nextgroup=graphqlType skipwhite
    4              0.000050 syn keyword graphqlStructure query mutation fragment nextgroup=graphqlName skipwhite
    4              0.000044 syn keyword graphqlStructure directive nextgroup=graphqlDirective skipwhite
    4              0.000021 syn keyword graphqlStructure extend nextgroup=graphqlStructure skipwhite
    4              0.000041 syn keyword graphqlStructure schema nextgroup=graphqlFold skipwhite

    4              0.000026 syn match graphqlDirective  "\<@\h\w*\>"   display
    4              0.000043 syn match graphqlVariable   "\<\$\h\w*\>"  display
    4              0.000026 syn match graphqlName       "\<\h\w*\>"    display
    4              0.000025 syn match graphqlType       "\<_*\u\w*\>"  display

                            " https://graphql.github.io/graphql-spec/June2018/#ExecutableDirectiveLocation
    4              0.000022 syn keyword graphqlDirectiveLocation QUERY MUTATION SUBSCRIPTION FIELD
    4              0.000017 syn keyword graphqlDirectiveLocation FRAGMENT_DEFINITION FRAGMENT_SPREAD
    4              0.000014 syn keyword graphqlDirectiveLocation INLINE_FRAGMENT
                            " https://graphql.github.io/graphql-spec/June2018/#TypeSystemDirectiveLocation
    4              0.000021 syn keyword graphqlDirectiveLocation SCHEMA SCALAR OBJECT FIELD_DEFINITION
    4              0.000016 syn keyword graphqlDirectiveLocation ARGUMENT_DEFINITION INTERFACE UNION
    4              0.000017 syn keyword graphqlDirectiveLocation ENUM ENUM_VALUE INPUT_OBJECT
    4              0.000012 syn keyword graphqlDirectiveLocation INPUT_FIELD_DEFINITION

    4              0.000041 syn keyword graphqlMetaFields __schema __type __typename

    4              0.000073 syn region  graphqlFold matchgroup=graphqlBraces start="{" end="}" transparent fold contains=ALLBUT,graphqlStructure
    4              0.000073 syn region  graphqlList matchgroup=graphqlBraces start="\[" end="]" transparent contains=ALLBUT,graphqlDirective,graphqlStructure

    4              0.000147 hi def link graphqlComment          Comment
    4              0.000095 hi def link graphqlOperator         Operator

    4              0.000088 hi def link graphqlBraces           Delimiter

    4              0.000084 hi def link graphqlBoolean          Boolean
    4              0.000083 hi def link graphqlNull             Keyword
    4              0.000088 hi def link graphqlNumber           Number
    4              0.000087 hi def link graphqlString           String

    4              0.000084 hi def link graphqlDirective        PreProc
    4              0.000085 hi def link graphqlDirectiveLocation Special
    4              0.000088 hi def link graphqlName             Identifier
    4              0.001200 hi def link graphqlMetaFields       Special
    4              0.000085 hi def link graphqlKeyword          Keyword
    4              0.000084 hi def link graphqlStructure        Structure
    4              0.000088 hi def link graphqlType             Type
    4              0.000088 hi def link graphqlVariable         Identifier

    4              0.000034 if !get(b:, 'graphql_nested_syntax')
    2              0.000007     syn sync minlines=500
    4              0.000005 endif

    4              0.000033 let b:current_syntax = 'graphql'

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/syntax/graphql.vim
Sourced 4 times
Total time:   0.001230
 Self time:   0.001230

count  total (s)   self (s)
    4              0.000054 if has_key(g:polyglot_is_disabled, 'graphql')
                              finish
    4              0.000005 endif

                            " Copyright (c) 2016-2020 Jon Parise <jon@indelible.org>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to
                            " deal in the Software without restriction, including without limitation the
                            " rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                            " sell copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                            " FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
                            " IN THE SOFTWARE.
                            "
                            " Language: GraphQL
                            " Maintainer: Jon Parise <jon@indelible.org>

    4              0.000020 if exists('b:current_syntax')
    4              0.000006   finish
                            endif

                            syn case match

                            syn match graphqlComment    "#.*$" contains=@Spell

                            syn match graphqlOperator   "=" display
                            syn match graphqlOperator   "!" display
                            syn match graphqlOperator   "|" display
                            syn match graphqlOperator   "&" display
                            syn match graphqlOperator   "\M..." display

                            syn keyword graphqlBoolean  true false
                            syn keyword graphqlNull     null
                            syn match   graphqlNumber   "-\=\<\%(0\|[1-9]\d*\)\%(\.\d\+\)\=\%([eE][-+]\=\d\+\)\=\>" display
                            syn region  graphqlString   start=+"+  skip=+\\\\\|\\"+  end=+"\|$+
                            syn region  graphqlString   start=+"""+ skip=+\\"""+ end=+"""+

                            syn keyword graphqlKeyword on nextgroup=graphqlType,graphqlDirectiveLocation skipwhite

                            syn keyword graphqlStructure enum scalar type union nextgroup=graphqlType skipwhite
                            syn keyword graphqlStructure input interface subscription nextgroup=graphqlType skipwhite
                            syn keyword graphqlStructure implements nextgroup=graphqlType skipwhite
                            syn keyword graphqlStructure query mutation fragment nextgroup=graphqlName skipwhite
                            syn keyword graphqlStructure directive nextgroup=graphqlDirective skipwhite
                            syn keyword graphqlStructure extend nextgroup=graphqlStructure skipwhite
                            syn keyword graphqlStructure schema nextgroup=graphqlFold skipwhite

                            syn match graphqlDirective  "\<@\h\w*\>"   display
                            syn match graphqlVariable   "\<\$\h\w*\>"  display
                            syn match graphqlName       "\<\h\w*\>"    display
                            syn match graphqlType       "\<_*\u\w*\>"  display

                            " https://graphql.github.io/graphql-spec/June2018/#ExecutableDirectiveLocation
                            syn keyword graphqlDirectiveLocation QUERY MUTATION SUBSCRIPTION FIELD
                            syn keyword graphqlDirectiveLocation FRAGMENT_DEFINITION FRAGMENT_SPREAD
                            syn keyword graphqlDirectiveLocation INLINE_FRAGMENT
                            " https://graphql.github.io/graphql-spec/June2018/#TypeSystemDirectiveLocation
                            syn keyword graphqlDirectiveLocation SCHEMA SCALAR OBJECT FIELD_DEFINITION
                            syn keyword graphqlDirectiveLocation ARGUMENT_DEFINITION INTERFACE UNION
                            syn keyword graphqlDirectiveLocation ENUM ENUM_VALUE INPUT_OBJECT
                            syn keyword graphqlDirectiveLocation INPUT_FIELD_DEFINITION

                            syn keyword graphqlMetaFields __schema __type __typename

                            syn region  graphqlFold matchgroup=graphqlBraces start="{" end="}" transparent fold contains=ALLBUT,graphqlStructure
                            syn region  graphqlList matchgroup=graphqlBraces start="\[" end="]" transparent contains=ALLBUT,graphqlDirective,graphqlStructure

                            hi def link graphqlComment          Comment
                            hi def link graphqlOperator         Operator

                            hi def link graphqlBraces           Delimiter

                            hi def link graphqlBoolean          Boolean
                            hi def link graphqlNull             Keyword
                            hi def link graphqlNumber           Number
                            hi def link graphqlString           String

                            hi def link graphqlDirective        PreProc
                            hi def link graphqlDirectiveLocation Special
                            hi def link graphqlName             Identifier
                            hi def link graphqlMetaFields       Special
                            hi def link graphqlKeyword          Keyword
                            hi def link graphqlStructure        Structure
                            hi def link graphqlType             Type
                            hi def link graphqlVariable         Identifier

                            syn sync minlines=500

                            let b:current_syntax = 'graphql'

SCRIPT  /Users/philippe/.vim/plugged/vim-graphql/autoload/graphql.vim
Sourced 1 time
Total time:   0.001227
 Self time:   0.001227

count  total (s)   self (s)
                            " Copyright (c) 2016-2020 Jon Parise <jon@indelible.org>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to
                            " deal in the Software without restriction, including without limitation the
                            " rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                            " sell copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                            " FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
                            " IN THE SOFTWARE.
                            "
                            " Language: GraphQL
                            " Maintainer: Jon Parise <jon@indelible.org>

    1              0.000011 function! graphql#has_syntax_group(group) abort
                              try
                                silent execute 'silent highlight ' . a:group
                              catch
                                return v:false
                              endtry
                              return v:true
                            endfunction

    1              0.000003 function! graphql#javascript_tags() abort
                              return get(g:, 'graphql_javascript_tags', ['gql', 'graphql', 'Relay.QL'])
                            endfunction

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/after/syntax/typescript/graphql.vim
Sourced 2 times
Total time:   0.004793
 Self time:   0.003347

count  total (s)   self (s)
    2              0.000039 if has_key(g:polyglot_is_disabled, 'graphql')
                              finish
    2              0.000003 endif

                            " Copyright (c) 2016-2020 Jon Parise <jon@indelible.org>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to
                            " deal in the Software without restriction, including without limitation the
                            " rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                            " sell copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                            " FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
                            " IN THE SOFTWARE.
                            "
                            " Language: GraphQL
                            " Maintainer: Jon Parise <jon@indelible.org>

    2              0.000011 if exists('b:current_syntax')
    2              0.000012   let s:current_syntax = b:current_syntax
    2              0.000006   unlet b:current_syntax
    2              0.000002 endif
    2   0.002842   0.001416 syn include @GraphQLSyntax syntax/graphql.vim
    2              0.000012 if exists('s:current_syntax')
    2              0.000009   let b:current_syntax = s:current_syntax
    2              0.000002 endif

    2   0.000127   0.000107 let s:tags = '\%(' . join(graphql#javascript_tags(), '\|') . '\)'

    2              0.000123 exec 'syntax region graphqlTemplateString matchgroup=typescriptTemplate start=+' . s:tags . '\@20<=`+ skip=+\\`+ end=+`+ contains=@GraphQLSyntax,typescriptTemplateSubstitution extend'
    2              0.000036 exec 'syntax match graphqlTaggedTemplate +' . s:tags . '\ze`+ nextgroup=graphqlTemplateString'

                            " Support expression interpolation ((${...})) inside template strings.
    2              0.000078 syntax region graphqlTemplateExpression start=+${+ end=+}+ contained contains=typescriptTemplateSubstitution containedin=graphqlFold keepend

    2              0.000012 hi def link graphqlTemplateString typescriptTemplate
    2              0.000027 hi def link graphqlTemplateExpression typescriptTemplateSubstitution

    2              0.000013 syn cluster typescriptExpression add=graphqlTaggedTemplate
    2              0.000017 syn cluster graphqlTaggedTemplate add=graphqlTemplateString

SCRIPT  /Users/philippe/.vim/plugged/vim-graphql/after/syntax/typescriptreact/graphql.vim
Sourced 1 time
Total time:   0.005395
 Self time:   0.002076

count  total (s)   self (s)
    1   0.004133   0.000814 runtime! after/syntax/typescript/graphql.vim

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/ftplugin/typescriptreact.vim
Sourced 1 time
Total time:   0.001160
 Self time:   0.001160

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

                            " modified from mxw/vim-jsx from html.vim
    1              0.000009 if exists("loaded_matchit") && !exists('b:tsx_match_words')
    1              0.000006   let b:match_ignorecase = 0
    1              0.000007   let b:tsx_match_words = '(:),\[:\],{:},<:>,' .
                                    \ '<\@<=\([^/][^ \t>]*\)[^>]*\%(/\@<!>\|$\):<\@<=/\1>'
    1              0.000010   let b:match_words = exists('b:match_words')
                                \ ? b:match_words . ',' . b:tsx_match_words
                                \ : b:tsx_match_words
    1              0.000001 endif

                            " Comment formatting
    1              0.000012 setlocal comments=s1:/*,mb:*,ex:*/,://
    1              0.000011 setlocal formatoptions-=t formatoptions+=croql

    1              0.000014 set suffixesadd+=.tsx

SCRIPT  /usr/local/Cellar/neovim/HEAD-759a054/share/nvim/runtime/ftplugin/typescriptreact.vim
Sourced 1 time
Total time:   0.006866
 Self time:   0.002124

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	TypeScript React
                            " Maintainer:	Doug Kearns <dougkearns@gmail.com>
                            " Last Change:	2020 Aug 09

    1              0.000012 let s:match_words = ""
    1              0.000003 let s:undo_ftplugin = ""

    1   0.005624   0.000881 runtime! ftplugin/typescript.vim

    1              0.000014 let s:cpo_save = &cpo
    1              0.000013 set cpo-=C

    1              0.000006 if exists("b:match_words")
    1              0.000004     let s:match_words = b:match_words
    1              0.000001 endif
    1              0.000004 if exists("b:undo_ftplugin")
                                let s:undo_ftplugin = b:undo_ftplugin
    1              0.000001 endif

                            " Matchit configuration
    1              0.000004 if exists("loaded_matchit")
    1              0.000003     let b:match_ignorecase = 0
    1              0.000011     let b:match_words = s:match_words .
                            		\	'<:>,' .
                            		\	'<\@<=\([^ \t>/]\+\)\%(\s\+[^>]*\%([^/]>\|$\)\|>\|$\):<\@<=/\1>,' .
                            		\	'<\@<=\%([^ \t>/]\+\)\%(\s\+[^/>]*\|$\):/>'
    1              0.000001 endif

    1              0.000005 let b:undo_ftplugin = "unlet! b:match_words b:match_ignorecase | " . s:undo_ftplugin

    1              0.000009 let &cpo = s:cpo_save
    1              0.000008 unlet s:cpo_save

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/ftplugin/typescript.vim
Sourced 1 time
Total time:   0.003451
 Self time:   0.002111

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

                            " set Vi-incompatible, compiler and commentstring

    1              0.000005 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
    1              0.000006 let b:did_ftplugin = 1

    1              0.000010 let s:cpo_save = &cpo
    1              0.000013 set cpo-=C

    1   0.002050   0.000710 compiler typescript
    1              0.000008 setlocal commentstring=//\ %s

                            " Set 'formatoptions' to break comment lines but not other lines,
                            " " and insert the comment leader when hitting <CR> or using "o".
    1              0.000010 setlocal formatoptions-=t formatoptions+=croql

    1              0.000004 if !&l:formatexpr && !&l:formatprg
    1              0.000005     setlocal formatexpr=Fixedgq(v:lnum,v:count)
    1              0.000001 endif

                            " setlocal foldmethod=syntax

    1              0.000012 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save

    1              0.000004 function! Fixedgq(lnum, count)
                                let l:tw = &tw ? &tw : 80

                                let l:count = a:count
                                let l:first_char = indent(a:lnum) + 1

                                if mode() == 'i' " gq was not pressed, but tw was set
                                    return 1
                                endif

                                " This gq is only meant to do code with strings, not comments
                                if yats#IsLineComment(a:lnum, l:first_char) || yats#IsInMultilineComment(a:lnum, l:first_char)
                                    return 1
                                endif

                                if len(getline(a:lnum)) < l:tw && l:count == 1 " No need for gq
                                    return 1
                                endif

                                " Put all the lines on one line and do normal spliting after that
                                if l:count > 1
                                    while l:count > 1
                                        let l:count -= 1
                                        normal! J
                                    endwhile
                                endif

                                let l:winview = winsaveview()

                                call cursor(a:lnum, l:tw + 1)
                                let orig_breakpoint = searchpairpos(' ', '', '\.', 'bcW', '', a:lnum)
                                call cursor(a:lnum, l:tw + 1)
                                let breakpoint = searchpairpos(' ', '', '\.', 'bcW', s:skip_expr, a:lnum)

                                " No need for special treatment, normal gq handles edgecases better
                                if breakpoint[1] == orig_breakpoint[1]
                                    call winrestview(l:winview)
                                    return 1
                                endif

                                " Try breaking after string
                                if breakpoint[1] <= indent(a:lnum)
                                    call cursor(a:lnum, l:tw + 1)
                                    let breakpoint = searchpairpos('\.', '', ' ', 'cW', s:skip_expr, a:lnum)
                                endif


                                if breakpoint[1] != 0
                                    call feedkeys("r\<CR>")
                                else
                                    let l:count = l:count - 1
                                endif

                                " run gq on new lines
                                if l:count == 1
                                    call feedkeys("gqq")
                                endif

                                return 0
                            endfunction

    1              0.000003 function! TsIncludeExpr(file)
                              if (filereadable(a:file))
                                return l:file
                              else
                                let l:file2=substitute(a:file,'$','/index.ts','g')
                                return l:file2
                              endif
                            endfunction

    1              0.000008 set path+=./node_modules/**,node_modules/**
    1              0.000005 set include=import\_s.\\zs[^'\"]*\\ze
    1              0.000005 set includeexpr=TsIncludeExpr(v:fname)
    1              0.000005 set suffixesadd+=.ts

                            "
                            " TagBar
                            "
    1              0.000049 let g:tagbar_type_typescript = {
                                \ 'ctagstype' : 'typescript',
                                \ 'kinds'     : [
                                  \ 'c:classes',
                                  \ 'a:abstract classes',
                                  \ 't:types',
                                  \ 'n:modules',
                                  \ 'f:functions',
                                  \ 'v:variables',
                                  \ 'l:varlambdas',
                                  \ 'm:members',
                                  \ 'i:interfaces',
                                  \ 'e:enums'
                                \ ],
                                \ 'sro'        : '.',
                                \ 'kind2scope' : {
                                  \ 'c' : 'classes',
                                  \ 'a' : 'abstract classes',
                                  \ 't' : 'types',
                                  \ 'f' : 'functions',
                                  \ 'v' : 'variables',
                                  \ 'l' : 'varlambdas',
                                  \ 'm' : 'members',
                                  \ 'i' : 'interfaces',
                                  \ 'e' : 'enums'
                                \ },
                                \ 'scope2kind' : {
                                  \ 'classes'    : 'c',
                                  \ 'abstract classes'    : 'a',
                                  \ 'types'      : 't',
                                  \ 'functions'  : 'f',
                                  \ 'variables'  : 'v',
                                  \ 'varlambdas' : 'l',
                                  \ 'members'    : 'm',
                                  \ 'interfaces' : 'i',
                                  \ 'enums'      : 'e'
                                \ }
                            \ }

                            " In case you've updated/customized your ~/.ctags and prefer to use it.
    1              0.000006 if get(g:, 'typescript_use_builtin_tagbar_defs', 1)
    1              0.000034   let g:tagbar_type_typescript.deffile = expand('<sfile>:p:h:h') . '/ctags/typescript.ctags'
    1              0.000005 endif

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/compiler/typescript.vim
Sourced 1 time
Total time:   0.001295
 Self time:   0.001295

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1              0.000005 if exists('current_compiler')
                              finish
    1              0.000001 endif

    1              0.000010 let current_compiler='typescript'

    1              0.000005 if !exists('g:typescript_compiler_binary')
    1              0.000006   let g:typescript_compiler_binary = 'tsc'
    1              0.000001 endif

    1              0.000004 if !exists('g:typescript_compiler_options')
    1              0.000004   if exists('g:syntastic_typescript_tsc_args')
                                let g:typescript_compiler_options = g:syntastic_typescript_tsc_args
    1              0.000001   else
    1              0.000005     let g:typescript_compiler_options = ''
    1              0.000001   endif
    1              0.000001 endif

    1              0.000015 let &l:makeprg = g:typescript_compiler_binary . ' ' . g:typescript_compiler_options . ' $* %'

    1              0.000027 CompilerSet errorformat=%+A\ %#%f\ %#(%l\\\,%c):\ %m,%C%m

SCRIPT  /usr/local/Cellar/neovim/HEAD-759a054/share/nvim/runtime/ftplugin/typescript.vim
Sourced 1 time
Total time:   0.001148
 Self time:   0.001148

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	TypeScript
                            " Maintainer:	Doug Kearns <dougkearns@gmail.com>
                            " Last Change:	2019 Aug 30

    1              0.000016 if exists("b:did_ftplugin")
    1              0.000003   finish
                            endif
                            let b:did_ftplugin = 1

                            let s:cpo_save = &cpo
                            set cpo-=C

                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
                            setlocal formatoptions-=t formatoptions+=croql

                            " Set 'comments' to format dashed lists in comments.
                            setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://

                            setlocal commentstring=//%s

                            setlocal suffixesadd+=.ts,.d.ts,.tsx,.js,.jsx,.cjs,.mjs

                            " Change the :browse e filter to primarily show TypeScript-related files.
                            if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                                let  b:browsefilter="TypeScript Files (*.ts)\t*.ts\n" .
                            		\	"TypeScript Declaration Files (*.d.ts)\t*.d.ts\n" .
                            		\	"TSX Files (*.tsx)\t*.tsx\n" .
                            		\	"JavaScript Files (*.js)\t*.js\n" .
                            		\	"JavaScript Modules (*.es, *.cjs, *.mjs)\t*.es;*.cjs;*.mjs\n" .
                            		\	"JSON Files (*.json)\t*.json\n" .
                            		\	"All Files (*.*)\t*.*\n"
                            endif

                            let b:undo_ftplugin = "setl fo< com< cms< sua< | unlet! b:browsefilter"

                            let &cpo = s:cpo_save
                            unlet s:cpo_save

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/after/ftplugin/typescriptreact.vim
Sourced 1 time
Total time:   0.001353
 Self time:   0.000594

count  total (s)   self (s)
    1              0.000025 if has_key(g:polyglot_is_disabled, 'jsx')
                              finish
    1              0.000001 endif

    1   0.001014   0.000256 source <sfile>:h/tsx.vim

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/after/ftplugin/tsx.vim
Sourced 1 time
Total time:   0.000714
 Self time:   0.000714

count  total (s)   self (s)
    1              0.000025 if has_key(g:polyglot_is_disabled, 'jsx')
                              finish
    1              0.000002 endif

                            " modified from html.vim
                            " For matchit plugin

    1              0.000006 if get(g:, 'vim_jsx_pretty_disable_tsx', 0)
                              finish
    1              0.000001 endif

    1              0.000005 if exists("loaded_matchit")
    1              0.000005   let b:match_ignorecase = 0
    1              0.000007   let b:match_words = '(:),\[:\],{:},<:>,' .
                                    \ '<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'
    1              0.000001 endif

                            " For andymass/vim-matchup plugin
    1              0.000004 if exists("loaded_matchup")
                              setlocal matchpairs=(:),{:},[:],<:>
                              let b:match_words = '<\@<=\([^/][^ \t>]*\)\g{hlend}[^>]*\%(/\@<!>\|$\):<\@<=/\1>'
                              let b:match_skip = 's:comment\|string'
    1              0.000001 endif

    1              0.000007 let b:jsx_pretty_old_cms = &l:commentstring

    1              0.000005 augroup jsx_comment
    1              0.000008   autocmd! CursorMoved <buffer>
    1              0.000006   autocmd CursorMoved <buffer> call jsx_pretty#comment#update_commentstring(b:jsx_pretty_old_cms)
    1              0.000001 augroup end

    1              0.000018 setlocal suffixesadd+=.tsx

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/indent/typescriptreact.vim
Sourced 1 time
Total time:   0.016049
 Self time:   0.003391

count  total (s)   self (s)
    1              0.000021 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    1              0.000002 endif

    1   0.011213   0.001546 exe 'runtime! indent/typescript.vim'
                            " Save the current JavaScript indentexpr.
    1              0.000008 let b:tsx_ts_indentexpr = &indentexpr

                            " Prologue; load in XML indentation.
    1              0.000006 if exists('b:did_indent')
    1              0.000004   let s:did_indent=b:did_indent
    1              0.000003   unlet b:did_indent
    1              0.000001 endif
    1   0.003687   0.000697 exe 'runtime! indent/xml.vim'
    1              0.000010 if exists('s:did_indent')
    1              0.000005   let b:did_indent=s:did_indent
    1              0.000002 endif

    1              0.000009 setlocal indentexpr=GetTsxIndent()

                            " JS indentkeys
    1              0.000006 setlocal indentkeys=0{,0},0),0],0\,,!^F,o,O,e
                            " XML indentkeys
    1              0.000005 setlocal indentkeys+=*<Return>,<>>,<<>,/

                            " Multiline end tag regex (line beginning with '>' or '/>')
    1              0.000004 let s:endtag = '^\s*\/\?>\s*;\='
    1              0.000003 let s:startexp = '[\{\(]\s*$'

                            " Get all syntax types at the beginning of a given line.
    1              0.000003 fu! SynSOL(lnum)
                              return map(synstack(a:lnum, 1), 'synIDattr(v:val, "name")')
                            endfu

                            " Get all syntax types at the end of a given line.
    1              0.000002 fu! SynEOL(lnum)
                              let lnum = prevnonblank(a:lnum)
                              let col = strlen(getline(lnum))
                              return map(synstack(lnum, col), 'synIDattr(v:val, "name")')
                            endfu

                            " Check if a syntax attribute is XMLish.
    1              0.000002 fu! SynAttrXMLish(synattr)
                              return a:synattr =~ "^xml" || a:synattr =~ "^tsx"
                            endfu

                            " Check if a synstack is XMLish (i.e., has an XMLish last attribute).
    1              0.000002 fu! SynXMLish(syns)
                              return SynAttrXMLish(get(a:syns, -1))
                            endfu

                            " Check if a synstack denotes the end of a TSX block.
    1              0.000002 fu! SynTSXBlockEnd(syns)
                              return get(a:syns, -1) =~ '\%(ts\|typescript\)Braces' &&
                                   \ SynAttrXMLish(get(a:syns, -2))
                            endfu

                            " Determine how many tsxRegions deep a synstack is.
    1              0.000002 fu! SynTSXDepth(syns)
                              return len(filter(copy(a:syns), 'v:val ==# "tsxRegion"'))
                            endfu

                            " Check whether `cursyn' continues the same tsxRegion as `prevsyn'.
    1              0.000002 fu! SynTSXContinues(cursyn, prevsyn)
                              let curdepth = SynTSXDepth(a:cursyn)
                              let prevdepth = SynTSXDepth(a:prevsyn)

                              " In most places, we expect the nesting depths to be the same between any
                              " two consecutive positions within a tsxRegion (e.g., between a parent and
                              " child node, between two TSX attributes, etc.).  The exception is between
                              " sibling nodes, where after a completed element (with depth N), we return
                              " to the parent's nesting (depth N - 1).  This case is easily detected,
                              " since it is the only time when the top syntax element in the synstack is
                              " tsxRegion---specifically, the tsxRegion corresponding to the parent.
                              return prevdepth == curdepth ||
                                  \ (prevdepth == curdepth + 1 && get(a:cursyn, -1) ==# 'tsxRegion')
                            endfu

                            " Cleverly mix JS and XML indentation.
    1              0.000002 fu! GetTsxIndent()
                              let cursyn  = SynSOL(v:lnum)
                              let prevsyn = SynEOL(v:lnum - 1)

                              " Use XML indenting iff:
                              "   - the syntax at the end of the previous line was either TSX or was the
                              "     closing brace of a jsBlock whose parent syntax was TSX; and
                              "   - the current line continues the same tsxRegion as the previous line.
                              if (SynXMLish(prevsyn) || SynTSXBlockEnd(prevsyn)) &&
                                    \ SynTSXContinues(cursyn, prevsyn)
                                let ind = XmlIndentGet(v:lnum, 0)
                                let l:line = getline(v:lnum)
                                let l:pline = getline(v:lnum - 1)

                                " Align '/>' and '>' with '<' for multiline tags.
                                " Align end of expression ')' or '}'.
                                if l:line =~? s:endtag
                                  let ind = ind - shiftwidth()
                                endif

                                " Then correct the indentation of any TSX following '/>' or '>'.
                                " Align start of expression '(' or '{'
                                if l:pline =~? s:endtag || l:pline =~? s:startexp
                                  let ind = ind + shiftwidth()
                                endif
                              else
                                if len(b:tsx_ts_indentexpr)
                                  " Invoke the base TS package's custom indenter
                                  let ind = eval(b:tsx_ts_indentexpr)
                                else
                                  let ind = cindent(v:lnum)
                                endif
                              endif

                              return ind
                            endfu
SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/indent/typescript.vim
Sourced 2 times
Total time:   0.001922
 Self time:   0.001922

count  total (s)   self (s)
    2              0.000033 if has_key(g:polyglot_is_disabled, 'typescript')
                              finish
    2              0.000003 endif

                            " Vim indent file
                            " Language: TypeScript
                            " Acknowledgement: Based off of vim-ruby maintained by Nikolai Weibull http://vim-ruby.rubyforge.org

                            " 0. Initialization {{{1
                            " =================

                            " Only load this indent file when no other was loaded.
    2              0.000010 if exists("b:did_indent")
    1              0.000001   finish
    1              0.000001 endif
    1              0.000005 let b:did_indent = 1

    1              0.000012 setlocal nosmartindent

                            " Now, set up our indentation expression and keys that trigger it.
    1              0.000008 setlocal indentexpr=GetTypescriptIndent()
    1              0.000006 setlocal indentkeys=0{,0},0),0],0\,,!^F,o,O,e

                            " Only define the function once.
    1              0.000006 if exists("*GetTypescriptIndent")
                              finish
    1              0.000001 endif

    1              0.000009 let s:cpo_save = &cpo
    1              0.000007 set cpo&vim

                            " 1. Variables {{{1
                            " ============

    1              0.000006 let s:js_keywords = '^\s*\(break\|case\|catch\|continue\|debugger\|default\|delete\|do\|else\|finally\|for\|function\|if\|in\|instanceof\|new\|return\|switch\|this\|throw\|try\|typeof\|var\|void\|while\|with\)'

                            " Regex of syntax group names that are or delimit string or are comments.
    1              0.000003 let s:syng_strcom = 'string\|regex\|comment\c'

                            " Regex of syntax group names that are strings.
    1              0.000002 let s:syng_string = 'regex\c'

                            " Expression used to check whether we should skip a match with searchpair().
    1              0.000006 let s:skip_expr = "synIDattr(synID(line('.'),col('.'),1),'name') =~ '".s:syng_strcom."'"

    1              0.000003 let s:line_term = '\s*\%(\%(\/\/\).*\)\=$'

                            " Regex that defines continuation lines, not including (, {, or [.
    1              0.000005 let s:continuation_regex = '\%([\\*+/.:]\|\%(<%\)\@<![=-]\|\W[|&?]\|||\|&&\|[^=]=[^=]\)' . s:line_term

                            " Regex that defines continuation lines.
                            " TODO: this needs to deal with if ...: and so on
    1              0.000003 let s:msl_regex = s:continuation_regex

    1              0.000005 let s:one_line_scope_regex = '\<\%(if\|else\|for\|while\)\>[^{;]*' . s:line_term

                            " Regex that defines blocks.
    1              0.000005 let s:block_regex = '\%([{[]\)\s*\%(|\%([*@]\=\h\w*,\=\s*\)\%(,\s*[*@]\=\h\w*\)*|\)\=' . s:line_term

    1              0.000002 let s:var_stmt = '^\s*var'

    1              0.000002 let s:comma_first = '^\s*,'
    1              0.000002 let s:comma_last = ',\s*$'

    1              0.000002 let s:ternary = '^\s\+[?:]'
    1              0.000003 let s:ternary_q = '^\s\+?[.?]\@!'

                            " 2. Auxiliary Functions {{{1
                            " ======================

                            " Check if the character at lnum:col is inside a string, comment, or is ascii.
    1              0.000005 function s:IsInStringOrComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_strcom
                            endfunction

                            " Check if the character at lnum:col is inside a string.
    1              0.000003 function s:IsInString(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_string
                            endfunction

                            " Find line above 'lnum' that isn't empty, in a comment, or in a string.
    1              0.000003 function s:PrevNonBlankNonString(lnum)
                              let in_block = 0
                              let lnum = prevnonblank(a:lnum)
                              while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
                                let line = getline(lnum)
                                if line =~ '/\*'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
                                elseif !in_block && line =~ '\*/'
                                  let in_block = 1
                                elseif !in_block && line !~ '^\s*\%(//\).*$' && !(s:IsInStringOrComment(lnum, 1) && s:IsInStringOrComment(lnum, strlen(line)))
                                  break
                                endif
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
                              return lnum
                            endfunction

                            " Find line above 'lnum' that started the continuation 'lnum' may be part of.
    1              0.000003 function s:GetMSL(lnum, in_one_line_scope)
                              " Start on the line we're at and use its indent.
                              let msl = a:lnum
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                              while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
                                let line = getline(lnum)
                                let col = match(line, s:msl_regex) + 1
                                if (col > 0 && !s:IsInStringOrComment(lnum, col)) || s:IsInString(lnum, strlen(line))
                                  let msl = lnum
                                else
                                  " Don't use lines that are part of a one line scope as msl unless the
                                  " flag in_one_line_scope is set to 1
                                  "
                                  if a:in_one_line_scope
                                    break
                                  end
                                  let msl_one_line = s:Match(lnum, s:one_line_scope_regex)
                                  if msl_one_line == 0
                                    break
                                  endif
                                endif
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                              return msl
                            endfunction

    1              0.000008 function s:RemoveTrailingComments(content)
                              let single = '\/\/\(.*\)\s*$'
                              let multi = '\/\*\(.*\)\*\/\s*$'
                              return substitute(substitute(a:content, single, '', ''), multi, '', '')
                            endfunction

                            " Find if the string is inside var statement (but not the first string)
    1              0.000003 function s:InMultiVarStatement(lnum)
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)

                            "  let type = synIDattr(synID(lnum, indent(lnum) + 1, 0), 'name')

                              " loop through previous expressions to find a var statement
                              while lnum > 0
                                let line = getline(lnum)

                                " if the line is a js keyword
                                if (line =~ s:js_keywords)
                                  " check if the line is a var stmt
                                  " if the line has a comma first or comma last then we can assume that we
                                  " are in a multiple var statement
                                  if (line =~ s:var_stmt)
                                    return lnum
                                  endif

                                  " other js keywords, not a var
                                  return 0
                                endif

                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile

                              " beginning of program, not a var
                              return 0
                            endfunction

                            " Find line above with beginning of the var statement or returns 0 if it's not
                            " this statement
    1              0.000003 function s:GetVarIndent(lnum)
                              let lvar = s:InMultiVarStatement(a:lnum)
                              let prev_lnum = s:PrevNonBlankNonString(a:lnum - 1)

                              if lvar
                                let line = s:RemoveTrailingComments(getline(prev_lnum))

                                " if the previous line doesn't end in a comma, return to regular indent
                                if (line !~ s:comma_last)
                                  return indent(prev_lnum) - shiftwidth()
                                else
                                  return indent(lvar) + shiftwidth()
                                endif
                              endif

                              return -1
                            endfunction


                            " Check if line 'lnum' has more opening brackets than closing ones.
    1              0.000003 function s:LineHasOpeningBrackets(lnum)
                              let open_0 = 0
                              let open_2 = 0
                              let open_4 = 0
                              let line = getline(a:lnum)
                              let pos = match(line, '[][(){}]', 0)
                              while pos != -1
                                if !s:IsInStringOrComment(a:lnum, pos + 1)
                                  let idx = stridx('(){}[]', line[pos])
                                  if idx % 2 == 0
                                    let open_{idx} = open_{idx} + 1
                                  else
                                    let open_{idx - 1} = open_{idx - 1} - 1
                                  endif
                                endif
                                let pos = match(line, '[][(){}]', pos + 1)
                              endwhile
                              return (open_0 > 0) . (open_2 > 0) . (open_4 > 0)
                            endfunction

    1              0.000002 function s:Match(lnum, regex)
                              let col = match(getline(a:lnum), a:regex) + 1
                              return col > 0 && !s:IsInStringOrComment(a:lnum, col) ? col : 0
                            endfunction

    1              0.000003 function s:IndentWithContinuation(lnum, ind, width)
                              " Set up variables to use and search for MSL to the previous line.
                              let p_lnum = a:lnum
                              let lnum = s:GetMSL(a:lnum, 1)
                              let line = getline(lnum)

                              " If the previous line wasn't a MSL and is continuation return its indent.
                              " TODO: the || s:IsInString() thing worries me a bit.
                              if p_lnum != lnum
                                if s:Match(p_lnum,s:continuation_regex)||s:IsInString(p_lnum,strlen(line))
                                  return a:ind
                                endif
                              endif

                              " Set up more variables now that we know we aren't continuation bound.
                              let msl_ind = indent(lnum)

                              " If the previous line ended with [*+/.-=], start a continuation that
                              " indents an extra level.
                              if s:Match(lnum, s:continuation_regex)
                                if lnum == p_lnum
                                  return msl_ind + a:width
                                else
                                  return msl_ind
                                endif
                              endif

                              return a:ind
                            endfunction

    1              0.000002 function s:InOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0 && s:Match(msl, s:one_line_scope_regex)
                                return msl
                              endif
                              return 0
                            endfunction

    1              0.000002 function s:ExitingOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0
                                " if the current line is in a one line scope ..
                                if s:Match(msl, s:one_line_scope_regex)
                                  return 0
                                else
                                  let prev_msl = s:GetMSL(msl - 1, 1)
                                  if s:Match(prev_msl, s:one_line_scope_regex)
                                    return prev_msl
                                  endif
                                endif
                              endif
                              return 0
                            endfunction

                            " 3. GetTypescriptIndent Function {{{1
                            " =========================

    1              0.000002 function GetTypescriptIndent()
                              " 3.1. Setup {{{2
                              " ----------

                              " Set up variables for restoring position in file.  Could use v:lnum here.
                              let vcol = col('.')

                              " 3.2. Work on the current line {{{2
                              " -----------------------------

                              let ind = -1
                              " Get the current line.
                              let line = getline(v:lnum)
                              " previous nonblank line number
                              let prevline = prevnonblank(v:lnum - 1)

                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
                              let col = matchend(line, '^\s*[],})]')
                              if col > 0 && !s:IsInStringOrComment(v:lnum, col)
                                call cursor(v:lnum, col)

                                let lvar = s:InMultiVarStatement(v:lnum)
                                if lvar
                                  let prevline_contents = s:RemoveTrailingComments(getline(prevline))

                                  " check for comma first
                                  if (line[col - 1] =~ ',')
                                    " if the previous line ends in comma or semicolon don't indent
                                    if (prevline_contents =~ '[;,]\s*$')
                                      return indent(s:GetMSL(line('.'), 0))
                                    " get previous line indent, if it's comma first return prevline indent
                                    elseif (prevline_contents =~ s:comma_first)
                                      return indent(prevline)
                                    " otherwise we indent 1 level
                                    else
                                      return indent(lvar) + shiftwidth()
                                    endif
                                  endif
                                endif


                                let bs = strpart('(){}[]', stridx(')}]', line[col - 1]) * 2, 2)
                                if searchpair(escape(bs[0], '\['), '', bs[1], 'bW', s:skip_expr) > 0
                                  if line[col-1]==')' && col('.') != col('$') - 1
                                    let ind = virtcol('.')-1
                                  else
                                    let ind = indent(s:GetMSL(line('.'), 0))
                                  endif
                                endif
                                return ind
                              endif

                              " If the line is comma first, dedent 1 level
                              if (getline(prevline) =~ s:comma_first)
                                return indent(prevline) - shiftwidth()
                              endif

                              if (line =~ s:ternary)
                                if (getline(prevline) =~ s:ternary_q)
                                  return indent(prevline)
                                else
                                  return indent(prevline) + shiftwidth()
                                endif
                              endif

                              " If we are in a multi-line comment, cindent does the right thing.
                              if yats#IsInMultilineComment(v:lnum, 1) && !yats#IsLineComment(v:lnum, 1)
                                return cindent(v:lnum)
                              endif

                              " Check for multiple var assignments
                            "  let var_indent = s:GetVarIndent(v:lnum)
                            "  if var_indent >= 0
                            "    return var_indent
                            "  endif

                              " 3.3. Work on the previous line. {{{2
                              " -------------------------------

                              " If the line is empty and the previous nonblank line was a multi-line
                              " comment, use that comment's indent. Deduct one char to account for the
                              " space in ' */'.
                              if line =~ '^\s*$' && s:IsInMultilineComment(prevline, 1)
                                return indent(prevline) - 1
                              endif

                              " Find a non-blank, non-multi-line string line above the current line.
                              let lnum = s:PrevNonBlankNonString(v:lnum - 1)

                              " If the line is empty and inside a string, use the previous line.
                              if line =~ '^\s*$' && lnum != prevline
                                return indent(prevnonblank(v:lnum))
                              endif

                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif

                              " Set up variables for current line.
                              let line = getline(lnum)
                              let ind = indent(lnum)

                              " If the previous line ended with a block opening, add a level of indent.
                              if s:Match(lnum, s:block_regex)
                                return indent(s:GetMSL(lnum, 0)) + shiftwidth()
                              endif

                              " If the previous line contained an opening bracket, and we are still in it,
                              " add indent depending on the bracket type.
                              if line =~ '[[({]'
                                let counts = s:LineHasOpeningBrackets(lnum)
                                if counts[0] == '1' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                  if col('.') + 1 == col('$')
                                    return ind + shiftwidth()
                                  else
                                    return virtcol('.')
                                  endif
                                elseif counts[1] == '1' || counts[2] == '1'
                                  return ind + shiftwidth()
                                else
                                  call cursor(v:lnum, vcol)
                                end
                              endif

                              " 3.4. Work on the MSL line. {{{2
                              " --------------------------

                              let ind_con = ind
                              let ind = s:IndentWithContinuation(lnum, ind_con, shiftwidth())

                              " }}}2
                              "
                              "
                              let ols = s:InOneLineScope(lnum)
                              if ols > 0
                                let ind = ind + shiftwidth()
                              else
                                let ols = s:ExitingOneLineScope(lnum)
                                while ols > 0 && ind > 0
                                  let ind = ind - shiftwidth()
                                  let ols = s:InOneLineScope(ols - 1)
                                endwhile
                              endif

                              return ind
                            endfunction

                            " }}}1

    1              0.000016 let &cpo = s:cpo_save
    1              0.000006 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/neovim/HEAD-759a054/share/nvim/runtime/indent/typescript.vim
Sourced 2 times
Total time:   0.001284
 Self time:   0.001284

count  total (s)   self (s)
                            " Vim indent file
                            " Language: TypeScript
                            " Maintainer: See https://github.com/HerringtonDarkholme/yats.vim
                            " Last Change: 2019 Oct 18
                            " Acknowledgement: Based off of vim-ruby maintained by Nikolai Weibull http://vim-ruby.rubyforge.org

                            " 0. Initialization {{{1
                            " =================

                            " Only load this indent file when no other was loaded.
    2              0.000026 if exists("b:did_indent")
    2              0.000005   finish
                            endif
                            let b:did_indent = 1

                            setlocal nosmartindent

                            " Now, set up our indentation expression and keys that trigger it.
                            setlocal indentexpr=GetTypescriptIndent()
                            setlocal formatexpr=Fixedgq(v:lnum,v:count)
                            setlocal indentkeys=0{,0},0),0],0\,,!^F,o,O,e

                            " Only define the function once.
                            if exists("*GetTypescriptIndent")
                              finish
                            endif

                            let s:cpo_save = &cpo
                            set cpo&vim

                            " 1. Variables {{{1
                            " ============

                            let s:js_keywords = '^\s*\(break\|case\|catch\|continue\|debugger\|default\|delete\|do\|else\|finally\|for\|function\|if\|in\|instanceof\|new\|return\|switch\|this\|throw\|try\|typeof\|var\|void\|while\|with\)'

                            " Regex of syntax group names that are or delimit string or are comments.
                            let s:syng_strcom = 'string\|regex\|comment\c'

                            " Regex of syntax group names that are strings.
                            let s:syng_string = 'regex\c'

                            " Regex of syntax group names that are strings or documentation.
                            let s:syng_multiline = 'comment\c'

                            " Regex of syntax group names that are line comment.
                            let s:syng_linecom = 'linecomment\c'

                            " Expression used to check whether we should skip a match with searchpair().
                            let s:skip_expr = "synIDattr(synID(line('.'),col('.'),1),'name') =~ '".s:syng_strcom."'"

                            let s:line_term = '\s*\%(\%(\/\/\).*\)\=$'

                            " Regex that defines continuation lines, not including (, {, or [.
                            let s:continuation_regex = '\%([\\*+/.:]\|\%(<%\)\@<![=-]\|\W[|&?]\|||\|&&\|[^=]=[^=].*,\)' . s:line_term

                            " Regex that defines continuation lines.
                            " TODO: this needs to deal with if ...: and so on
                            let s:msl_regex = s:continuation_regex

                            let s:one_line_scope_regex = '\<\%(if\|else\|for\|while\)\>[^{;]*' . s:line_term

                            " Regex that defines blocks.
                            let s:block_regex = '\%([{[]\)\s*\%(|\%([*@]\=\h\w*,\=\s*\)\%(,\s*[*@]\=\h\w*\)*|\)\=' . s:line_term

                            let s:var_stmt = '^\s*var'

                            let s:comma_first = '^\s*,'
                            let s:comma_last = ',\s*$'

                            let s:ternary = '^\s\+[?|:]'
                            let s:ternary_q = '^\s\+?'

                            " 2. Auxiliary Functions {{{1
                            " ======================

                            " Check if the character at lnum:col is inside a string, comment, or is ascii.
                            function s:IsInStringOrComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_strcom
                            endfunction

                            " Check if the character at lnum:col is inside a string.
                            function s:IsInString(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_string
                            endfunction

                            " Check if the character at lnum:col is inside a multi-line comment.
                            function s:IsInMultilineComment(lnum, col)
                              return !s:IsLineComment(a:lnum, a:col) && synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_multiline
                            endfunction

                            " Check if the character at lnum:col is a line comment.
                            function s:IsLineComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_linecom
                            endfunction

                            " Find line above 'lnum' that isn't empty, in a comment, or in a string.
                            function s:PrevNonBlankNonString(lnum)
                              let in_block = 0
                              let lnum = prevnonblank(a:lnum)
                              while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
                                let line = getline(lnum)
                                if line =~ '/\*'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
                                elseif !in_block && line =~ '\*/'
                                  let in_block = 1
                                elseif !in_block && line !~ '^\s*\%(//\).*$' && !(s:IsInStringOrComment(lnum, 1) && s:IsInStringOrComment(lnum, strlen(line)))
                                  break
                                endif
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
                              return lnum
                            endfunction

                            " Find line above 'lnum' that started the continuation 'lnum' may be part of.
                            function s:GetMSL(lnum, in_one_line_scope)
                              " Start on the line we're at and use its indent.
                              let msl = a:lnum
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                              while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
                                let line = getline(lnum)
                                let col = match(line, s:msl_regex) + 1
                                if (col > 0 && !s:IsInStringOrComment(lnum, col)) || s:IsInString(lnum, strlen(line))
                                  let msl = lnum
                                else
                                  " Don't use lines that are part of a one line scope as msl unless the
                                  " flag in_one_line_scope is set to 1
                                  "
                                  if a:in_one_line_scope
                                    break
                                  end
                                  let msl_one_line = s:Match(lnum, s:one_line_scope_regex)
                                  if msl_one_line == 0
                                    break
                                  endif
                                endif
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                              return msl
                            endfunction

                            function s:RemoveTrailingComments(content)
                              let single = '\/\/\(.*\)\s*$'
                              let multi = '\/\*\(.*\)\*\/\s*$'
                              return substitute(substitute(a:content, single, '', ''), multi, '', '')
                            endfunction

                            " Find if the string is inside var statement (but not the first string)
                            function s:InMultiVarStatement(lnum)
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)

                            "  let type = synIDattr(synID(lnum, indent(lnum) + 1, 0), 'name')

                              " loop through previous expressions to find a var statement
                              while lnum > 0
                                let line = getline(lnum)

                                " if the line is a js keyword
                                if (line =~ s:js_keywords)
                                  " check if the line is a var stmt
                                  " if the line has a comma first or comma last then we can assume that we
                                  " are in a multiple var statement
                                  if (line =~ s:var_stmt)
                                    return lnum
                                  endif

                                  " other js keywords, not a var
                                  return 0
                                endif

                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile

                              " beginning of program, not a var
                              return 0
                            endfunction

                            " Find line above with beginning of the var statement or returns 0 if it's not
                            " this statement
                            function s:GetVarIndent(lnum)
                              let lvar = s:InMultiVarStatement(a:lnum)
                              let prev_lnum = s:PrevNonBlankNonString(a:lnum - 1)

                              if lvar
                                let line = s:RemoveTrailingComments(getline(prev_lnum))

                                " if the previous line doesn't end in a comma, return to regular indent
                                if (line !~ s:comma_last)
                                  return indent(prev_lnum) - shiftwidth()
                                else
                                  return indent(lvar) + shiftwidth()
                                endif
                              endif

                              return -1
                            endfunction


                            " Check if line 'lnum' has more opening brackets than closing ones.
                            function s:LineHasOpeningBrackets(lnum)
                              let open_0 = 0
                              let open_2 = 0
                              let open_4 = 0
                              let line = getline(a:lnum)
                              let pos = match(line, '[][(){}]', 0)
                              while pos != -1
                                if !s:IsInStringOrComment(a:lnum, pos + 1)
                                  let idx = stridx('(){}[]', line[pos])
                                  if idx % 2 == 0
                                    let open_{idx} = open_{idx} + 1
                                  else
                                    let open_{idx - 1} = open_{idx - 1} - 1
                                  endif
                                endif
                                let pos = match(line, '[][(){}]', pos + 1)
                              endwhile
                              return (open_0 > 0) . (open_2 > 0) . (open_4 > 0)
                            endfunction

                            function s:Match(lnum, regex)
                              let col = match(getline(a:lnum), a:regex) + 1
                              return col > 0 && !s:IsInStringOrComment(a:lnum, col) ? col : 0
                            endfunction

                            function s:IndentWithContinuation(lnum, ind, width)
                              " Set up variables to use and search for MSL to the previous line.
                              let p_lnum = a:lnum
                              let lnum = s:GetMSL(a:lnum, 1)
                              let line = getline(lnum)

                              " If the previous line wasn't a MSL and is continuation return its indent.
                              " TODO: the || s:IsInString() thing worries me a bit.
                              if p_lnum != lnum
                                if s:Match(p_lnum,s:continuation_regex)||s:IsInString(p_lnum,strlen(line))
                                  return a:ind
                                endif
                              endif

                              " Set up more variables now that we know we aren't continuation bound.
                              let msl_ind = indent(lnum)

                              " If the previous line ended with [*+/.-=], start a continuation that
                              " indents an extra level.
                              if s:Match(lnum, s:continuation_regex)
                                if lnum == p_lnum
                                  return msl_ind + a:width
                                else
                                  return msl_ind
                                endif
                              endif

                              return a:ind
                            endfunction

                            function s:InOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0 && s:Match(msl, s:one_line_scope_regex)
                                return msl
                              endif
                              return 0
                            endfunction

                            function s:ExitingOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0
                                " if the current line is in a one line scope ..
                                if s:Match(msl, s:one_line_scope_regex)
                                  return 0
                                else
                                  let prev_msl = s:GetMSL(msl - 1, 1)
                                  if s:Match(prev_msl, s:one_line_scope_regex)
                                    return prev_msl
                                  endif
                                endif
                              endif
                              return 0
                            endfunction

                            " 3. GetTypescriptIndent Function {{{1
                            " =========================

                            function GetTypescriptIndent()
                              " 3.1. Setup {{{2
                              " ----------

                              " Set up variables for restoring position in file.  Could use v:lnum here.
                              let vcol = col('.')

                              " 3.2. Work on the current line {{{2
                              " -----------------------------

                              let ind = -1
                              " Get the current line.
                              let line = getline(v:lnum)
                              " previous nonblank line number
                              let prevline = prevnonblank(v:lnum - 1)

                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
                              let col = matchend(line, '^\s*[],})]')
                              if col > 0 && !s:IsInStringOrComment(v:lnum, col)
                                call cursor(v:lnum, col)

                                let lvar = s:InMultiVarStatement(v:lnum)
                                if lvar
                                  let prevline_contents = s:RemoveTrailingComments(getline(prevline))

                                  " check for comma first
                                  if (line[col - 1] =~ ',')
                                    " if the previous line ends in comma or semicolon don't indent
                                    if (prevline_contents =~ '[;,]\s*$')
                                      return indent(s:GetMSL(line('.'), 0))
                                    " get previous line indent, if it's comma first return prevline indent
                                    elseif (prevline_contents =~ s:comma_first)
                                      return indent(prevline)
                                    " otherwise we indent 1 level
                                    else
                                      return indent(lvar) + shiftwidth()
                                    endif
                                  endif
                                endif


                                let bs = strpart('(){}[]', stridx(')}]', line[col - 1]) * 2, 2)
                                if searchpair(escape(bs[0], '\['), '', bs[1], 'bW', s:skip_expr) > 0
                                  if line[col-1]==')' && col('.') != col('$') - 1
                                    let ind = virtcol('.')-1
                                  else
                                    let ind = indent(s:GetMSL(line('.'), 0))
                                  endif
                                endif
                                return ind
                              endif

                              " If the line is comma first, dedent 1 level
                              if (getline(prevline) =~ s:comma_first)
                                return indent(prevline) - shiftwidth()
                              endif

                              if (line =~ s:ternary)
                                if (getline(prevline) =~ s:ternary_q)
                                  return indent(prevline)
                                else
                                  return indent(prevline) + shiftwidth()
                                endif
                              endif

                              " If we are in a multi-line comment, cindent does the right thing.
                              if s:IsInMultilineComment(v:lnum, 1) && !s:IsLineComment(v:lnum, 1)
                                return cindent(v:lnum)
                              endif

                              " Check for multiple var assignments
                            "  let var_indent = s:GetVarIndent(v:lnum)
                            "  if var_indent >= 0
                            "    return var_indent
                            "  endif

                              " 3.3. Work on the previous line. {{{2
                              " -------------------------------

                              " If the line is empty and the previous nonblank line was a multi-line
                              " comment, use that comment's indent. Deduct one char to account for the
                              " space in ' */'.
                              if line =~ '^\s*$' && s:IsInMultilineComment(prevline, 1)
                                return indent(prevline) - 1
                              endif

                              " Find a non-blank, non-multi-line string line above the current line.
                              let lnum = s:PrevNonBlankNonString(v:lnum - 1)

                              " If the line is empty and inside a string, use the previous line.
                              if line =~ '^\s*$' && lnum != prevline
                                return indent(prevnonblank(v:lnum))
                              endif

                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif

                              " Set up variables for current line.
                              let line = getline(lnum)
                              let ind = indent(lnum)

                              " If the previous line ended with a block opening, add a level of indent.
                              if s:Match(lnum, s:block_regex)
                                return indent(s:GetMSL(lnum, 0)) + shiftwidth()
                              endif

                              " If the previous line contained an opening bracket, and we are still in it,
                              " add indent depending on the bracket type.
                              if line =~ '[[({]'
                                let counts = s:LineHasOpeningBrackets(lnum)
                                if counts[0] == '1' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                  if col('.') + 1 == col('$')
                                    return ind + shiftwidth()
                                  else
                                    return virtcol('.')
                                  endif
                                elseif counts[1] == '1' || counts[2] == '1'
                                  return ind + shiftwidth()
                                else
                                  call cursor(v:lnum, vcol)
                                end
                              endif

                              " 3.4. Work on the MSL line. {{{2
                              " --------------------------

                              let ind_con = ind
                              let ind = s:IndentWithContinuation(lnum, ind_con, shiftwidth())

                              " }}}2
                              "
                              "
                              let ols = s:InOneLineScope(lnum)
                              if ols > 0
                                let ind = ind + shiftwidth()
                              else
                                let ols = s:ExitingOneLineScope(lnum)
                                while ols > 0 && ind > 0
                                  let ind = ind - shiftwidth()
                                  let ols = s:InOneLineScope(ols - 1)
                                endwhile
                              endif

                              return ind
                            endfunction

                            " }}}1

                            let &cpo = s:cpo_save
                            unlet s:cpo_save

                            function! Fixedgq(lnum, count)
                                let l:tw = &tw ? &tw : 80

                                let l:count = a:count
                                let l:first_char = indent(a:lnum) + 1

                                if mode() == 'i' " gq was not pressed, but tw was set
                                    return 1
                                endif

                                " This gq is only meant to do code with strings, not comments
                                if s:IsLineComment(a:lnum, l:first_char) || s:IsInMultilineComment(a:lnum, l:first_char)
                                    return 1
                                endif

                                if len(getline(a:lnum)) < l:tw && l:count == 1 " No need for gq
                                    return 1
                                endif

                                " Put all the lines on one line and do normal spliting after that
                                if l:count > 1
                                    while l:count > 1
                                        let l:count -= 1
                                        normal J
                                    endwhile
                                endif

                                let l:winview = winsaveview()

                                call cursor(a:lnum, l:tw + 1)
                                let orig_breakpoint = searchpairpos(' ', '', '\.', 'bcW', '', a:lnum)
                                call cursor(a:lnum, l:tw + 1)
                                let breakpoint = searchpairpos(' ', '', '\.', 'bcW', s:skip_expr, a:lnum)

                                " No need for special treatment, normal gq handles edgecases better
                                if breakpoint[1] == orig_breakpoint[1]
                                    call winrestview(l:winview)
                                    return 1
                                endif

                                " Try breaking after string
                                if breakpoint[1] <= indent(a:lnum)
                                    call cursor(a:lnum, l:tw + 1)
                                    let breakpoint = searchpairpos('\.', '', ' ', 'cW', s:skip_expr, a:lnum)
                                endif


                                if breakpoint[1] != 0
                                    call feedkeys("r\<CR>")
                                else
                                    let l:count = l:count - 1
                                endif

                                " run gq on new lines
                                if l:count == 1
                                    call feedkeys("gqq")
                                endif

                                return 0
                            endfunction

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/after/indent/typescript.vim
Sourced 2 times
Total time:   0.005074
 Self time:   0.002382

count  total (s)   self (s)
    2              0.000033 if has_key(g:polyglot_is_disabled, 'graphql')
                              finish
    2              0.000003 endif

                            " Copyright (c) 2016-2020 Jon Parise <jon@indelible.org>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to
                            " deal in the Software without restriction, including without limitation the
                            " rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                            " sell copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                            " FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
                            " IN THE SOFTWARE.
                            "
                            " Language: GraphQL
                            " Maintainer: Jon Parise <jon@indelible.org>

    2              0.000020 if exists('*GetTypescriptGraphQLIndent') && !empty(&indentexpr)
    1              0.000001   finish
    1              0.000001 endif

    1   0.003585   0.000894 runtime! indent/graphql.vim

                            " Set the indentexpr with our own version that will call GetGraphQLIndent when
                            " we're inside of a GraphQL string and otherwise defer to the base function.
    1              0.000009 let b:indentexpr_base = &indentexpr
    1              0.000011 setlocal indentexpr=GetTypescriptGraphQLIndent()

    1              0.000005 function GetTypescriptGraphQLIndent()
                              let l:stack = map(synstack(v:lnum, 1), "synIDattr(v:val, 'name')")
                              if get(l:stack, 0, '') ==# 'graphqlTemplateString'
                                return GetGraphQLIndent()
                              endif

                              return eval(b:indentexpr_base)
                            endfunction

SCRIPT  /Users/philippe/.vim/plugged/vim-graphql/indent/graphql.vim
Sourced 1 time
Total time:   0.001308
 Self time:   0.001308

count  total (s)   self (s)
                            " Copyright (c) 2016-2020 Jon Parise <jon@indelible.org>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to
                            " deal in the Software without restriction, including without limitation the
                            " rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                            " sell copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                            " FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
                            " IN THE SOFTWARE.
                            "
                            " Language: GraphQL
                            " Maintainer: Jon Parise <jon@indelible.org>

                            " Set our local options if indentation hasn't already been set up.
                            " This generally means we've been detected as the primary filetype.
    1              0.000016 if !exists('b:did_indent')
                              setlocal autoindent
                              setlocal nocindent
                              setlocal nolisp
                              setlocal nosmartindent

                              setlocal indentexpr=GetGraphQLIndent()
                              setlocal indentkeys=0{,0},0),0[,0],0#,!^F,o,O

                              let b:did_indent = 1
    1              0.000001 endif

                            " If our indentation function already exists, we have nothing more to do.
    1              0.000006 if exists('*GetGraphQLIndent')
                              finish
    1              0.000001 endif

    1              0.000007 let s:cpo_save = &cpoptions
    1              0.000011 set cpoptions&vim

                            " searchpair() skip expression that matches in comments and strings.
    1              0.000006 let s:pair_skip_expr =
                              \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "comment\\|string"'

                            " Check if the character at lnum:col is inside a string.
    1              0.000007 function s:InString(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') ==# 'graphqlString'
                            endfunction

    1              0.000002 function GetGraphQLIndent()
                              " If this is the first non-blank line, we have nothing more to do because
                              " all of our indentation rules are based on matching against earlier lines.
                              let l:prevlnum = prevnonblank(v:lnum - 1)
                              if l:prevlnum == 0
                                return 0
                              endif

                              " If the previous line isn't GraphQL, don't change this line's indentation.
                              " Assume we've been manually indented as part of a template string.
                              let l:stack = map(synstack(l:prevlnum, 1), "synIDattr(v:val, 'name')")
                              if get(l:stack, -1) !~# '^graphql'
                                return -1
                              endif

                              let l:line = getline(v:lnum)

                              " If this line contains just a closing bracket, find its matching opening
                              " bracket and indent the closing bracket to match.
                              let l:col = matchend(l:line, '^\s*[]})]')
                              if l:col > 0 && !s:InString(v:lnum, l:col)
                                call cursor(v:lnum, l:col)

                                let l:bracket = l:line[l:col - 1]
                                if l:bracket ==# '}'
                                  let l:matched = searchpair('{', '', '}', 'bW', s:pair_skip_expr)
                                elseif l:bracket ==# ']'
                                  let l:matched = searchpair('\[', '', '\]', 'bW', s:pair_skip_expr)
                                elseif l:bracket ==# ')'
                                  let l:matched = searchpair('(', '', ')', 'bW', s:pair_skip_expr)
                                else
                                  let l:matched = -1
                                endif

                                return l:matched > 0 ? indent(l:matched) : virtcol('.') - 1
                              endif

                              " If we're inside of a multiline string, continue with the same indentation.
                              if s:InString(v:lnum, matchend(l:line, '^\s*') + 1)
                                return indent(v:lnum)
                              endif

                              " If the previous line ended with an opening bracket, indent this line.
                              if getline(l:prevlnum) =~# '\%(#.*\)\@<![[{(]\s*$'
                                return indent(l:prevlnum) + shiftwidth()
                              endif

                              " Default to the existing indentation level.
                              return indent(l:prevlnum)
                            endfunction

    1              0.000008 let &cpoptions = s:cpo_save
    1              0.000010 unlet s:cpo_save

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/indent/graphql.vim
Sourced 1 time
Total time:   0.001296
 Self time:   0.001296

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'graphql')
                              finish
    1              0.000002 endif

                            " Copyright (c) 2016-2020 Jon Parise <jon@indelible.org>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to
                            " deal in the Software without restriction, including without limitation the
                            " rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                            " sell copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                            " FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
                            " IN THE SOFTWARE.
                            "
                            " Language: GraphQL
                            " Maintainer: Jon Parise <jon@indelible.org>

                            " Set our local options if indentation hasn't already been set up.
                            " This generally means we've been detected as the primary filetype.
    1              0.000006 if !exists('b:did_indent')
                              setlocal autoindent
                              setlocal nocindent
                              setlocal nolisp
                              setlocal nosmartindent

                              setlocal indentexpr=GetGraphQLIndent()
                              setlocal indentkeys=0{,0},0),0[,0],0#,!^F,o,O

                              let b:did_indent = 1
    1              0.000001 endif

                            " If our indentation function already exists, we have nothing more to do.
    1              0.000006 if exists('*GetGraphQLIndent')
    1              0.000002   finish
                            endif

                            let s:cpo_save = &cpoptions
                            set cpoptions&vim

                            " searchpair() skip expression that matches in comments and strings.
                            let s:pair_skip_expr =
                              \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "comment\\|string"'

                            " Check if the character at lnum:col is inside a string.
                            function s:InString(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') ==# 'graphqlString'
                            endfunction

                            function GetGraphQLIndent()
                              " If this is the first non-blank line, we have nothing more to do because
                              " all of our indentation rules are based on matching against earlier lines.
                              let l:prevlnum = prevnonblank(v:lnum - 1)
                              if l:prevlnum == 0
                                return 0
                              endif

                              " If the previous line isn't GraphQL, don't change this line's indentation.
                              " Assume we've been manually indented as part of a template string.
                              let l:stack = map(synstack(l:prevlnum, 1), "synIDattr(v:val, 'name')")
                              if get(l:stack, -1) !~# '^graphql'
                                return -1
                              endif

                              let l:line = getline(v:lnum)

                              " If this line contains just a closing bracket, find its matching opening
                              " bracket and indent the closing bracket to match.
                              let l:col = matchend(l:line, '^\s*[]})]')
                              if l:col > 0 && !s:InString(v:lnum, l:col)
                                call cursor(v:lnum, l:col)

                                let l:bracket = l:line[l:col - 1]
                                if l:bracket ==# '}'
                                  let l:matched = searchpair('{', '', '}', 'bW', s:pair_skip_expr)
                                elseif l:bracket ==# ']'
                                  let l:matched = searchpair('\[', '', '\]', 'bW', s:pair_skip_expr)
                                elseif l:bracket ==# ')'
                                  let l:matched = searchpair('(', '', ')', 'bW', s:pair_skip_expr)
                                else
                                  let l:matched = -1
                                endif

                                return l:matched > 0 ? indent(l:matched) : virtcol('.') - 1
                              endif

                              " If we're inside of a multiline string, continue with the same indentation.
                              if s:InString(v:lnum, matchend(l:line, '^\s*') + 1)
                                return indent(v:lnum)
                              endif

                              " If the previous line ended with an opening bracket, indent this line.
                              if getline(l:prevlnum) =~# '\%(#.*\)\@<![[{(]\s*$'
                                return indent(l:prevlnum) + shiftwidth()
                              endif

                              " Default to the existing indentation level.
                              return indent(l:prevlnum)
                            endfunction

                            let &cpoptions = s:cpo_save
                            unlet s:cpo_save

SCRIPT  /Users/philippe/.vim/plugged/vim-graphql/after/indent/typescript.vim
Sourced 2 times
Total time:   0.001243
 Self time:   0.001243

count  total (s)   self (s)
                            " Copyright (c) 2016-2020 Jon Parise <jon@indelible.org>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to
                            " deal in the Software without restriction, including without limitation the
                            " rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                            " sell copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                            " FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
                            " IN THE SOFTWARE.
                            "
                            " Language: GraphQL
                            " Maintainer: Jon Parise <jon@indelible.org>

    2              0.000034 if exists('*GetTypescriptGraphQLIndent') && !empty(&indentexpr)
    2              0.000005   finish
                            endif

                            runtime! indent/graphql.vim

                            " Set the indentexpr with our own version that will call GetGraphQLIndent when
                            " we're inside of a GraphQL string and otherwise defer to the base function.
                            let b:indentexpr_base = &indentexpr
                            setlocal indentexpr=GetTypescriptGraphQLIndent()

                            function GetTypescriptGraphQLIndent()
                              let l:stack = map(synstack(v:lnum, 1), "synIDattr(v:val, 'name')")
                              if get(l:stack, 0, '') ==# 'graphqlTemplateString'
                                return GetGraphQLIndent()
                              endif

                              return eval(b:indentexpr_base)
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/HEAD-759a054/share/nvim/runtime/indent/xml.vim
Sourced 1 time
Total time:   0.002943
 Self time:   0.002943

count  total (s)   self (s)
                            "     Language: xml
                            "   Repository: https://github.com/chrisbra/vim-xml-ftplugin
                            " Last Changed: July 27, 2019
                            "   Maintainer: Christian Brabandt <cb@256bit.org>
                            " Previous Maintainer:  Johannes Zellner <johannes@zellner.org>
                            " Last Change:
                            " 20190726 - Correctly handle non-tagged data
                            " 20190204 - correctly handle wrap tags
                            "            https://github.com/chrisbra/vim-xml-ftplugin/issues/5
                            " 20190128 - Make sure to find previous tag
                            "            https://github.com/chrisbra/vim-xml-ftplugin/issues/4
                            " 20181116 - Fix indentation when tags start with a colon or an underscore
                            "            https://github.com/vim/vim/pull/926
                            " 20181022 - Do not overwrite indentkeys setting
                            "            https://github.com/chrisbra/vim-xml-ftplugin/issues/1
                            " 20180724 - Correctly indent xml comments https://github.com/vim/vim/issues/3200
                            "
                            " Notes:
                            "   1) does not indent pure non-xml code (e.g. embedded scripts)
                            "       2) will be confused by unbalanced tags in comments
                            "       or CDATA sections.
                            "       2009-05-26 patch by Nikolai Weibull
                            " TODO:     implement pre-like tags, see xml_indent_open / xml_indent_close

                            " Only load this indent file when no other was loaded.
    1              0.000015 if exists("b:did_indent")
                                finish
    1              0.000001 endif
    1              0.000006 let b:did_indent = 1
    1              0.000010 let s:keepcpo= &cpo
    1              0.000012 set cpo&vim

                            " [-- local settings (must come before aborting the script) --]
                            " Attention: Parameter use_syntax_check is used by the docbk.vim indent script
    1              0.000007 setlocal indentexpr=XmlIndentGet(v:lnum,1)
    1              0.000006 setlocal indentkeys=o,O,*<Return>,<>>,<<>,/,{,},!^F
                            " autoindent: used when the indentexpr returns -1
    1              0.000016 setlocal autoindent

    1              0.000006 if !exists('b:xml_indent_open')
    1              0.000004     let b:xml_indent_open = '.\{-}<[:A-Z_a-z]'
                                " pre tag, e.g. <address>
                                " let b:xml_indent_open = '.\{-}<[/]\@!\(address\)\@!'
    1              0.000001 endif

    1              0.000004 if !exists('b:xml_indent_close')
    1              0.000003     let b:xml_indent_close = '.\{-}</'
                                " end pre tag, e.g. </address>
                                " let b:xml_indent_close = '.\{-}</\(address\)\@!'
    1              0.000001 endif

    1              0.000009 let &cpo = s:keepcpo
    1              0.000003 unlet s:keepcpo

                            " [-- finish, if the function already exists --]
    1              0.000005 if exists('*XmlIndentGet')
                                finish
    1              0.000001 endif

    1              0.000005 let s:keepcpo= &cpo
    1              0.000006 set cpo&vim

    1              0.000006 fun! <SID>XmlIndentWithPattern(line, pat)
                                let s = substitute('x'.a:line, a:pat, "\1", 'g')
                                return strlen(substitute(s, "[^\1].*$", '', ''))
                            endfun

                            " [-- check if it's xml --]
    1              0.000003 fun! <SID>XmlIndentSynCheck(lnum)
                                if &syntax != ''
                                    let syn1 = synIDattr(synID(a:lnum, 1, 1), 'name')
                                    let syn2 = synIDattr(synID(a:lnum, strlen(getline(a:lnum)) - 1, 1), 'name')
                                    if syn1 != '' && syn1 !~ 'xml' && syn2 != '' && syn2 !~ 'xml'
                                        " don't indent pure non-xml code
                                        return 0
                                    endif
                                endif
                                return 1
                            endfun

                            " [-- return the sum of indents of a:lnum --]
    1              0.000003 fun! <SID>XmlIndentSum(line, style, add)
                                if <SID>IsXMLContinuation(a:line) && a:style == 0
                                    " no complete tag, add one additional indent level
                                    " but only for the current line
                                    return a:add + shiftwidth()
                                elseif <SID>HasNoTagEnd(a:line)
                                    " no complete tag, return initial indent
                                    return a:add
                                endif
                                if a:style == match(a:line, '^\s*</')
                                    return (shiftwidth() *
                                    \  (<SID>XmlIndentWithPattern(a:line, b:xml_indent_open)
                                    \ - <SID>XmlIndentWithPattern(a:line, b:xml_indent_close)
                                    \ - <SID>XmlIndentWithPattern(a:line, '.\{-}/>'))) + a:add
                                else
                                    return a:add
                                endif
                            endfun

                            " Main indent function
    1              0.000003 fun! XmlIndentGet(lnum, use_syntax_check)
                                " Find a non-empty line above the current line.
                                if prevnonblank(a:lnum - 1) == 0
                                    " Hit the start of the file, use zero indent.
                                    return 0
                                endif
                                " Find previous line with a tag (regardless whether open or closed,
                                " but always restrict the match to a line before the current one
                                " Note: xml declaration: <?xml version="1.0"?>
                                "       won't be found, as it is not a legal tag name
                                let ptag_pattern = '\%(.\{-}<[/:A-Z_a-z]\)'. '\%(\&\%<'. a:lnum .'l\)'
                                let ptag = search(ptag_pattern, 'bnW')
                                " no previous tag
                                if ptag == 0
                                    return 0
                                endif

                                let pline = getline(ptag)
                                let pind  = indent(ptag)

                                let syn_name_start = '' " Syntax element at start of line (excluding whitespace)
                                let syn_name_end = ''   " Syntax element at end of line
                                let curline = getline(a:lnum)
                                if a:use_syntax_check
                                    let check_lnum = <SID>XmlIndentSynCheck(ptag)
                                    let check_alnum = <SID>XmlIndentSynCheck(a:lnum)
                                    if check_lnum == 0 || check_alnum == 0
                                        return indent(a:lnum)
                                    endif
                                    let syn_name_end   = synIDattr(synID(a:lnum, strlen(curline) - 1, 1), 'name')
                                    let syn_name_start = synIDattr(synID(a:lnum, match(curline, '\S') + 1, 1), 'name')
                                endif

                                if syn_name_end =~ 'Comment' && syn_name_start =~ 'Comment'
                                    return <SID>XmlIndentComment(a:lnum)
                                elseif empty(syn_name_start) && empty(syn_name_end)
                                    " non-xml tag content: use indent from 'autoindent'
                                    return pind + shiftwidth()
                                endif

                                " Get indent from previous tag line
                                let ind = <SID>XmlIndentSum(pline, -1, pind)
                                " Determine indent from current line
                                let ind = <SID>XmlIndentSum(curline, 0, ind)
                                return ind
                            endfun

    1              0.000012 func! <SID>IsXMLContinuation(line)
                                " Checks, whether or not the line matches a start-of-tag
                                return a:line !~ '^\s*<'
                            endfunc

    1              0.000003 func! <SID>HasNoTagEnd(line)
                                " Checks whether or not the line matches '>' (so finishes a tag)
                                return a:line !~ '>\s*$'
                            endfunc

                            " return indent for a commented line,
                            " the middle part might be indented one additional level
    1              0.000003 func! <SID>XmlIndentComment(lnum)
                                let ptagopen = search(b:xml_indent_open, 'bnW')
                                let ptagclose = search(b:xml_indent_close, 'bnW')
                                if getline(a:lnum) =~ '<!--'
                                    " if previous tag was a closing tag, do not add
                                    " one additional level of indent
                                    if ptagclose > ptagopen && a:lnum > ptagclose
                                        return indent(ptagclose)
                                    else
                                        " start of comment, add one indentation level
                                        return indent(ptagopen) + shiftwidth()
                                    endif
                                elseif getline(a:lnum) =~ '-->'
                                    " end of comment, same as start of comment
                                    return indent(search('<!--', 'bnW'))
                                else
                                    " middle part of comment, add one additional level
                                    return indent(search('<!--', 'bnW')) + shiftwidth()
                                endif
                            endfunc

    1              0.000023 let &cpo = s:keepcpo
    1              0.000004 unlet s:keepcpo

                            " vim:ts=4 et sts=-1 sw=0

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/after/indent/typescriptreact.vim
Sourced 1 time
Total time:   0.004111
 Self time:   0.001518

count  total (s)   self (s)
    1              0.000023 if has_key(g:polyglot_is_disabled, 'jsx')
                              finish
    1              0.000002 endif

    1   0.002972   0.000379 source <sfile>:h/tsx.vim

SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/after/indent/tsx.vim
Sourced 1 time
Total time:   0.002535
 Self time:   0.002359

count  total (s)   self (s)
    1              0.000024 if has_key(g:polyglot_is_disabled, 'jsx')
                              finish
    1              0.000002 endif

                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Vim indent file
                            "
                            " Language: typescript.jsx
                            " Maintainer: MaxMellon <maxmellon1994@gmail.com>
                            " Depends: leafgarland/typescript-vim
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    1              0.000006 if get(g:, 'vim_jsx_pretty_disable_tsx', 0)
                              finish
    1              0.000001 endif

    1              0.000005 if exists('b:did_indent')
    1              0.000006   let s:did_indent = b:did_indent
    1              0.000003   unlet b:did_indent
    1              0.000001 endif

    1              0.000010 let s:keepcpo = &cpo
    1              0.000013 set cpo&vim

    1              0.000004 if exists('s:did_indent')
    1              0.000003   let b:did_indent = s:did_indent
    1              0.000001 endif

    1   0.001195   0.001019 runtime! indent/typescript.vim

    1              0.000009 setlocal indentexpr=GetJsxIndent()
    1              0.000007 setlocal indentkeys=0.,0{,0},0),0],0?,0\*,0\,,!^F,:,<:>,o,O,e,<>>,=*/

    1              0.000004 function! GetJsxIndent()
                              return jsx_pretty#indent#get(function('GetTypescriptIndent'))
                            endfunction

    1              0.000010 let &cpo = s:keepcpo
    1              0.000005 unlet s:keepcpo

SCRIPT  /Users/philippe/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim
Sourced 1 time
Total time:   0.001211
 Self time:   0.001211

count  total (s)   self (s)
    1              0.000038 let s:available = has('nvim') || (
                                  \   has('job') && (
                                  \     (has('patch-7-4-1826') && !has('gui_running')) ||
                                  \     (has('patch-7-4-1850') &&  has('gui_running')) ||
                                  \     (has('patch-7-4-1832') &&  has('gui_macvim'))
                                  \   )
                                  \ )

    1              0.000004 let s:jobs = {}

    1              0.000004 function! gitgutter#async#available()
                              return s:available
                            endfunction


    1              0.000004 function! gitgutter#async#execute(cmd, bufnr, handler) abort
                              call gitgutter#debug#log('[async] '.a:cmd)

                              let options = {
                                    \   'stdoutbuffer': [],
                                    \   'buffer': a:bufnr,
                                    \   'handler': a:handler
                                    \ }
                              let command = s:build_command(a:cmd)

                              if has('nvim')
                                call jobstart(command, extend(options, {
                                      \   'on_stdout': function('s:on_stdout_nvim'),
                                      \   'on_stderr': function('s:on_stderr_nvim'),
                                      \   'on_exit':   function('s:on_exit_nvim')
                                      \ }))
                              else
                                let job = job_start(command, {
                                      \   'out_cb':   function('s:on_stdout_vim', options),
                                      \   'err_cb':   function('s:on_stderr_vim', options),
                                      \   'close_cb': function('s:on_exit_vim', options)
                                      \ })
                                let s:jobs[s:job_id(job)] = 1
                              endif
                            endfunction


    1              0.000005 function! s:build_command(cmd)
                              if has('unix')
                                return ['sh', '-c', a:cmd]
                              endif

                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif

                              throw 'unknown os'
                            endfunction


    1              0.000003 function! s:on_stdout_nvim(_job_id, data, _event) dict abort
                              if empty(self.stdoutbuffer)
                                let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] +
                                      \ [self.stdoutbuffer[-1] . a:data[0]] +
                                      \ a:data[1:]
                              endif
                            endfunction

    1              0.000003 function! s:on_stderr_nvim(_job_id, data, _event) dict abort
                              if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
                              endif
                            endfunction

    1              0.000003 function! s:on_exit_nvim(_job_id, exit_code, _event) dict abort
                              if !a:exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction


    1              0.000003 function! s:on_stdout_vim(_channel, data) dict abort
                              call add(self.stdoutbuffer, a:data)
                            endfunction

    1              0.000002 function! s:on_stderr_vim(channel, _data) dict abort
                              call self.handler.err(self.buffer)
                            endfunction

    1              0.000002 function! s:on_exit_vim(channel) dict abort
                              let job = ch_getjob(a:channel)
                              let jobid = s:job_id(job)
                              if has_key(s:jobs, jobid) | unlet s:jobs[jobid] | endif
                              while 1
                                if job_status(job) == 'dead'
                                  let exit_code = job_info(job).exitval
                                  break
                                endif
                                sleep 5m
                              endwhile

                              if !exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction

    1              0.000002 function! s:job_id(job)
                              " Vim
                              return job_info(a:job).process
                            endfunction

SCRIPT  /Users/philippe/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim
Sourced 1 time
Total time:   0.001246
 Self time:   0.001246

count  total (s)   self (s)
    1              0.000069 let s:plugin_dir  = expand('<sfile>:p:h:h:h').'/'
    1              0.000006 let s:log_file    = s:plugin_dir.'gitgutter.log'
    1              0.000004 let s:channel_log = s:plugin_dir.'channel.log'
    1              0.000003 let s:new_log_session = 1


    1              0.000004 function! gitgutter#debug#debug()
                              " Open a scratch buffer
                              vsplit __GitGutter_Debug__
                              normal! ggdG
                              setlocal buftype=nofile
                              setlocal bufhidden=delete
                              setlocal noswapfile

                              call s:vim_version()
                              call s:separator()

                              call s:git_version()
                              call s:separator()

                              call s:grep_version()
                              call s:separator()

                              call s:option('updatetime')
                            endfunction


    1              0.000005 function! s:separator()
                              call s:output('')
                            endfunction

    1              0.000002 function! s:vim_version()
                              redir => version_info
                                silent execute 'version'
                              redir END
                              call s:output(split(version_info, '\n')[0:2])
                            endfunction

    1              0.000002 function! s:git_version()
                              let v = system(g:gitgutter_git_executable.' --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            endfunction

    1              0.000002 function! s:grep_version()
                              let v = system(g:gitgutter_grep.' --version')
                              call s:output( substitute(v, '\n$', '', '') )

                              let v = system(g:gitgutter_grep.' --help')
                              call s:output( substitute(v, '\%x00', '', 'g') )
                            endfunction

    1              0.000002 function! s:option(name)
                              if exists('+' . a:name)
                                let v = eval('&' . a:name)
                                call s:output(a:name . '=' . v)
                                " redir => output
                                "   silent execute "verbose set " . a:name . "?"
                                " redir END
                                " call s:output(a:name . '=' . output)
                              else
                                call s:output(a:name . ' [n/a]')
                              end
                            endfunction

    1              0.000002 function! s:output(text)
                              call append(line('$'), a:text)
                            endfunction

                            " assumes optional args are calling function's optional args
    1              0.000003 function! gitgutter#debug#log(message, ...) abort
                              if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif

                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif

                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END

                                let s:new_log_session = 0
                              endif
                            endfunction

    1              0.000002 function! s:format_for_log(data) abort
                              if type(a:data) == 1
                                return join(split(a:data,'\n'),"\n")
                              elseif type(a:data) == 3
                                return '['.join(a:data,"\n").']'
                              else
                                return a:data
                              endif
                            endfunction


SCRIPT  /Users/philippe/.vim/plugged/vim-airline/autoload/airline/async.vim
Sourced 1 time
Total time:   0.002296
 Self time:   0.002296

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2020 Christian Brabandt et al.
                            " vim: et ts=2 sts=2 sw=2

    1              0.000007 scriptencoding utf-8

    1              0.000010 let s:untracked_jobs = {}
    1              0.000003 let s:mq_jobs        = {}
    1              0.000003 let s:po_jobs        = {}
    1              0.000003 let s:clean_jobs     = {}

                            " Generic functions handling on exit event of the various async functions
    1              0.000008 function! s:untracked_output(dict, buf)
                              if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
                                let a:dict.cfg.untracked[a:dict.file] = ''
                              endif
                            endfunction

                            " also called from branch extension (for non-async vims)
    1              0.000004 function! airline#async#mq_output(buf, file)
                              let buf=a:buf
                              if !empty(a:buf)
                                if a:buf =~# 'no patches applied' ||
                                  \ a:buf =~# "unknown command 'qtop'" ||
                                  \ a:buf =~# "abort"
                                  let buf = ''
                                elseif exists("b:mq") && b:mq isnot# buf
                                  " make sure, statusline is updated
                                  unlet! b:airline_head
                                endif
                                let b:mq = buf
                              endif
                              if has_key(s:mq_jobs, a:file)
                                call remove(s:mq_jobs, a:file)
                              endif
                            endfunction

    1              0.000003 function! s:po_output(buf, file)
                              if !empty(a:buf)
                                let b:airline_po_stats = printf("%s", a:buf)
                              else
                                let b:airline_po_stats = ''
                              endif
                              if has_key(s:po_jobs, a:file)
                                call remove(s:po_jobs, a:file)
                              endif
                            endfunction

    1              0.000002 function! s:valid_dir(dir)
                              if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
                              endif
                              return a:dir
                            endfunction

    1              0.000003 function! airline#async#vcs_untracked(config, file, vcs)
                              if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_untracked(a:config, a:file)
                              else
                                " nvim async or vim without job-feature
                                noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
                              endif
                            endfunction

    1              0.000003 function! s:set_clean_variables(file, vcs, val)
                              let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
                              if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') &&
                                    \ type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
                                let var[a:vcs].dirty=a:val
                                try
                                  call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
                                  unlet! b:airline_head
                                catch
                                endtry
                              endif
                            endfunction

    1              0.000003 function! s:set_clean_jobs_variable(vcs, file, id)
                              if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
                              endif
                              let s:clean_jobs[a:vcs][a:file]=a:id
                            endfunction

    1              0.000002 function! s:on_exit_clean(...) dict abort
                              let buf=self.buf
                              call s:set_clean_variables(self.file, self.vcs, !empty(buf))
                              if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
                                call remove(s:clean_jobs[self.vcs], self.file)
                              endif
                            endfunction

    1              0.000003 function! airline#async#vcs_clean(cmd, file, vcs)
                              if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
                              elseif has("nvim")
                                " nvim async
                                noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                              else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
                              endif
                            endfunction

    1              0.000012 if v:version >= 800 && has("job")
                              " Vim 8.0 with Job feature
                              " TODO: Check if we need the cwd option for the job_start() functions
                              "       (only works starting with Vim 8.0.0902)

                              function! s:on_stdout(channel, msg) dict abort
                                let self.buf .= a:msg
                              endfunction

                              function! s:on_exit_mq(channel) dict abort
                                call airline#async#mq_output(self.buf, self.file)
                              endfunction

                              function! s:on_exit_untracked(channel) dict abort
                                call s:untracked_output(self, self.buf)
                                if has_key(s:untracked_jobs, self.file)
                                  call remove(s:untracked_jobs, self.file)
                                endif
                              endfunction

                              function! s:on_exit_po(channel) dict abort
                                call s:po_output(self.buf, self.file)
                                call airline#extensions#po#shorten()
                              endfunction

                              function! airline#async#get_mq_async(cmd, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif

                                let options = {'cmd': a:cmd, 'buf': '', 'file': a:file}
                                if has_key(s:mq_jobs, a:file)
                                  if job_status(get(s:mq_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:mq_jobs, a:file)
                                    call remove(s:mq_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_mq', options)})
                                let s:mq_jobs[a:file] = id
                              endfunction

                              function! airline#async#get_msgfmt_stat(cmd, file)
                                if !executable('msgfmt')
                                  " no msgfmt
                                  return
                                endif
                                if g:airline#init#is_windows
                                  let cmd = 'cmd /C ' . a:cmd. shellescape(a:file)
                                else
                                  let cmd = ['sh', '-c', a:cmd. shellescape(a:file)]
                                endif

                                let options = {'buf': '', 'file': a:file}
                                if has_key(s:po_jobs, a:file)
                                  if job_status(get(s:po_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:po_jobs, a:file)
                                    call remove(s:po_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_po', options)})
                                let s:po_jobs[a:file] = id
                              endfunction

                              function! airline#async#vim_vcs_clean(cmd, file, vcs)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif

                                let options = {'buf': '', 'vcs': a:vcs, 'file': a:file}
                                let jobs = get(s:clean_jobs, a:vcs, {})
                                if has_key(jobs, a:file)
                                  if job_status(get(jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(jobs, a:file)
                                    " still running
                                    return
                                    " jobs dict should be cleaned on exit, so not needed here
                                    " call remove(jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'null',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_clean', options)})
                                call s:set_clean_jobs_variable(a:vcs, a:file, id)
                              endfunction

                              function! airline#async#vim_vcs_untracked(config, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:config['cmd'] . shellescape(a:file)
                                else
                                  let cmd = [&shell, &shellcmdflag, a:config['cmd'] . shellescape(a:file)]
                                endif

                                let options = {'cfg': a:config, 'buf': '', 'file': a:file}
                                if has_key(s:untracked_jobs, a:file)
                                  if job_status(get(s:untracked_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:untracked_jobs, a:file)
                                    call remove(s:untracked_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_untracked', options)})
                                let s:untracked_jobs[a:file] = id
                              endfunction

    1              0.000011 elseif has("nvim")
                              " NVim specific functions

    1              0.000006   function! s:nvim_output_handler(job_id, data, event) dict
                                if a:event == 'stdout' || a:event == 'stderr'
                                  let self.buf .=  join(a:data)
                                endif
                              endfunction

    1              0.000025   function! s:nvim_untracked_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:untracked_output(self, self.buf)
                                  if has_key(s:untracked_jobs, self.file)
                                    call remove(s:untracked_jobs, self.file)
                                  endif
                                endif
                              endfunction

    1              0.000032   function! s:nvim_mq_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call airline#async#mq_output(self.buf, self.file)
                                endif
                              endfunction

    1              0.000003   function! s:nvim_po_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:po_output(self.buf, self.file)
                                  call airline#extensions#po#shorten()
                                endif
                              endfunction

    1              0.000003   function! airline#async#nvim_get_mq_async(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_mq_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif

                                if has_key(s:mq_jobs, a:file)
                                  call remove(s:mq_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:mq_jobs[a:file] = id
                              endfunction

    1              0.000003   function! airline#async#nvim_get_msgfmt_stat(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_po_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  " no msgfmt on windows?
                                  return
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd. shellescape(a:file)]
                                endif

                                if has_key(s:po_jobs, a:file)
                                  call remove(s:po_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:po_jobs[a:file] = id
                              endfunction

    1              0.000003   function! airline#async#nvim_vcs_clean(cmd, file, vcs)
                                let config = {
                                \ 'buf': '',
                                \ 'vcs': a:vcs,
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:on_exit_clean')}
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif

                                if !has_key(s:clean_jobs, a:vcs)
                                  let s:clean_jobs[a:vcs] = {}
                                endif
                                if has_key(s:clean_jobs[a:vcs], a:file)
                                  " still running
                                  return
                                  " jobs dict should be cleaned on exit, so not needed here
                                  " call remove(s:clean_jobs[a:vcs], a:file)
                                endif
                                let id = jobstart(cmd, config)
                                call s:set_clean_jobs_variable(a:vcs, a:file, id)
                              endfunction

    1              0.000002 endif

                            " Should work in either Vim pre 8 or Nvim
    1              0.000003 function! airline#async#nvim_vcs_untracked(cfg, file, vcs)
                              let cmd = a:cfg.cmd . shellescape(a:file)
                              let id = -1
                              let config = {
                              \ 'buf': '',
                              \ 'vcs': a:vcs,
                              \ 'cfg': a:cfg,
                              \ 'file': a:file,
                              \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h'))
                              \ }
                              if has("nvim")
                                call extend(config, {
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_untracked_job_handler')})
                                if has_key(s:untracked_jobs, config.file)
                                  " still running
                                  return
                                endif
                                try
                                let id = jobstart(cmd, config)
                                catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
                                endtry
                                let s:untracked_jobs[a:file] = id
                              endif
                              " vim without job feature or nvim jobstart failed
                              if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
                              endif
                            endfunction

    1              0.000003 function! airline#async#vim7_vcs_clean(cmd, file, vcs)
                              " Vim pre 8, fallback using system()
                              " don't want to to see error messages
                              if g:airline#init#is_windows && &shell =~ 'cmd'
                                let cmd = a:cmd .' 2>nul'
                              elseif g:airline#init#is_windows && &shell =~ 'powerline'
                                let cmd = a:cmd .' 2> $null'
                              else
                                let cmd = a:cmd .' 2>/dev/null'
                              endif
                              let output=system(cmd)
                              call s:set_clean_variables(a:file, a:vcs, !empty(output))
                            endfunction

SCRIPT  /Users/philippe/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim
Sourced 1 time
Total time:   0.060550
 Self time:   0.008568

count  total (s)   self (s)
    1              0.000013 scriptencoding utf8

    1              0.000017 let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''

    1              0.000003 let s:hunk_re = '^@@ -\(\d\+\),\?\(\d*\) +\(\d\+\),\?\(\d*\) @@'

                            " True for git v1.7.2+.
    1              0.000007 function! s:git_supports_command_line_config_override() abort
                              call gitgutter#utility#system(g:gitgutter_git_executable.' '.g:gitgutter_git_args.' -c foo.bar=baz --version')
                              return !v:shell_error
                            endfunction

    1   0.052030   0.000047 let s:c_flag = s:git_supports_command_line_config_override()

    1              0.000028 let s:temp_from = tempname()
    1              0.000015 let s:temp_buffer = tempname()
    1              0.000009 let s:counter = 0

                            " Returns a diff of the buffer against the index or the working tree.
                            "
                            " After running the diff we pass it through grep where available to reduce
                            " subsequent processing by the plugin.  If grep is not available the plugin
                            " does the filtering instead.
                            "
                            " When diffing against the index:
                            "
                            " The buffer contents is not the same as the file on disk so we need to pass
                            " two instances of the file to git-diff:
                            "
                            "     git diff myfileA myfileB
                            "
                            " where myfileA comes from
                            "
                            "     git show :myfile > myfileA
                            "
                            " and myfileB is the buffer contents.
                            "
                            " Regarding line endings:
                            "
                            " git-show does not convert line endings.
                            " git-diff FILE FILE does convert line endings for the given files.
                            "
                            " If a file has CRLF line endings and git's core.autocrlf is true,
                            " the file in git's object store will have LF line endings.  Writing
                            " it out via git-show will produce a file with LF line endings.
                            "
                            " If this last file is one of the files passed to git-diff, git-diff will
                            " convert its line endings to CRLF before diffing -- which is what we want --
                            " but also by default output a warning on stderr.
                            "
                            "   warning: LF will be replace by CRLF in <temp file>.
                            "   The file will have its original line endings in your working directory.
                            "
                            " When running the diff asynchronously, the warning message triggers the stderr
                            " callbacks which assume the overall command has failed and reset all the
                            " signs.  As this is not what we want, and we can safely ignore the warning,
                            " we turn it off by passing the '-c "core.safecrlf=false"' argument to
                            " git-diff.
                            "
                            " When writing the temporary files we preserve the original file's extension
                            " so that repos using .gitattributes to control EOL conversion continue to
                            " convert correctly.
                            "
                            " Arguments:
                            "
                            " bufnr              - the number of the buffer to be diffed
                            " from               - 'index' or 'working_tree'; what the buffer is diffed against
                            " preserve_full_diff - truthy to return the full diff or falsey to return only
                            "                      the hunk headers (@@ -x,y +m,n @@); only possible if
                            "                      grep is available.
    1              0.000022 function! gitgutter#diff#run_diff(bufnr, from, preserve_full_diff) abort
                              if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter author fail'
                              endif

                              if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif

                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
                              let cmd = '('

                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.

                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
                              let buff_file = s:temp_buffer.'.'.a:bufnr

                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
                              let s:counter = (s:counter + 1) % 20
                              let buff_file .= '.'.s:counter

                              let extension = gitgutter#utility#extension(a:bufnr)
                              if !empty(extension)
                                let buff_file .= '.'.extension
                              endif

                              " Write buffer to temporary file.
                              " Note: this is synchronous.
                              call s:write_buffer(a:bufnr, buff_file)

                              if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
                                let from_file = s:temp_from.'.'.a:bufnr

                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
                                let from_file .= '.'.s:counter

                                if !empty(extension)
                                  let from_file .= '.'.extension
                                endif

                                " Write file from index to temporary file.
                                let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
                                let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '

                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
                              endif

                              " Call git-diff.
                              let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
                              if s:c_flag
                                let cmd .= ' -c "diff.autorefreshindex=0"'
                                let cmd .= ' -c "diff.noprefix=false"'
                                let cmd .= ' -c "core.safecrlf=false"'
                              endif
                              let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file

                              " Pipe git-diff output into grep.
                              if !a:preserve_full_diff && !empty(g:gitgutter_grep)
                                let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
                              endif

                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
                              let cmd .= ' || exit 0'

                              let cmd .= ')'

                              let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)

                              if g:gitgutter_async && gitgutter#async#available()
                                call gitgutter#async#execute(cmd, a:bufnr, {
                                      \   'out': function('gitgutter#diff#handler'),
                                      \   'err': function('gitgutter#hunk#reset'),
                                      \ })
                                return 'async'

                              else
                                let diff = gitgutter#utility#system(cmd)

                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif

                                return diff
                              endif
                            endfunction


    1              0.000025 function! gitgutter#diff#handler(bufnr, diff) abort
                              call gitgutter#debug#log(a:diff)

                              if !bufexists(a:bufnr)
                                return
                              endif

                              call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
                              let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))

                              let signs_count = len(modified_lines)
                              if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf(
                                      \ 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).',
                                      \ signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)

                              else
                                if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
                                  call gitgutter#sign#update_signs(a:bufnr, modified_lines)
                                endif
                              endif

                              call s:save_last_seen_change(a:bufnr)
                              if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif
                            endfunction


    1              0.000010 function! gitgutter#diff#parse_diff(diff) abort
                              let hunks = []
                              for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
                              endfor
                              return hunks
                            endfunction

    1              0.000006 function! gitgutter#diff#parse_hunk(line) abort
                              let matches = matchlist(a:line, s:hunk_re)
                              if len(matches) > 0
                                let from_line  = str2nr(matches[1])
                                let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
                                let to_line    = str2nr(matches[3])
                                let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
                                return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end
                            endfunction

                            " This function is public so it may be used by other plugins
                            " e.g. vim-signature.
    1              0.000006 function! gitgutter#diff#process_hunks(bufnr, hunks) abort
                              let modified_lines = []
                              for hunk in a:hunks
                                call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
                              endfor
                              return modified_lines
                            endfunction

                            " Returns [ [<line_number (number)>, <name (string)>], ...]
    1              0.000022 function! s:process_hunk(bufnr, hunk) abort
                              let modifications = []
                              let from_line  = a:hunk[0]
                              let from_count = a:hunk[1]
                              let to_line    = a:hunk[2]
                              let to_count   = a:hunk[3]

                              if s:is_added(from_count, to_count)
                                call s:process_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)

                              elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)

                              elseif s:is_modified(from_count, to_count)
                                call s:process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)

                              elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)

                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)

                              endif
                              return modifications
                            endfunction

    1              0.000009 function! s:is_added(from_count, to_count) abort
                              return a:from_count == 0 && a:to_count > 0
                            endfunction

    1              0.000005 function! s:is_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count == 0
                            endfunction

    1              0.000005 function! s:is_modified(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count
                            endfunction

    1              0.000007 function! s:is_modified_and_added(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count
                            endfunction

    1              0.000005 function! s:is_modified_and_removed(from_count, to_count) abort
                              return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count
                            endfunction

    1              0.000004 function! s:process_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction

    1              0.000006 function! s:process_removed(modifications, from_count, to_count, to_line) abort
                              if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
                              else
                                call add(a:modifications, [a:to_line, 'removed'])
                              endif
                            endfunction

    1              0.000004 function! s:process_modified(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                            endfunction

    1              0.000005 function! s:process_modified_and_added(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:from_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'added'])
                                let offset += 1
                              endwhile
                            endfunction

    1              0.000005 function! s:process_modified_and_removed(modifications, from_count, to_count, to_line) abort
                              let offset = 0
                              while offset < a:to_count
                                let line_number = a:to_line + offset
                                call add(a:modifications, [line_number, 'modified'])
                                let offset += 1
                              endwhile
                              let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']
                            endfunction


                            " Returns a diff for the current hunk.
                            " Assumes there is only 1 current hunk unless the optional argument is given,
                            " in which case the cursor is in two hunks and the argument specifies the one
                            " to choose.
                            "
                            " Optional argument: 0 (to use the first hunk) or 1 (to use the second).
    1              0.000005 function! gitgutter#diff#hunk_diff(bufnr, full_diff, ...)
                              let modified_diff = []
                              let hunk_index = 0
                              let keep_line = 1
                              " Don't keepempty when splitting because the diff we want may not be the
                              " final one.  Instead add trailing NL at end of function.
                              for line in split(a:full_diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4  " start of new hunk
                                  let keep_line = gitgutter#hunk#cursor_in_hunk(hunk_info)

                                  if a:0 && hunk_index != a:1
                                    let keep_line = 0
                                  endif

                                  let hunk_index += 1
                                endif
                                if keep_line
                                  call add(modified_diff, line)
                                endif
                              endfor
                              return join(modified_diff, "\n")."\n"
                            endfunction


    1              0.000015 function! s:write_buffer(bufnr, file)
                              let bufcontents = getbufline(a:bufnr, 1, '$')

                              if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
                              endif

                              if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif

                              if getbufvar(a:bufnr, '&endofline')
                                call add(bufcontents, '')
                              endif

                              let fenc = getbufvar(a:bufnr, '&fileencoding')
                              if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif

                              if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
                              endif

                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
                              try
                                call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
                              endtry
                            endfunction


    1              0.000008 function! s:save_last_seen_change(bufnr) abort
                              call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))
                            endfunction

SCRIPT  /Users/philippe/.vim/plugged/coc.nvim/autoload/coc/task.vim
Sourced 1 time
Total time:   0.001392
 Self time:   0.001392

count  total (s)   self (s)
                            " ============================================================================
                            " Description: Manage long running tasks.
                            " Author: Qiming Zhao <chemzqm@gmail.com>
                            " Licence: MIT licence
                            " Version: 0.1
                            " Last Modified:  Dec 12, 2020
                            " ============================================================================

    1              0.000023 let s:is_vim = !has('nvim')
    1              0.000006 let s:running_task = {}
                            " neovim emit strings that part of lines.
    1              0.000004 let s:out_remain_text = {}
    1              0.000004 let s:err_remain_text = {}

    1              0.000006 function! coc#task#start(id, opts)
                              if coc#task#running(a:id)
                                call coc#task#stop(a:id)
                              endif
                              let cmd = [a:opts['cmd']] + get(a:opts, 'args', [])
                              let cwd = get(a:opts, 'cwd', getcwd())
                              let env = get(a:opts, 'env', {})
                              " cmd args cwd pty
                              if s:is_vim
                                let options = {
                                      \ 'cwd': cwd,
                                      \ 'err_mode': 'nl',
                                      \ 'out_mode': 'nl',
                                      \ 'err_cb': {channel, message -> s:on_stderr(a:id, [message])},
                                      \ 'out_cb': {channel, message -> s:on_stdout(a:id, [message])},
                                      \ 'exit_cb': {channel, code -> s:on_exit(a:id, code)},
                                      \ 'env': env,
                                      \}
                                if has("patch-8.1.350")
                                  let options['noblock'] = 1
                                endif
                                if get(a:opts, 'pty', 0)
                                  let options['pty'] = 1
                                endif
                                let job = job_start(cmd, options)
                                let status = job_status(job)
                                if status !=# 'run'
                                  echohl Error | echom 'Failed to start '.a:id.' task' | echohl None
                                  return v:false
                                endif
                                let s:running_task[a:id] = job
                              else
                                let options = {
                                      \ 'cwd': cwd,
                                      \ 'on_stderr': {channel, msgs -> s:on_stderr(a:id, msgs)},
                                      \ 'on_stdout': {channel, msgs -> s:on_stdout(a:id, msgs)},
                                      \ 'on_exit': {channel, code -> s:on_exit(a:id, code)},
                                      \ 'detach': get(a:opts, 'detach', 0),
                                      \}
                                let original = {}
                                if !empty(env) && exists('*setenv') && exists('*getenv')
                                  for key in keys(env)
                                    let original[key] = getenv(key)
                                    call setenv(key, env[key])
                                  endfor
                                endif
                                if get(a:opts, 'pty', 0)
                                  let options['pty'] = 1
                                endif
                                let chan_id = jobstart(cmd, options)
                                if !empty(original)
                                  for key in keys(original)
                                    call setenv(key, original[key])
                                  endfor
                                endif
                                if chan_id <= 0
                                  echohl Error | echom 'Failed to start '.a:id.' task' | echohl None
                                  return v:false
                                endif
                                let s:running_task[a:id] = chan_id
                              endif
                              return v:true
                            endfunction

    1              0.000004 function! coc#task#stop(id)
                              let job = get(s:running_task, a:id, v:null)
                              if !job | return | endif
                              if s:is_vim
                                call job_stop(job, 'term')
                              else
                                call jobstop(job)
                              endif
                              sleep 50m
                              let running = coc#task#running(a:id)
                              if running
                                echohl Error | echom 'job '.a:id. ' stop failed.' | echohl None
                              endif
                            endfunction

    1              0.000004 function! s:on_exit(id, code) abort
                              if get(g:, 'coc_vim_leaving', 0) | return | endif
                              if has('nvim')
                                let s:out_remain_text[a:id] = ''
                                let s:err_remain_text[a:id] = ''
                              endif
                              if has_key(s:running_task, a:id)
                                call remove(s:running_task, a:id)
                              endif
                              call coc#rpc#notify('TaskExit', [a:id, a:code])
                            endfunction

    1              0.000002 function! s:on_stderr(id, msgs)
                              if get(g:, 'coc_vim_leaving', 0) | return | endif
                              if empty(a:msgs)
                                return
                              endif
                              if s:is_vim
                                call coc#rpc#notify('TaskStderr', [a:id, a:msgs])
                              else
                                let remain = get(s:err_remain_text, a:id, '')
                                let eof = (a:msgs == [''])
                                let msgs = copy(a:msgs)
                                if len(remain) > 0
                                  if msgs[0] == ''
                                    let msgs[0] = remain
                                  else
                                    let msgs[0] = remain . msgs[0]
                                  endif
                                endif
                                let last = msgs[len(msgs) - 1]
                                let s:err_remain_text[a:id] = len(last) > 0 ? last : ''
                                " all lines from 0 to n - 2
                                if len(msgs) > 1
                                  call coc#rpc#notify('TaskStderr', [a:id, msgs[:len(msgs)-2]])
                                elseif eof && len(msgs[0]) > 0
                                  call coc#rpc#notify('TaskStderr', [a:id, msgs])
                                endif
                              endif
                            endfunction

    1              0.000003 function! s:on_stdout(id, msgs)
                              if empty(a:msgs)
                                return
                              endif
                              if s:is_vim
                                call coc#rpc#notify('TaskStdout', [a:id, a:msgs])
                              else
                                let remain = get(s:out_remain_text, a:id, '')
                                let eof = (a:msgs == [''])
                                let msgs = copy(a:msgs)
                                if len(remain) > 0
                                  if msgs[0] == ''
                                    let msgs[0] = remain
                                  else
                                    let msgs[0] = remain . msgs[0]
                                  endif
                                endif
                                let last = msgs[len(msgs) - 1]
                                let s:out_remain_text[a:id] = len(last) > 0 ? last : ''
                                " all lines from 0 to n - 2
                                if len(msgs) > 1
                                  call coc#rpc#notify('TaskStdout', [a:id, msgs[:len(msgs)-2]])
                                elseif eof && len(msgs[0]) > 0
                                  call coc#rpc#notify('TaskStdout', [a:id, msgs])
                                endif
                              endif
                            endfunction

    1              0.000006 function! coc#task#running(id)
                              if !has_key(s:running_task, a:id) == 1
                                return v:false
                              endif
                              let job = s:running_task[a:id]
                              if s:is_vim
                                let status = job_status(job)
                                return status ==# 'run'
                              endif
                              let [code] = jobwait([job], 10)
                              return code == -1
                            endfunction

SCRIPT  /Users/philippe/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim
Sourced 1 time
Total time:   0.001534
 Self time:   0.001534

count  total (s)   self (s)
                            " For older Vims without sign_place() the plugin has to manaage the sign ids.
    1              0.000015 let s:first_sign_id = 3000
    1              0.000005 let s:next_sign_id  = s:first_sign_id
                            " Remove-all-signs optimisation requires Vim 7.3.596+.
    1              0.000010 let s:supports_star = v:version > 703 || (v:version == 703 && has("patch596"))


    1              0.000004 function! gitgutter#sign#enable() abort
                              let old_signs = g:gitgutter_signs

                              let g:gitgutter_signs = 1
                              call gitgutter#highlight#define_sign_text_highlights()

                              if !old_signs && !g:gitgutter_highlight_lines && !g:gitgutter_highlight_linenrs
                                call gitgutter#all(1)
                              endif
                            endfunction

    1              0.000003 function! gitgutter#sign#disable() abort
                              let g:gitgutter_signs = 0
                              call gitgutter#highlight#define_sign_text_highlights()

                              if !g:gitgutter_highlight_lines && !g:gitgutter_highlight_linenrs
                                call gitgutter#sign#clear_signs(bufnr(''))
                              endif
                            endfunction

    1              0.000003 function! gitgutter#sign#toggle() abort
                              if g:gitgutter_signs
                                call gitgutter#sign#disable()
                              else
                                call gitgutter#sign#enable()
                              endif
                            endfunction


                            " Removes gitgutter's signs from the buffer being processed.
    1              0.000003 function! gitgutter#sign#clear_signs(bufnr) abort
                              if exists('*sign_unplace')
                                call sign_unplace('gitgutter', {'buffer': a:bufnr})
                                return
                              endif


                              call s:find_current_signs(a:bufnr)

                              let sign_ids = map(values(gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')), 'v:val.id')
                              call s:remove_signs(a:bufnr, sign_ids, 1)
                              call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', {})
                            endfunction


                            " Updates gitgutter's signs in the buffer being processed.
                            "
                            " modified_lines: list of [<line_number (number)>, <name (string)>]
                            " where name = 'added|removed|modified|modified_removed'
    1              0.000003 function! gitgutter#sign#update_signs(bufnr, modified_lines) abort
                              if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
                                call sign_unplace('gitgutter', {'buffer': a:bufnr})

                                let modified_lines = s:handle_double_hunk(a:modified_lines)
                                let signs = map(copy(modified_lines), '{'.
                                      \ '"buffer":   a:bufnr,'.
                                      \ '"group":    "gitgutter",'.
                                      \ '"name":     s:highlight_name_for_change(v:val[1]),'.
                                      \ '"lnum":     v:val[0],'.
                                      \ '"priority": g:gitgutter_sign_priority'.
                                      \ '}')

                                if exists('*sign_placelist')
                                  call sign_placelist(signs)
                                  return
                                endif

                                for sign in signs
                                  call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
                                endfor
                                return
                              endif


                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.

                              call s:find_current_signs(a:bufnr)

                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)

                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            endfunction


                            "
                            " Internal functions
                            "


    1              0.000005 function! s:find_current_signs(bufnr) abort
                              let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
                              if !g:gitgutter_sign_allow_clobber
                                let other_signs = []      " [<line_number (number),...]
                              endif

                              if exists('*getbufinfo')
                                let bufinfo = getbufinfo(a:bufnr)[0]
                                let signs = has_key(bufinfo, 'signs') ? bufinfo.signs : []
                              else
                                let signs = []

                                redir => signlines
                                  silent execute "sign place buffer=" . a:bufnr
                                redir END

                                for signline in filter(split(signlines, '\n')[2:], 'v:val =~# "="')
                                  " Typical sign line before v8.1.0614:  line=88 id=1234 name=GitGutterLineAdded
                                  " We assume splitting is faster than a regexp.
                                  let components = split(signline)
                                  call add(signs, {
                                        \ 'lnum': str2nr(split(components[0], '=')[1]),
                                        \ 'id':   str2nr(split(components[1], '=')[1]),
                                        \ 'name':        split(components[2], '=')[1]
                                        \ })
                                endfor
                              endif

                              for sign in signs
                                if sign.name =~# 'GitGutter'
                                  " Remove orphaned signs (signs placed on lines which have been deleted).
                                  " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                  " line numbers are decremented appropriately.)
                                  if has_key(gitgutter_signs, sign.lnum)
                                    execute "sign unplace" gitgutter_signs[sign.lnum].id
                                  endif
                                  let gitgutter_signs[sign.lnum] = {'id': sign.id, 'name': sign.name}
                                else
                                  if !g:gitgutter_sign_allow_clobber
                                    call add(other_signs, sign.lnum)
                                  endif
                                endif
                              endfor

                              call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
                              if !g:gitgutter_sign_allow_clobber
                                call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)
                              endif
                            endfunction


                            " Returns a list of [<id (number)>, ...]
                            " Sets `s:remove_all_old_signs` as a side-effect.
    1              0.000007 function! s:obsolete_gitgutter_signs_to_remove(bufnr, new_gitgutter_signs_line_numbers) abort
                              let signs_to_remove = []  " list of [<id (number)>, ...]
                              let remove_all_signs = 1
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                              for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
                              endfor
                              let s:remove_all_old_signs = remove_all_signs
                              return signs_to_remove
                            endfunction


    1              0.000004 function! s:remove_signs(bufnr, sign_ids, all_signs) abort
                              if a:all_signs && s:supports_star && (g:gitgutter_sign_allow_clobber || empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs')))
                                execute "sign unplace * buffer=" . a:bufnr
                              else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
                              endif
                            endfunction


    1              0.000003 function! s:upsert_new_gitgutter_signs(bufnr, modified_lines) abort
                              if !g:gitgutter_sign_allow_clobber
                                let other_signs = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
                              endif
                              let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')

                              let modified_lines = s:handle_double_hunk(a:modified_lines)

                              for line in modified_lines
                                let line_number = line[0]  " <number>
                                if g:gitgutter_sign_allow_clobber || index(other_signs, line_number) == -1  " don't clobber others' signs
                                  let name = s:highlight_name_for_change(line[1])
                                  if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
                                  endif
                                endif
                              endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.
                            endfunction


                            " Handle special case where the first line is the site of two hunks:
                            " lines deleted above at the start of the file, and lines deleted
                            " immediately below.
    1              0.000002 function! s:handle_double_hunk(modified_lines)
                              if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
                              endif

                              return a:modified_lines
                            endfunction


    1              0.000002 function! s:next_sign_id() abort
                              let next_id = s:next_sign_id
                              let s:next_sign_id += 1
                              return next_id
                            endfunction


                            " Only for testing.
    1              0.000002 function! gitgutter#sign#reset()
                              let s:next_sign_id  = s:first_sign_id
                            endfunction


    1              0.000003 function! s:highlight_name_for_change(text) abort
                              if a:text ==# 'added'
                                return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
                                return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif
                            endfunction



SCRIPT  /Users/philippe/.vim/plugged/vim-polyglot/autoload/jsx_pretty/comment.vim
Sourced 1 time
Total time:   0.000280
 Self time:   0.000280

count  total (s)   self (s)
    1              0.000022 if has_key(g:polyglot_is_disabled, 'jsx')
                              finish
    1              0.000002 endif

    1              0.000005 function! jsx_pretty#comment#update_commentstring(original)
                              let line = getline(".")
                              let col = col('.')
                              if line !~# '^\s*$' && line[: col - 1] =~# '^\s*$'    " skip indent
                                let col = indent('.') + 1
                              endif
                              let syn_start = s:syn_name(line('.'), col)
                              let save_cursor = getcurpos()

                              if syn_start =~? '^jsx'
                                if line =~ '^\s*//'
                                  let &l:commentstring = '// %s'
                                elseif s:syn_contains(line('.'), col, 'jsxTaggedRegion')
                                  let &l:commentstring = '<!-- %s -->'
                                elseif syn_start =~? '^jsxAttrib'
                                  let &l:commentstring = '// %s'
                                else
                                  let &l:commentstring = '{/* %s */}'
                                endif
                              else
                                let &l:commentstring = a:original
                              endif

                              " Restore the cursor position
                              call setpos('.', save_cursor)
                            endfunction

    1              0.000006 function! s:syn_name(lnum, cnum)
                              let syn_id = get(synstack(a:lnum, a:cnum), -1)
                              return synIDattr(syn_id, "name")
                            endfunction

    1              0.000003 function! s:syn_contains(lnum, cnum, syn_name)
                              let stack = synstack(a:lnum, a:cnum)
                              let syn_names = map(stack, 'synIDattr(v:val, "name")')
                              return index(syn_names, a:syn_name) >= 0
                            endfunction

FUNCTION  FugitiveExtractGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:215
Called 47 times
Total time:   0.027910
 Self time:   0.019665

count  total (s)   self (s)
   47   0.001414   0.000764   let path = s:Slash(a:path)
   47              0.000410   if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
   47              0.000138   elseif empty(path)
                                return ''
   47              0.000861   elseif isdirectory(path)
   45              0.001337     let path = fnamemodify(path, ':p:s?/$??')
    2              0.000002   else
    2              0.000042     let path = fnamemodify(path, ':p:h:s?/$??')
   47              0.000044   endif
   47              0.000848   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
   47              0.000281   if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
   47              0.000041   endif
   47              0.004481   let root = resolve(path)
   47              0.000230   if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
   47              0.000047   endif
   47              0.000211   let previous = ""
   47              0.000858   let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
   47   0.002043   0.001016   call s:Tree(env_git_dir)
   50              0.000181   while root !=# previous
   50              0.000589     if root =~# '\v^//%([^/]+/?)?$'
                                  break
   50              0.000042     endif
   50   0.003141   0.001042     if index(s:CeilingDirectories(), root) >= 0
                                  break
   50              0.000034     endif
   50              0.000383     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
   50              0.000239     elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
   50              0.000035     endif
   50              0.001028     let dir = substitute(root, '[\/]$', '', '') . '/.git'
   50              0.001264     let type = getftype(dir)
   50   0.005193   0.000860     if type ==# 'dir' && FugitiveIsGitDir(dir)
   47              0.000117       return dir
    3              0.000009     elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
    3              0.000008     elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
    3   0.000164   0.000029     elseif FugitiveIsGitDir(root)
                                  return root
    3              0.000002     endif
    3              0.000007     let previous = root
    3              0.000016     let root = fnamemodify(root, ':h')
    3              0.000003   endwhile
                              return ''

FUNCTION  <SNR>3_SynSet()
    Defined: /usr/local/Cellar/neovim/HEAD-759a054/share/nvim/runtime/syntax/synload.vim:33
Called 5 times
Total time:   0.211869
 Self time:   0.007070

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    5              0.000062   syn clear
    5              0.000032   if exists("b:current_syntax")
                                unlet b:current_syntax
    5              0.000006   endif

    5              0.000031   let s = expand("<amatch>")
    5              0.000015   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    5              0.000012   elseif s == "OFF"
                                let s = ""
    5              0.000003   endif

    5              0.000010   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
   10              0.000090     for name in split(s, '\.')
    5   0.211449   0.006649       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
   10              0.000023     endfor
    5              0.000006   endif

FUNCTION  <SNR>246_is_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:281
Called 28 times
Total time:   0.000184
 Self time:   0.000184

count  total (s)   self (s)
   28              0.000161   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:28
Called 22 times
Total time:   0.000473
 Self time:   0.000473

count  total (s)   self (s)
   22              0.000317   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
   22              0.000023   endif

FUNCTION  <SNR>91_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:126
Called 1865 times
Total time:   0.082697
 Self time:   0.082697

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values

                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
 1865              0.012436   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
 1865              0.001897   endif
 1865              0.013881   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
 1865              0.001337   endif

 1865              0.007479   for val in a:colors
 1865              0.009008     if !empty(val) && val !=# 'NONE'
 1865              0.003333       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>64_invoke_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:177
Called 40 times
Total time:   0.516089
 Self time:   0.005044

count  total (s)   self (s)
   40   0.003231   0.000811   let builder = airline#builder#new(a:context)
   40   0.087688   0.001541   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   40              0.000074   if err == 1
   40   0.423181   0.000702     let a:context.line = builder.build()
   40              0.000543     let s:contexts[a:context.winnr] = a:context
   40              0.000313     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
   40              0.000851     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
   40              0.000054   endif

FUNCTION  357()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:60
Called 15 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
   15              0.000080 	return join(self.list[self.col+1 : ], '')

FUNCTION  358()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:64
Called 30 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
   30              0.000123 	return get(self.list, self.col, "")

FUNCTION  coc#client#get_channel()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:141
Called 194 times
Total time:   0.004707
 Self time:   0.004707

count  total (s)   self (s)
  194              0.000765   if s:is_vim
                                return a:client['channel']
  194              0.000263   endif
  194              0.002483   return a:client['chan_id']

FUNCTION  <SNR>26_collect()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:861
Called 2 times
Total time:   0.000495
 Self time:   0.000495

count  total (s)   self (s)
    2              0.000003   try
    2              0.000214     return filereadable(a:temps.result) ? readfile(a:temps.result) : []
    2              0.000005   finally
    4              0.000018     for tf in values(a:temps)
    2              0.000233       silent! call delete(tf)
    4              0.000007     endfor
    2              0.000003   endtry

FUNCTION  <SNR>149__reset()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/History.vim:34
Called 16 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
   16              0.000078 	let s:cmdhist = []
   16              0.000036 	let s:count = 0
   16              0.000055 	let s:is_match_mode = 0 " <Up>/<Down>: true, <C-n>/<C-p>: false

FUNCTION  1()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:14
Called 12 times
Total time:   0.002033
 Self time:   0.001268

count  total (s)   self (s)
   12              0.000033     let l:prependWorkingDir = 0

   12   0.000256   0.000145     if nerdtree#runningWindows()
                                    let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
   12              0.000010     else
   12              0.000072         let l:prependWorkingDir = a:pathStr !~# '^/'
   12              0.000009     endif

   12              0.000027     let l:result = a:pathStr

   12              0.000019     if l:prependWorkingDir
   11              0.000475         let l:result = getcwd()

   11   0.000479   0.000136         if l:result[-1:] == nerdtree#slash()
                                        let l:result = l:result . a:pathStr
   11              0.000009         else
   11   0.000473   0.000162             let l:result = l:result . nerdtree#slash() . a:pathStr
   11              0.000008         endif
   12              0.000007     endif

   12              0.000019     return l:result

FUNCTION  3()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:47
Called 487 times
Total time:   0.064662
 Self time:   0.046404

count  total (s)   self (s)
  487   0.021429   0.010463     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)

  487              0.001010     if self.isExecutable
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
  487              0.000445     endif

  487              0.002051     let self._bookmarkNames = []
  487   0.013512   0.006220     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
  487              0.000874     endfor
  487              0.002518     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks ==# 1
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
  487              0.000418     endif

  487              0.000839     if self.isSymLink
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
  487              0.000377     endif

  487              0.000863     if self.isReadOnly
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
  487              0.000362     endif

FUNCTION  airline#extensions#undotree#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/undotree.vim:11
Called 16 times
Total time:   0.000486
 Self time:   0.000486

count  total (s)   self (s)
   16              0.000076   if exists('t:undotree')
                                if &ft == 'undotree'
                                  if exists('*t:undotree.GetStatusLine')
                                    call airline#extensions#apply_left_override('undo', '%{exists("t:undotree") ? t:undotree.GetStatusLine() : ""}')
                                  else
                                    call airline#extensions#apply_left_override('undotree', '%f')
                                  endif
                                endif

                                if &ft == 'diff' && exists('*t:diffpanel.GetStatusLine')
                                  call airline#extensions#apply_left_override('diff', '%{exists("t:diffpanel") ? t:diffpanel.GetStatusLine() : ""}')
                                endif
   16              0.000011   endif

FUNCTION  airline#async#vcs_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:57
Called 8 times
Total time:   0.007785
 Self time:   0.000563

count  total (s)   self (s)
    8              0.000033   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_untracked(a:config, a:file)
    8              0.000011   else
                                " nvim async or vim without job-feature
    8   0.007566   0.000344     noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
    8              0.000012   endif

FUNCTION  vital#_easymotion#Over#Exception#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Exception.vim:5
Called 1 time
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    1              0.000056     return map({'throw': '', 'throw_cmd': '', 'set_prefix': '', 'error': ''},  'function("s:" . v:key)')

FUNCTION  coc#highlight#clear_match_group()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:202
Called 15 times
Total time:   0.001514
 Self time:   0.001514

count  total (s)   self (s)
   15              0.000178   let winid = a:winid == 0 ? win_getid() : a:winid
   15              0.000249   if empty(getwininfo(winid))
                                " not valid
    3              0.000004     return
   12              0.000013   endif
   12              0.000031   if s:clear_match_by_window
   12              0.000138     let arr = filter(getmatches(winid), 'v:val["group"] =~# "'.a:match.'"')
   12              0.000041     for item in arr
                                  call matchdelete(item['id'], winid)
   12              0.000026     endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  let arr = filter(getmatches(), 'v:val["group"] =~# "'.a:match.'"')
                                  for item in arr
                                    call matchdelete(item['id'])
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
   12              0.000010   endif

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:93
Called 40 times
Total time:   0.086147
 Self time:   0.010623

count  total (s)   self (s)
  278              0.000722     for Fn in a:list
  278   0.083771   0.008248       let code = call(Fn, a:000)
  278              0.000574       if code != 0
   40              0.000063         return code
  238              0.000195       endif
  238              0.000202     endfor
                                return 0

FUNCTION  <SNR>26_common_sink()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:264
Called 1 time
Total time:   0.292696
 Self time:   0.008291

count  total (s)   self (s)
    1              0.000004   if len(a:lines) < 2
                                return
    1              0.000001   endif
    1              0.000004   let key = remove(a:lines, 0)
    1              0.000004   let Cmd = get(a:action, key, 'e')
    1              0.000007   if type(Cmd) == type(function('call'))
                                return Cmd(a:lines)
    1              0.000001   endif
    1              0.000002   if len(a:lines) > 1
                                augroup fzf_swap
                                  autocmd SwapExists * let v:swapchoice='o'| call s:warn('fzf: E325: swap file exists: '.s:fzf_expand('<afile>'))
                                augroup END
    1              0.000001   endif
    1              0.000001   try
    1   0.000041   0.000022     let empty = empty(s:fzf_expand('%')) && line('$') == 1 && empty(getline(1)) && !&modified
                                " Preserve the current working directory in case it's changed during
                                " the execution (e.g. `set autochdir` or `autocmd BufEnter * lcd ...`)
    1              0.000006     let cwd = exists('w:fzf_pushd') ? w:fzf_pushd.dir : expand('%:p:h')
    2              0.000007     for item in a:lines
    1              0.000011       if item[0] != '~' && item !~ (s:is_win ? '^[A-Z]:\' : '^/')
    1              0.000002         let sep = s:is_win ? '\' : '/'
    1              0.000011         let item = join([cwd, item], cwd[len(cwd)-1] == sep ? '' : sep)
    1              0.000001       endif
    1              0.000001       if empty
    1   0.292489   0.008103         execute 'e' s:escape(item)
    1              0.000006         let empty = 0
                                  else
                                    call s:open(Cmd, item)
    1              0.000004       endif
    1              0.000013       if !has('patch-8.0.0177') && !has('nvim-0.2') && exists('#BufEnter') && isdirectory(item)
                                    doautocmd BufEnter
    1              0.000001       endif
    2              0.000009     endfor
                              catch /^Vim:Interrupt$/
    1              0.000001   finally
    1              0.000015     silent! autocmd! fzf_swap
    1              0.000001   endtry

FUNCTION  399()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim:117
Called 15 times
Total time:   0.005034
 Self time:   0.002311

count  total (s)   self (s)
   15   0.001248   0.000302 	if a:cmdline.is_input("<Over>(buffer-complete)")		|| a:cmdline.is_input("<Over>(buffer-complete-prev)")
                            		if self.complete(a:cmdline) == -1
                            			call s:_finish()
                            			call a:cmdline.setchar('')
                            			return
                            		endif
                            		if a:cmdline.is_input("<Over>(buffer-complete-prev)")
                            			let s:count = len(s:complete_list) - 1
                            		endif
                            		call a:cmdline.setchar('')
                            		call a:cmdline.tap_keyinput("Completion")
                            " 	elseif a:cmdline.is_input("\<Tab>", "Completion")
   15   0.000995   0.000312 	elseif a:cmdline.is_input("<Over>(buffer-complete)", "Completion")		|| a:cmdline.is_input("\<Right>", "Completion")
                            		call a:cmdline.setchar('')
                            		let s:count += 1
                            		if s:count >= len(s:complete_list)
                            			let s:count = 0
                            		endif
   15   0.000913   0.000329 	elseif a:cmdline.is_input("<Over>(buffer-complete-prev)", "Completion")		|| a:cmdline.is_input("\<Left>", "Completion")
                            		call a:cmdline.setchar('')
                            		let s:count -= 1
                            		if s:count < 0
                            			let s:count = len(s:complete_list) - 1
                            		endif
   15              0.000014 	else
   15   0.000303   0.000143 		if a:cmdline.untap_keyinput("Completion")
                            			call a:cmdline.callevent("on_char_pre")
   15              0.000014 		endif
   15   0.000660   0.000310 		call s:_finish()
   15              0.000023 		return
                            	endif
                            	call a:cmdline.setline(s:line)
                            	call a:cmdline.insert(s:complete_list[s:count], s:pos)
                            	if len(s:complete_list) > 1
                            		let &statusline = s:_as_statusline(s:complete_list, s:count)
                            		redrawstatus
                            	endif
                            	if len(s:complete_list) == 1
                            		call a:cmdline.untap_keyinput("Completion")
                            	endif

FUNCTION  <SNR>26_version_requirement()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:157
Called 1 time
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    1              0.000013   let val = split(a:val, '\.')
    1              0.000006   let min = split(a:min, '\.')
    3              0.000010   for idx in range(0, len(min) - 1)
    3              0.000010     let v = get(val, idx, 0)
    3              0.000011     if     v < min[idx] | return 0
    4              0.000009     elseif v > min[idx] | return 1
    2              0.000002     endif
    2              0.000002   endfor
                              return 1

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:21
Called 65 times
Total time:   0.204431
 Self time:   0.014210

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.

   65   0.075833   0.002167   if gitgutter#utility#is_active(a:bufnr)

   42              0.000409     if has('patch-7.4.1559')
   42              0.000685       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
   42              0.000053     endif
   42   0.016011   0.001086     let how = s:setup_path(a:bufnr, l:Callback)
   42              0.000238     if [how] == ['async']  " avoid string-to-number conversion if how is a number
    1              0.000001       return
   41              0.000050     endif

   41   0.005075   0.001223     if a:force || s:has_fresh_changes(a:bufnr)

    4              0.000011       let diff = 'NOT SET'
    4              0.000006       try
    4   0.099312   0.001534         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
    4              0.000010       endtry

    4              0.000025       if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
    4              0.000014       endif

   41              0.000043     endif
   64              0.000089   endif

FUNCTION  AirlineWebDevIcons()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:578
Called 18 times
Total time:   0.002197
 Self time:   0.001153

count  total (s)   self (s)
   18              0.000204   let w:airline_section_x = get(w:, 'airline_section_x', get(g:, 'airline_section_x', ''))
   18              0.000098   let w:airline_section_x .= ' %{WebDevIconsGetFileTypeSymbol()} '
   18   0.001558   0.000514   let hasFileFormatEncodingPart = airline#parts#ffenc() !=? ''
   18              0.000185   if g:webdevicons_enable_airline_statusline_fileformat_symbols && hasFileFormatEncodingPart
   18              0.000080     let w:airline_section_y = ' %{&fenc . " " . WebDevIconsGetFileFormatSymbol()} '
   18              0.000018   endif

FUNCTION  <SNR>130__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:21
Called 1 time
Total time:   0.004582
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.004579   0.000033 	let s:List = s:V.import("Data.List")

FUNCTION  <SNR>90_create()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:17
Called 7 times
Total time:   0.002016
 Self time:   0.001666

count  total (s)   self (s)
    7              0.000016   let _ = ''
   14              0.000060   for idx in range(len(a:parts))
    7   0.000139   0.000085     let part = airline#parts#get(a:parts[idx])
    7              0.000014     let val = ''
    7              0.000030     let add_sep = get(l:, 'add_sep', 0)

    7              0.000030     if exists('part.function')
    7              0.000024       let func = (part.function).'()'
                                elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let t = ''
                                    if !add_sep
                                      let t = s:spc.g:airline_right_alt_sep.s:spc
                                    endif
                                    let val = t.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
    7              0.000005     endif

    7              0.000031     let minwidth = get(part, 'minwidth', 0)

    7              0.000016     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
    7              0.000027     elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
    7              0.000006     else
    7              0.000052       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
    7              0.000013       let add_sep = 0
    7              0.000006     endif

    7              0.000024     if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
    7              0.000005     endif

    7   0.000424   0.000128     let val .= s:wrap_accent(part, partval)
    7              0.000027     let _ .= val
   14              0.000067   endfor
    7              0.000016   return _

FUNCTION  gitgutter#utility#system()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:92
Called 1 time
Total time:   0.051879
 Self time:   0.000423

count  total (s)   self (s)
    1   0.000067   0.000012   call gitgutter#debug#log(a:cmd, a:000)

    1   0.000083   0.000013   call s:use_known_shell()
    1   0.051150   0.000154   silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
    1   0.000544   0.000210   call s:restore_shell()

    1              0.000022   return output

FUNCTION  fzf#exec()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:170
Called 5 times
Total time:   0.010032
 Self time:   0.000688

count  total (s)   self (s)
    5              0.000047   if !exists('s:exec')
    1              0.000064     if executable(s:fzf_go)
    1              0.000006       let s:exec = s:fzf_go
                                elseif executable('fzf')
                                  let s:exec = 'fzf'
                                elseif input('fzf executable not found. Download binary? (y/n) ') =~? '^y'
                                  redraw
                                  call fzf#install()
                                  return fzf#exec()
                                else
                                  redraw
                                  throw 'fzf executable not found'
    1              0.000001     endif
    5              0.000004   endif

    5              0.000026   if a:0 && !has_key(s:checked, a:1)
    1              0.000004     let command = s:exec . ' --version'
    1   0.009315   0.000045     let output = systemlist(command)
    1              0.000012     if v:shell_error || empty(output)
                                  throw printf('Failed to run "%s": %s', command, output)
    1              0.000001     endif
    1              0.000038     let fzf_version = matchstr(output[-1], '[0-9.]\+')
    1   0.000108   0.000034     if s:version_requirement(fzf_version, a:1)
    1              0.000004       let s:checked[a:1] = 1
    1              0.000004       return s:exec
                                elseif a:0 < 2 && input(printf('You need fzf %s or above. Found: %s. Download binary? (y/n) ', a:1, fzf_version)) =~? '^y'
                                  redraw
                                  call fzf#install()
                                  return fzf#exec(a:1, 1)
                                else
                                  throw printf('You need to upgrade fzf (required: %s or above)', a:1)
                                endif
    4              0.000004   endif

    4              0.000013   return s:exec

FUNCTION  <SNR>9_guess()
    Defined: ~/.vim/plugged/vim-polyglot/ftdetect/polyglot.vim:2701
Called 16 times
Total time:   0.033487
 Self time:   0.026805

count  total (s)   self (s)
   16              0.000080     let options = {}
   16              0.000042     let ccomment = 0
   16              0.000030     let podcomment = 0
   16              0.000029     let triplequote = 0
   16              0.000029     let backtick = 0
   16              0.000027     let xmlcomment = 0
   16              0.000031     let heredoc = ''
   16              0.000029     let minindent = 10
   16              0.000036     let spaces_minus_tabs = 0
   16              0.000025     let lineno = 0
   16              0.000045     let stack = [0]
   16              0.000105     let indents = { '2': 0, '3': 0, '4': 0, '6': 0, '8': 0 }

  201              0.000327     for line in a:lines
  185              0.000307       let lineno += 1

  185              0.001055       if line =~# '^\s*$'
   19              0.000050         continue
  166              0.000095       endif

  166              0.000835       if line =~# '^\s*/\*'
                                    let ccomment = 1
  166              0.000091       endif
  166              0.000180       if ccomment
                                    if line =~# '\*/'
                                      let ccomment = 0
                                    endif
                                    continue
  166              0.000089       endif

  166              0.000510       if line =~# '^=\w'
                                    let podcomment = 1
  166              0.000092       endif
  166              0.000182       if podcomment
                                    if line =~# '^=\%(end\|cut\)\>'
                                      let podcomment = 0
                                    endif
                                    continue
  166              0.000089       endif

  166              0.000181       if triplequote
                                    if line =~# '^[^"]*"""[^"]*$'
                                      let triplequote = 0
                                    endif
                                    continue
  166              0.002197       elseif line =~# '^[^"]*"""[^"]*$'
                                    let triplequote = 1
  166              0.000094       endif

  166              0.000175       if backtick
                                    if line =~# '^[^`]*`[^`]*$'
                                      let backtick = 0
                                    endif
                                    continue
  166              0.000433       elseif &filetype ==# 'go' && line =~# '^[^`]*`[^`]*$'
                                    let backtick = 1
  166              0.000095       endif

  166              0.000890       if line =~# '^\s*<\!--'
                                    let xmlcomment = 1
  166              0.000109       endif
  166              0.000189       if xmlcomment
                                    if line =~# '-->'
                                      let xmlcomment = 0
                                    endif
                                    continue
  166              0.000091       endif

                                  " This is correct order because both "<<EOF" and "EOF" matches end
  166              0.000288       if heredoc != ''
                                    if line =~# heredoc
                                      let heredoc = ''
                                    endif
                                    continue
  166              0.000095       endif
  166              0.001245       let herematch = matchlist(line, '\C<<\W*\([A-Z]\+\)\s*$')
  166              0.000395       if len(herematch) > 0
                                    let heredoc = herematch[1] . '$'
  166              0.000097       endif

  166              0.000338       if line[0] == "\t"
                                    let spaces_minus_tabs -= 1
  166              0.000101       else
  166              0.000310         if line[0] == " "
  117              0.000258           let spaces_minus_tabs += 1
  166              0.000102         endif
  166              0.001222         let indent = len(matchstr(line, '^ *'))
  187              0.000386         while stack[-1] > indent
   21              0.000063           call remove(stack, -1)
  187              0.000148         endwhile

  166              0.000426         let indent_inc = indent - stack[-1]

  166              0.000476         if indent_inc == 0 && len(stack) > 1
   94              0.000231           let indent_inc = indent - stack[-2]
  166              0.000100         endif

  166              0.000546         if has_key(indents, indent_inc)
  117              0.000298           let indents[indent_inc] += 1
  117              0.000201           let prev_indent = indent
  166              0.000100         endif

  166              0.000301         if stack[-1] != indent
   23              0.000069           call add(stack, indent)
  166              0.000095         endif
  166              0.000093       endif
  182              0.000278     endfor

   16              0.000055     if spaces_minus_tabs < 0
                                  setlocal noexpandtab
                                  let &l:shiftwidth=&tabstop
                                  return 1
   16              0.000015     endif

   16   0.006993   0.000311     let shiftwidth = s:get_shiftwidth(indents)

   16              0.000030     if shiftwidth > 0
    2              0.000014       setlocal expandtab
    2              0.000016       let &l:shiftwidth=shiftwidth
    2              0.000002       try
                                    " Sunchronize tabstop with shiftwidth
    2              0.000009         let &l:softtabstop = -1
                                  catch /^Vim\%((\a\+)\)\=:E487/
                                    " -1 was not supported before Vim 7.4
                                    let &l:softtabstop = a:num_spaces
    2              0.000002       endtry
    2              0.000002       return 1
   14              0.000009     endif

   14              0.000014     return 0

FUNCTION  <SNR>61_setup_styledEmmetAbbreviation()
    Defined: ~/.vim/plugged/emmet-vim/plugin/emmet.vim:177
Called 5 times
Total time:   0.000242
 Self time:   0.000242

count  total (s)   self (s)
    5              0.000072   if index(['javascript', 'javascriptreact', 'typescript', 'typescriptreact'], &filetype) != -1
    1              0.000056     syntax match styledEmmetAbbreviation "[a-z0-9#+!%]\+" containedin=styledDefinition contained
    5              0.000006   endif

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:14
Called 241 times
Total time:   0.026897
 Self time:   0.007888

count  total (s)   self (s)
  241   0.026628   0.007619   return airline#extensions#coc#get('error')

FUNCTION  vital#_easymotion#Over#Commandline#Modules#ExceptionExit#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionExit.vim:5
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  vital#_easymotion#Over#Commandline#Modules#ExceptionMessage#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionMessage.vim:5
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  coc#util#do_autocmd()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:738
Called 8 times
Total time:   0.000231
 Self time:   0.000231

count  total (s)   self (s)
    8              0.000167   if exists('#User#'.a:name)
                                exe 'doautocmd <nomodeline> User '.a:name
    8              0.000013   endif

FUNCTION  325()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:277
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002 	let self.variables.exit = 1
    1              0.000004 	let self.variables.exit_code = get(a:, 1, 0)

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:190
Called 335 times
Total time:   0.010237
 Self time:   0.010237

count  total (s)   self (s)
  335              0.004924   if has_key(s:contexts, a:winnr)
  335              0.004289     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:199
Called 335 times
Total time:   1.552512
 Self time:   0.086947

count  total (s)   self (s)
  335              0.002504   if !has_key(s:contexts, a:winnr)
                                return ''
  335              0.000541   endif
  335              0.002652   let context = s:contexts[a:winnr]

  335              0.001982   if get(w:, 'airline_active', 1)
  272              0.001710     let l:m = mode(1)
  272              0.000878     if l:m ==# "i"
   12              0.000043       let l:mode = ['insert']
  260              0.002850     elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
  260              0.000660     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
  260              0.000662     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
  260              0.004310     elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
  260              0.000858     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
  260              0.000669     elseif l:m[0] ==# "c"
   10              0.000033       let l:mode = ['commandline']
  250              0.000594     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
  250              0.000745     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['insert']
                                  let l:m = 'ni'
  250              0.000308     else
  250              0.001521       let l:mode = ['normal']
  272              0.000288     endif
  272              0.002467     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
  272              0.000260     endif
  272              0.003212     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
  272              0.001017       let l:m = l:m[0]
  272              0.000259     endif
  272              0.002419     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   63              0.000066   else
   63              0.000211     let l:mode = ['inactive']
   63              0.000489     let w:airline_current_mode = get(g:airline_mode_map, '__')
  335              0.000336   endif

  335              0.002392   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
  335              0.000295   endif

  335              0.001075   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
  335              0.000316   endif

  335              0.003819   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
  335              0.000275   endif

  335              0.001033   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
  335              0.000250   endif

  335              0.000839   if &readonly || ! &modifiable
   85              0.000470     call add(l:mode, 'readonly')
  335              0.000301   endif

  335              0.004723   let mode_string = join(l:mode)
  335              0.002730   if get(w:, 'airline_lastmode', '') != mode_string
   35   0.023804   0.000875     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   35   1.436766   0.002076     call airline#highlighter#highlight(l:mode, context.bufnr)
   35   0.008494   0.000548     call airline#util#doautocmd('AirlineModeChanged')
   35              0.000192     let w:airline_lastmode = mode_string
  335              0.000286   endif

  335              0.000668   return ''

FUNCTION  <SNR>129__is_valid_highlight()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:400
Called 1 time
Total time:   0.000589
 Self time:   0.000039

count  total (s)   self (s)
    1   0.000563   0.000013 	let highlight = s:Highlight.get(a:name)
    1              0.000003 	if empty(highlight)
                            		return 0
    1              0.000001 	endif

    1              0.000008 	if has("gui_running")	&& (has_key(highlight, "guifg") || has_key(highlight, "guibg"))
                            		return 1
    1              0.000006 	elseif (has_key(highlight, "ctermfg") || has_key(highlight, "ctermbg"))
                            		return 1
    1              0.000001 	endif
    1              0.000001 	return 0

FUNCTION  <SNR>123_fzf()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:272
Called 2 times
Total time:   0.229115
 Self time:   0.000419

count  total (s)   self (s)
    2   0.066424   0.000050   call s:check_requirements()

    2              0.000015   let [extra, bang] = [{}, 0]
    2              0.000011   if len(a:extra) <= 1
                                let first = get(a:extra, 0, 0)
                                if type(first) == s:TYPE.dict
                                  let extra = first
                                else
                                  let bang = first
                                endif
    2              0.000006   elseif len(a:extra) == 2
    2              0.000007     let [extra, bang] = a:extra
                              else
                                throw 'invalid number of arguments'
    2              0.000001   endif

    2              0.000017   let eopts  = has_key(extra, 'options') ? remove(extra, 'options') : ''
    2              0.000067   let merged = extend(copy(a:opts), extra)
    2   0.001126   0.000078   call s:merge_opts(merged, eopts)
    2   0.161398   0.000124   return fzf#run(s:wrap(a:name, merged, bang))

FUNCTION  nerdtree#renderView()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:257
Called 40 times
Total time:   0.404592
 Self time:   0.002627

count  total (s)   self (s)
   40   0.404536   0.002572     call b:NERDTree.render()

FUNCTION  <SNR>141__redraw()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:56
Called 15 times
Total time:   0.130496
 Self time:   0.129963

count  total (s)   self (s)
   15   0.000637   0.000363 	let left = a:cmdline.get_prompt() . a:cmdline.getline() . (empty(a:cmdline.line.pos_char()) ? " " : "")
   15              0.000060 	let width = len(left) + 1

   15   0.000139   0.000101 	if a:cmdline.get_suffix() != ""
                            		let width += len(s:suffix(left, a:cmdline.get_suffix())) - 1
   15              0.000014 	endif

   15              0.000090 	if &columns >= width && &columns <= s:old_width && s:old_width >= width
                            		redraw
                            		normal! :
   15              0.000029 	elseif &columns <= width
                            		normal! :
   15              0.000011 	else
   15              0.128218 		redraw
   15              0.000063 	endif
   15              0.000129 	let s:old_width = width

   15   0.000409   0.000242 	call s:cmdheight.save()
   15   0.000346   0.000293 	let height = max([(width - 1) / (&columns) + 1, s:cmdheight.get()])
   15              0.000053 	if height > &cmdheight || &cmdheight > height
                            		let &cmdheight = height
                            		redraw
   15              0.000012 	endif

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:49
Called 1687 times
Total time:   0.048674
 Self time:   0.048674

count  total (s)   self (s)
 1687              0.012223   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 1687              0.001668   endif
 1687              0.016834   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 1687              0.011455   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  coc#util#get_format_opts()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:944
Called 2 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    2              0.000039   if a:bufnr && bufloaded(a:bufnr)
    2              0.000024     let tabsize = getbufvar(a:bufnr, '&shiftwidth')
    2              0.000005     if tabsize == 0
                                  let tabsize = getbufvar(a:bufnr, '&tabstop')
    2              0.000003     endif
    2              0.000013     return [tabsize, getbufvar(a:bufnr, '&expandtab')]
                              endif
                              let tabsize = &shiftwidth == 0 ? &tabstop : &shiftwidth
                              return [tabsize, &expandtab]

FUNCTION  <SNR>106_has_fresh_changes()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:162
Called 40 times
Total time:   0.003852
 Self time:   0.002862

count  total (s)   self (s)
   40   0.003805   0.002815   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  400()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim:164
Called 15 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                            " 	redrawstatus

FUNCTION  <SNR>128__runtime()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:251
Called 27 times
Total time:   0.057670
 Self time:   0.011207

count  total (s)   self (s)
   27   0.057631   0.011169   execute 'runtime' fnameescape(a:path)

FUNCTION  <SNR>246_is_modified_and_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:285
Called 12 times
Total time:   0.002196
 Self time:   0.002196

count  total (s)   self (s)
   12              0.002180   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  airline#util#try_focusgained()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:203
Called 3 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
                              " Ignore lasts for at most one second and is cleared on the first
                              " focusgained. We use ignore to prevent system() calls from triggering
                              " FocusGained (which occurs 100% on win32 and seem to sometimes occur under
                              " tmux).
    3              0.000074   let dt = localtime() - s:focusgained_ignore_time
    3              0.000021   let s:focusgained_ignore_time = 0
    3              0.000013   return dt >= 1

FUNCTION  239()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:259
Called 1 time
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    1              0.000004     let rootLine = 1
    4              0.000078     while rootLine <= line('$') && getline(rootLine) !~# '^\(/\|<\)'
    3              0.000015         let rootLine = rootLine + 1
    4              0.000006     endwhile
    1              0.000002     return rootLine

FUNCTION  401()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim:169
Called 1 time
Total time:   0.000038
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000035   0.000017 	call s:_finish()
    1              0.000002 	unlet! s:complete

FUNCTION  <SNR>63_DevIconsGetArtifactFix()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:542
Called 1480 times
Total time:   0.030101
 Self time:   0.030101

count  total (s)   self (s)
 1480              0.009385   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
 1480              0.001743   else
 1480              0.004078     let artifactFix = ''
 1480              0.001600   endif

 1480              0.005047   return artifactFix

FUNCTION  <SNR>111_reset_summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:24
Called 4 times
Total time:   0.000267
 Self time:   0.000114

count  total (s)   self (s)
    4   0.000262   0.000109   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim:31
Called 932 times
Total time:   0.353798
 Self time:   0.031151

count  total (s)   self (s)
  932   0.352976   0.030329   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:279
Called 35 times
Total time:   0.001795
 Self time:   0.001393

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
   35              0.000831   let g:airline#visual_active = (mode() =~? '[vs]')
   35   0.000836   0.000435   call airline#update_tabline()

FUNCTION  319()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:243
Called 5 times
Total time:   0.000574
 Self time:   0.000270

count  total (s)   self (s)
    5   0.000509   0.000206 	let key = s:Keymapping.as_key_config(a:rhs)
    5              0.000020 	let key.noremap = 1
    5              0.000035 	let self.variables.keymapping[a:lhs] = key

FUNCTION  <SNR>137_capture()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Message.vim:49
Called 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000001   try
    1              0.000004     redir => out
    1              0.000029     silent execute a:command
    1              0.000002   finally
    1              0.000004     redir END
    1              0.000001   endtry
    1              0.000002   return out

FUNCTION  FugitiveWorkTree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:151
Called 271 times
Total time:   0.046347
 Self time:   0.011964

count  total (s)   self (s)
  271   0.046097   0.011713   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  <SNR>26_escape()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:231
Called 7 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
    7              0.000051   let path = fnameescape(a:path)
    7              0.000031   return s:is_win ? escape(path, '$') : path

FUNCTION  vital#_easymotion#Over#Commandline#Modules#NoInsert#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/NoInsert.vim:5
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000023     return map({'make_special_chars': '', 'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>129__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:21
Called 1 time
Total time:   0.021833
 Self time:   0.000121

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.007382   0.000013 	let s:String  = s:V.import("Over.String")
    1   0.002902   0.000018 	let s:Signals = s:V.import("Over.Signals")
    1   0.002130   0.000017 	let s:Input = s:V.import("Over.Input")
    1   0.002293   0.000015 	let s:Keymapping = s:V.import("Over.Keymapping")
    1   0.002203   0.000013 	let s:Module = s:V.import("Over.Commandline.Modules")
    1   0.000029   0.000014 	let s:base.variables.modules = s:Signals.make()
    1              0.000003 	function! s:base.variables.modules.get_slot(val)
                            		return a:val.slot.module
                            	endfunction

    1   0.004880   0.000016 	let s:Highlight = s:V.import("Palette.Highlight")

FUNCTION  <SNR>57_filename()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:219
Called 1 time
Total time:   0.000099
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000098   0.000012   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:57
Called 4 times
Total time:   0.054476
 Self time:   0.049221

count  total (s)   self (s)
    4              0.000025   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
    4              0.000125     call sign_unplace('gitgutter', {'buffer': a:bufnr})

    4   0.000200   0.000117     let modified_lines = s:handle_double_hunk(a:modified_lines)
    4   0.047458   0.042287     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')

    4              0.000026     if exists('*sign_placelist')
                                  call sign_placelist(signs)
                                  return
    4              0.000005     endif

  506              0.000803     for sign in signs
  502              0.005085       call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
  506              0.000495     endfor
    4              0.000009     return
                              endif


                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.

                              call s:find_current_signs(a:bufnr)

                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)

                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  <SNR>154__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:21
Called 1 time
Total time:   0.002731
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000004 	let s:V = a:V
    1   0.002724   0.000023 	let s:E  = s:V.import("Over.Exception")

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:10
Called 241 times
Total time:   0.023456
 Self time:   0.006265

count  total (s)   self (s)
  241   0.023174   0.005984   return airline#extensions#coc#get('warning')

FUNCTION  airline#extensions#coc#get_status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:45
Called 249 times
Total time:   0.030135
 Self time:   0.008364

count  total (s)   self (s)
                              " Shorten text for windows < 91 characters
  249   0.029516   0.007745   return airline#util#shorten(get(g:, 'coc_status', ''), 91, 9)

FUNCTION  395()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/CursorMove.vim:24
Called 15 times
Total time:   0.005596
 Self time:   0.001930

count  total (s)   self (s)
   15   0.000524   0.000151 	if a:cmdline.is_input("\<Right>")
                            		call a:cmdline.line.next()
                            		call a:cmdline.setchar('')
   15   0.000441   0.000118 	elseif a:cmdline.is_input("\<Left>")
                            		call a:cmdline.line.prev()
                            		call a:cmdline.setchar('')
   15   0.000959   0.000277 	elseif a:cmdline.is_input("\<C-b>")		|| a:cmdline.is_input("\<Home>")
                            		call a:cmdline.setline(0)
                            		call a:cmdline.setchar('')
   15   0.000917   0.000222 	elseif a:cmdline.is_input("\<C-e>")		|| a:cmdline.is_input("\<End>")
                            		call a:cmdline.setline(a:cmdline.line.length())
                            		call a:cmdline.setchar('')
   15   0.001100   0.000222 	elseif a:cmdline.is_input("\<C-Left>")		|| a:cmdline.is_input("\<S-Left>")
                            		call a:cmdline.setline(strridx(a:cmdline.backward()[:-2], ' ') + 1)
                            		call a:cmdline.setchar('')
   15   0.000967   0.000252 	elseif a:cmdline.is_input("\<C-Right>")		|| a:cmdline.is_input("\<S-Right>")
                            		let p = stridx(a:cmdline.forward()[1:], ' ')
                            		call a:cmdline.setline(p != -1 ? a:cmdline.line.pos() + p + 2 : a:cmdline.line.length())
                            		call a:cmdline.setchar('')
   15              0.000014 	endif

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:139
Called 1 time
Total time:   0.005794
 Self time:   0.000429

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git

    1   0.000034   0.000011   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    1   0.000457   0.000033   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))

    1   0.001563   0.000306   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
    1              0.000008     let handler = copy(s:set_path_handler)
    1              0.000004     let handler.continuation = a:continuation
    1   0.003716   0.000054     call gitgutter#async#execute(cmd, a:bufnr, handler)
    1              0.000004     return 'async'
                              endif

                              let path = gitgutter#utility#system(cmd)
                              if v:shell_error
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                              endif

FUNCTION  fugitive#Prepare()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:426
Called 3 times
Total time:   0.019050
 Self time:   0.000129

count  total (s)   self (s)
    3   0.017145   0.000066   let [dir, env, argv] = call('fugitive#PrepareDirEnvArgv', a:000)
    3   0.001901   0.000059   return s:BuildShell(dir, env, argv)

FUNCTION  <SNR>93_is_branch_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:55
Called 241 times
Total time:   0.004363
 Self time:   0.004363

count  total (s)   self (s)
  241              0.003925   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>128__import_func_name()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:204
Called 27 times
Total time:   0.001012
 Self time:   0.000620

count  total (s)   self (s)
   27   0.000975   0.000582   return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))

FUNCTION  nerdtree#slash()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:37
Called 915 times
Total time:   0.053305
 Self time:   0.038952

count  total (s)   self (s)
  915   0.039319   0.024966     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif

                                    return '\'
  915              0.000902     endif

  915              0.001550     return '/'

FUNCTION  <SNR>91_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:183
Called 466 times
Total time:   0.644528
 Self time:   0.049792

count  total (s)   self (s)
  466              0.001590   if pumvisible()
                                return
  466              0.000334   endif
  466              0.002735   let group = a:from.'_to_'.a:to.a:suffix
  466   0.192515   0.011156   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  466   0.183007   0.010568   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  466              0.000892   if a:inverse
  173              0.001249     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  293              0.000239   else
  293              0.002007     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  466              0.000354   endif
  466              0.002665   let a:dict[group] = colors
  466   0.252735   0.011797   call airline#highlighter#exec(group, colors)

FUNCTION  coc#float#check_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:796
Called 51 times
Total time:   0.016970
 Self time:   0.016970

count  total (s)   self (s)
   51              0.000929   let invalids = []
   51              0.000405   if s:is_vim
                                if !exists('*popup_list')
                                  return
                                endif
                                for id in popup_list()
                                  let target = getwinvar(id, 'target_winid', 0)
                                  if (target && !s:popup_visible(target)) || getwinvar(id, 'kind', '') == 'pum'
                                    call add(invalids, id)
                                  endif
                                endfor
   51              0.000127   else
  154              0.001589     for i in range(1, winnr('$'))
  103              0.001237       let target = getwinvar(i, 'target_winid', 0)
  103              0.001901       if target && !nvim_win_is_valid(target)
                                    call add(invalids, win_getid(i))
  103              0.000987       elseif getwinvar(i, 'kind', '') == 'pum'
                                    call add(invalids, win_getid(i))
  103              0.000154       endif
  154              0.001338     endfor
   51              0.000521   endif
   51              0.000284   for id in invalids
                                call coc#float#close(id)
   51              0.000148   endfor

FUNCTION  <SNR>139_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Cancel.vim:34
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005 	return deepcopy(s:module)

FUNCTION  fzf#vim#with_preview()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:117
Called 2 times
Total time:   0.000734
 Self time:   0.000544

count  total (s)   self (s)
                              " Default spec
    2              0.000006   let spec = {}
    2              0.000004   let window = ''

    2              0.000008   let args = copy(a:000)

                              " Spec to wrap
    2              0.000015   if len(args) && type(args[0]) == s:TYPE.dict
    2              0.000009     let spec = copy(args[0])
    2              0.000008     call remove(args, 0)
    2              0.000002   endif

    2              0.000181   if !executable('bash')
                                if !s:warned
                                  call s:warn('Preview window not supported (bash not found in PATH)')
                                  let s:warned = 1
                                endif
                                return spec
    2              0.000001   endif

                              " Placeholder expression (TODO/TBD: undocumented)
    2              0.000012   let placeholder = get(spec, 'placeholder', '{}')

                              " Preview window
    2              0.000013   if len(args) && type(args[0]) == s:TYPE.string
    2              0.000032     if args[0] !~# '^\(up\|down\|left\|right\)'
                                  throw 'invalid preview window: '.args[0]
    2              0.000002     endif
    2              0.000006     let window = args[0]
    2              0.000007     call remove(args, 0)
    2              0.000002   endif

    2              0.000005   let preview = []
    2              0.000005   if len(window)
    2              0.000011     let preview += ['--preview-window', window]
    2              0.000001   endif
    2              0.000003   if s:is_win
                                let is_wsl_bash = exepath('bash') =~? 'Windows[/\\]system32[/\\]bash.exe$'
                                let preview_cmd = 'bash '.(is_wsl_bash ? substitute(substitute(s:bin.preview, '^\([A-Z]\):', '/mnt/\L\1', ''), '\', '/', 'g') : escape(s:bin.preview, '\'))
    2              0.000002   else
    2   0.000111   0.000030     let preview_cmd = fzf#shellescape(s:bin.preview)
    2              0.000002   endif
    2              0.000006   if len(placeholder)
    2              0.000015     let preview += ['--preview', preview_cmd.' '.placeholder]
    2              0.000001   end

    2              0.000004   if len(args)
    2              0.000034     call extend(preview, ['--bind', join(map(args, 'v:val.":toggle-preview"'), ',')])
    2              0.000002   endif
    2   0.000140   0.000031   call s:merge_opts(spec, preview)
    2              0.000003   return spec

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:143
Called 522 times
Total time:   0.008299
 Self time:   0.008299

count  total (s)   self (s)
  522              0.003098   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
  522              0.000469   endif
  522              0.001457   return s:has_fugitive

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 38 times
Total time:   0.056594
 Self time:   0.004923

count  total (s)   self (s)
   38              0.000183   let winnr = a:context.winnr
   38              0.000139   let active = a:context.active

   38   0.001176   0.000784   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
   28   0.023431   0.000573     call s:build_sections(a:builder, a:context, s:layout[0])
   10              0.000013   else
   10   0.000919   0.000186     let text = s:get_section(winnr, 'c')
   10              0.000029     if empty(text)
                                  let text = ' %f%m '
   10              0.000008     endif
   10   0.000206   0.000126     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
   38              0.000033   endif

   38   0.004289   0.000917   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))

   38   0.000831   0.000534   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   23   0.024421   0.000480     call s:build_sections(a:builder, a:context, s:layout[1])
   38              0.000036   endif

   38              0.000073   return 1

FUNCTION  <SNR>110_SplitExpandChain()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1175
Called 1 time
Total time:   0.000073
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000073   0.000014   return s:ExpandSplit(a:string, 1, a:0 ? a:1 : getcwd())

FUNCTION  ToggleGStatus()
    Defined: ~/.config/nvim/init.vim:192
Called 1 time
Total time:   0.277246
 Self time:   0.002534

count  total (s)   self (s)
    1              0.000145     if buflisted(bufname('.git/index'))
                                    bd .git/index
    1              0.000001     else
    1   0.277093   0.002381         Gstatus
    1              0.000001     endif

FUNCTION  coc#util#cursor()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:65
Called 32 times
Total time:   0.001239
 Self time:   0.001239

count  total (s)   self (s)
   32              0.001121   return [line('.') - 1, strchars(strpart(getline('.'), 0, col('.') - 1))]

FUNCTION  <SNR>103_get_transitioned_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:140
Called 149 times
Total time:   0.230416
 Self time:   0.010603

count  total (s)   self (s)
  149              0.000443   let line = ''
  149              0.001210   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
  149              0.000158   else
  149   0.222949   0.003136     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  149              0.001263     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
  149              0.001076     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
  149              0.000699     let line .= '%#'.a:group.'#'
  149              0.000132   endif
  149              0.000302   return line

FUNCTION  vital#_easymotion#Over#Commandline#Modules#CursorMove#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/CursorMove.vim:5
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000025     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>133_getchar()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Input.vim:21
Called 15 times
Total time:   0.004236
 Self time:   0.004236

count  total (s)   self (s)
   15              0.000060 	let mode = get(a:, 1, 0)
   15              0.000026 	while 1
                            		" Workaround for https://github.com/osyo-manga/vital-over/issues/53
   15              0.000015 		try
   15              0.002862 			let char = call("getchar", a:000)
                            		catch /^Vim:Interrupt$/
                            			let char = 3 " <C-c>
   15              0.000034 		endtry
                            		" Workaround for the <expr> mappings
   15              0.000162 		if string(char) !=# "\x80\xfd`"
   15              0.000145 			return mode == 1 ? !!char				 : type(char) == type(0) ? nr2char(char) : char
                            		endif
                            	endwhile

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:196
Called 4 times
Total time:   0.001119
 Self time:   0.001119

count  total (s)   self (s)
    4              0.000845   let p = resolve(expand('#'.a:bufnr.':p'))
    4              0.000109   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
    4              0.000112   if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
    4              0.000007   endif
    4              0.000014   return g:gitgutter_diff_base

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:102
Called 249 times
Total time:   0.012238
 Self time:   0.006952

count  total (s)   self (s)
  249   0.011962   0.006676   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 18 times
Total time:   0.000717
 Self time:   0.000717

count  total (s)   self (s)
   18              0.000137   if &ft == 'netrw'
                                let spc = g:airline_symbols.space

                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
   18              0.000015   endif

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:82
Called 241 times
Total time:   0.003363
 Self time:   0.003363

count  total (s)   self (s)
  241              0.001354   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
  241              0.000471   endif
  241              0.000321   return ''

FUNCTION  <SNR>95_ModifierFlags()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:11
Called 249 times
Total time:   0.002482
 Self time:   0.002482

count  total (s)   self (s)
  249              0.002128   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 286 times
Total time:   0.028924
 Self time:   0.020761

count  total (s)   self (s)
  286   0.028560   0.020396   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>123_merge_opts()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:108
Called 4 times
Total time:   0.001158
 Self time:   0.000087

count  total (s)   self (s)
    4   0.001150   0.000080   return s:extend_opts(a:dict, a:eopts, 0)

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:273
Called 102 times
Total time:   0.001398
 Self time:   0.001398

count  total (s)   self (s)
  102              0.000720   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
  102              0.000106   endif

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:14
Called 16 times
Total time:   0.000576
 Self time:   0.000576

count  total (s)   self (s)
   16              0.000156   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
   16              0.000013   endif

FUNCTION  EasyMotion#helper#should_case_sensitive()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/helper.vim:75
Called 15 times
Total time:   0.000613
 Self time:   0.000613

count  total (s)   self (s)
   15              0.000048     if !a:is_search
                                    if g:EasyMotion_smartcase == 0
                                        return 0
                                    else
                                        " return 1 if input didn't match uppercase letter
                                        return match(a:input, '\u') == -1
                                    endif
   15              0.000012     endif

   15              0.000281     if (g:EasyMotion_smartcase == 1 && match(a:input, '\u') == -1) ||  (&ignorecase && &smartcase && match(a:input, '\u') == -1) ||  (&ignorecase && !&smartcase)
   15              0.000029         return 1
                                endif
                                return 0

FUNCTION  <SNR>110_Map()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:170
Called 188 times
Total time:   0.050009
 Self time:   0.050009

count  total (s)   self (s)
  380              0.002585   for mode in split(a:mode, '\zs')
  192              0.002335     let flags = (a:0 ? a:1 : '') . (a:rhs =~# '<Plug>' ? '' : '<script>')
  192              0.000503     let head = a:lhs
  192              0.000302     let tail = ''
  192              0.001062     let keys = get(g:, mode.'remap', {})
  192              0.000785     if type(keys) == type([])
                                  return
  192              0.000147     endif
  551              0.001623     while !empty(head)
  359              0.001081       if has_key(keys, head)
                                    let head = keys[head]
                                    if empty(head)
                                      return
                                    endif
                                    break
  359              0.000218       endif
  359              0.004367       let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
  359              0.007891       let head = substitute(head, '<[^<>]*>$\|.$', '', '')
  551              0.000642     endwhile
  192              0.001687     if flags !~# '<unique>' || empty(mapcheck(head.tail, mode))
  192              0.007442       exe mode.'map <buffer>' s:nowait flags head.tail a:rhs
  192              0.000492       if a:0 > 1
    5              0.000050         let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|sil! exe "' . mode . 'unmap <buffer> ' . head.tail . '"'
  192              0.000148       endif
  192              0.000128     endif
  380              0.000922   endfor

FUNCTION  vital#_easymotion#Over#Commandline#Modules#Doautocmd#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:5
Called 1 time
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000066     return map({'_vital_depends': '', 'doautocmd_user': '', 'get_cmdline': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  coc#rpc#request()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:88
Called 4 times
Total time:   0.643591
 Self time:   0.000156

count  total (s)   self (s)
    4   0.000112   0.000060   if !coc#rpc#ready()
                                return ''
    4              0.000003   endif
    4   0.643454   0.000070   return s:client['request'](a:method, a:args)

FUNCTION  coc#float#get_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:1207
Called 64 times
Total time:   0.003099
 Self time:   0.003099

count  total (s)   self (s)
   64              0.001036   for winid in getwinvar(a:winid, 'related', [])
                                if getwinvar(winid, 'kind', '') ==# a:kind
                                  return winid
                                endif
   64              0.000154   endfor
   64              0.000131   return 0

FUNCTION  <SNR>141_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:149
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000012 	return deepcopy(s:module)

FUNCTION  <SNR>97_conflict_marker()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:52
Called 3 times
Total time:   0.002134
 Self time:   0.002134

count  total (s)   self (s)
                              " Checks for git conflict markers
    3              0.000011   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
    3              0.000021   if &ft is# 'rst'
                                " rst filetypes use '=======' as header
                                let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(>\{7\} '.annotation.'\)\)$'
    3              0.000003   else
    3              0.000023     let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
    3              0.000003   endif
    3              0.002049   return search(pattern, 'nw')

FUNCTION  vital#_easymotion#Vim#Message#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Vim/Message.vim:5
Called 1 time
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    1              0.000046     return map({'capture': '', 'echomsg': '', 'echo': '', 'warn': '', 'get_hit_enter_max_length': '', 'error': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>110_Mods()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:95
Called 1 time
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    1              0.000008   let mods = substitute(a:mods, '\C<mods>', '', '')
    1              0.000006   let mods = mods =~# '\S$' ? mods . ' ' : mods
    1              0.000019   if a:0 && mods !~# '\<\%(aboveleft\|belowright\|leftabove\|rightbelow\|topleft\|botright\|tab\)\>'
    1              0.000003     let mods = a:1 . ' ' . mods
    1              0.000001   endif
    1              0.000009   return substitute(mods, '\s\+', ' ', 'g')

FUNCTION  vital#_easymotion#Palette#Capture#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Capture.vim:5
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000022     return map({'extend': '', 'command': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>245_untracked_output()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:12
Called 3 times
Total time:   0.000167
 Self time:   0.000167

count  total (s)   self (s)
    3              0.000047   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
    3              0.000004   else
    3              0.000073     let a:dict.cfg.untracked[a:dict.file] = ''
    3              0.000005   endif

FUNCTION  vital#_easymotion#Over#Commandline#Modules#DrawCommandline#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:5
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000034     return map({'suffix': '', 'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>26_present()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:485
Called 5 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    5              0.000023   for key in a:000
    5              0.000036     if !empty(get(a:dict, key, ''))
    5              0.000008       return 1
                                endif
                              endfor
                              return 0

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:18
Called 482 times
Total time:   0.036199
 Self time:   0.036199

count  total (s)   self (s)
  482              0.003268   if !exists(':CocCommand')
                                return ''
  482              0.000414   endif
  482              0.003137   let _backup = get(g:, 'coc_stl_format', '')
  482              0.002076   let is_err = (a:type  is# 'error')
  482              0.000741   if is_err
  241              0.004579     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_err', '%E{[%e(#%fe)]}')
  241              0.000218   else
  241              0.002348     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%W{[%w(#%fw)]}')
  482              0.000420   endif
  482              0.002501   let info = get(b:, 'coc_diagnostic_info', {})
  482              0.002561   if empty(info) | return '' | endif


  398              0.002043   let cnt = get(info, a:type, 0)
  398              0.001284   if !empty(_backup)
  398              0.002184     let g:coc_stl_format = _backup
  398              0.000341   endif

  398              0.001449   if empty(cnt)
  398              0.000594     return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  EasyMotion#S()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:132
Called 1 time
Total time:   0.384923
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000006     if a:direction == 1
                                    let is_inclusive = 0
    1              0.000002     else
                                    " Note: Handle bi-direction later because 'f' motion is inclusive but
                                    " 'F' motion is exclusive
    1              0.000009         let is_inclusive = mode(1) ==# 'no' ? 1 : 0
    1              0.000001     endif
    1              0.000005     let s:flag.find_bd = a:direction == 2 ? 1 : 0
    1   0.384858   0.000020     let re = s:findMotion(a:num_strokes, a:direction)
    1   0.000034   0.000019     if s:handleEmpty(re, a:visualmode) | return | endif
                                call s:EasyMotion(re, a:direction, a:visualmode ? visualmode() : '', is_inclusive)
                                return s:EasyMotion_is_cancelled

FUNCTION  <SNR>20_notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:181
Called 190 times
Total time:   0.065291
 Self time:   0.060616

count  total (s)   self (s)
  190   0.024426   0.019751   let channel = coc#client#get_channel(self)
  190              0.001154   if empty(channel)
                                return ''
  190              0.000519   endif
  190              0.000298   try
  190              0.000371     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
  190              0.000354     else
  190              0.022224       call call('rpcnotify', [channel, a:method] + a:args)
  190              0.000540     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
  190              0.000355   endtry

FUNCTION  404()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:98
Called 15 times
Total time:   0.002068
 Self time:   0.001501

count  total (s)   self (s)
   15   0.000766   0.000200 	if a:cmdline.is_input("\<C-r>")
                            		call a:cmdline.setchar('"')
                            		let self.prefix_key = a:cmdline.input_key()
                            		let self.old_line = a:cmdline.getline()
                            		let self.old_pos  = a:cmdline.getpos()
                            		return
   15              0.000115 	elseif exists("self.prefix_key")		&& a:cmdline.get_tap_key() == self.prefix_key
                            		call a:cmdline.setline(self.old_line)
                            		call a:cmdline.setpos(self.old_pos)
                            		let char = a:cmdline.input_key()
                            		if char =~ '^[0-9a-zA-z.%#:/"\-*+]$'
                            			let register = tr(getreg(char), "\n", "\r")
                            			call a:cmdline.setchar(register)
                            		elseif char == "="
                            			call a:cmdline.setchar(s:input(a:cmdline))
                            		elseif char == "\<C-w>"
                            			call a:cmdline.setchar(s:get_cmdline_cword(a:cmdline.backward_word(), self.cword))
                            		elseif char == "\<C-a>"
                            			call a:cmdline.setchar(self.cWORD)
                            		elseif char == "\<C-f>"
                            			call a:cmdline.setchar(self.cfile)
                            		elseif char == "\<C-r>"
                            			call a:cmdline.setchar('"')
                            		else
                            			call a:cmdline.setchar("")
                            		endif
                            " 		elseif a:cmdline.is_input('=', self.prefix_key)
                            " 			call a:cmdline.setchar(s:input(a:cmdline))
                            " 		elseif a:cmdline.is_input("\<C-w>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cword)
                            " 		elseif a:cmdline.is_input("\<C-a>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cWORD)
                            " 		elseif a:cmdline.is_input("\<C-f>", self.prefix_key)
                            " 			call a:cmdline.setchar(self.cfile)
                            " 		elseif a:cmdline.is_input("\<C-r>", self.prefix_key)
                            " 			call a:cmdline.setchar('"')
                            " 		else
                            " 			call a:cmdline.setchar("")
                            " 		endif
   15              0.000016 	endif

FUNCTION  <SNR>123_ansi()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:254
Called 1 time
Total time:   0.000289
 Self time:   0.000091

count  total (s)   self (s)
    1   0.000109   0.000018   let fg = s:get_color('fg', a:group)
    1   0.000085   0.000015   let bg = s:get_color('bg', a:group)
    1   0.000060   0.000022   let color = (empty(fg) ? s:ansi[a:default] : s:csi(fg, 1)) . (empty(bg) ? '' : ';'.s:csi(bg, 0))
    1              0.000033   return printf("\x1b[%s%sm%s\x1b[m", color, a:0 ? ';1' : '', a:str)

FUNCTION  coc#util#set_lines()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:587
Called 1 time
Total time:   0.000301
 Self time:   0.000301

count  total (s)   self (s)
    1              0.000006   if !s:is_vim
    1              0.000232     call nvim_buf_set_lines(a:bufnr, a:start, a:end, 0, a:replacement)
                              else
                                call coc#api#notify('buf_set_lines', [a:bufnr, a:start, a:end, 0, a:replacement])
    1              0.000001   endif
    1              0.000051   return { 'lines': getbufline(a:bufnr, 1, '$'), 'changedtick': getbufvar(a:bufnr, 'changedtick') }

FUNCTION  provider#python3#Call()
    Defined: /usr/local/Cellar/neovim/HEAD-759a054/share/nvim/runtime/autoload/provider/python3.vim:26
Called 1 time
Total time:   0.000709
 Self time:   0.000709

count  total (s)   self (s)
    1              0.000004   if s:err != ''
                                return
    1              0.000001   endif
    1              0.000004   if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')

                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
    1              0.000001   endif
    1              0.000678   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  306()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:157
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000009 	let self.variables.prompt = a:prompt

FUNCTION  309()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:172
Called 30 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
   30              0.000066 	return self.variables.suffix

FUNCTION  <SNR>145__finish()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim:108
Called 16 times
Total time:   0.000368
 Self time:   0.000368

count  total (s)   self (s)
   16              0.000223 	if exists("s:old_statusline")
                            		let &statusline = s:old_statusline
                            		unlet s:old_statusline
                            		redrawstatus
   16              0.000014 	endif

FUNCTION  airline#extensions#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:71
Called 38 times
Total time:   0.011206
 Self time:   0.004869

count  total (s)   self (s)
   38              0.000321   let filetype_overrides = get(s:, 'filetype_overrides', {})
   38              0.000470   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')

   38   0.004677   0.000753   if s:is_excluded_window()
                                return -1
   38              0.000027   endif

   38              0.000143   if &buftype == 'terminal'
    4              0.000023     let w:airline_section_x = ''
    4              0.000015     let w:airline_section_y = ''
   38              0.000032   endif

   38              0.000202   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
   38              0.000030   endif

   38              0.000450   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
    7              0.000060     let args = filetype_overrides[&ft]
    7   0.002584   0.000171     call airline#extensions#apply_left_override(args[0], args[1])
   38              0.000034   endif

   38              0.000110   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
   38              0.000028   endif

   38              0.000247   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
   38              0.000077   endfor

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:102
Called 42 times
Total time:   0.007353
 Self time:   0.001154

count  total (s)   self (s)
   42   0.007302   0.001102   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>123_csi()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:246
Called 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000003   let prefix = a:fg ? '38;' : '48;'
    1              0.000004   if a:color[0] == '#'
    1              0.000029     return prefix.'2;'.join(map([a:color[1:2], a:color[3:4], a:color[5:6]], 'str2nr(v:val, 16)'), ';')
                              endif
                              return prefix.'5;'.a:color

FUNCTION  296()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:95
Called 15 times
Total time:   0.000854
 Self time:   0.000191

count  total (s)   self (s)
   15   0.000845   0.000181 	return self.line.set(a:line)

FUNCTION  <SNR>103_get_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:155
Called 126 times
Total time:   0.309827
 Self time:   0.006278

count  total (s)   self (s)
  126   0.111033   0.002798   if airline#builder#should_change_group(a:prev_group, a:group)
  126   0.198591   0.003278     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>151_make_emacs()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/KeyMapping.vim:93
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005 	return deepcopy(s:emacs)

FUNCTION  12()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:244
Called 287 times
Total time:   0.003942
 Self time:   0.003376

count  total (s)   self (s)
  287              0.001040     if self.cachedDisplayString ==# ''
    7   0.000607   0.000041         call self.cacheDisplayString()
  287              0.000234     endif

  287              0.000627     return self.cachedDisplayString

FUNCTION  14()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:263
Called 12 times
Total time:   0.000502
 Self time:   0.000400

count  total (s)   self (s)
   12   0.000247   0.000145     if nerdtree#runningWindows()
                                    if a:fullpath =~# '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', 'g')
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
   12              0.000008     else
   12              0.000049         let self.drive = ''
   12              0.000009     endif


FUNCTION  19()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:331
Called 1451 times
Total time:   0.031967
 Self time:   0.031967

count  total (s)   self (s)
 1451              0.005973     if empty(self.pathSegments)
                                    return ''
 1451              0.001369     endif
 1451              0.008068     let toReturn = self.pathSegments[-1]
 1451              0.004127     if a:dirSlash && self.isDirectory
  211              0.000825         let toReturn = toReturn . '/'
 1451              0.001167     endif
 1451              0.002667     return toReturn

FUNCTION  <SNR>26_create_popup()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:904
Called 2 times
Total time:   0.065324
 Self time:   0.001389

count  total (s)   self (s)
    2   0.001011   0.000828     let buf = nvim_create_buf(v:false, v:true)
    2              0.000028     let opts = extend({'relative': 'editor', 'style': 'minimal'}, a:opts)
    2              0.000013     let border = has_key(opts, 'border') ? remove(opts, 'border') : []
    2   0.064097   0.000363     let win = nvim_open_win(buf, v:true, opts)
    2   0.000121   0.000116     call setwinvar(win, '&winhighlight', 'NormalFloat:'..a:hl)
    2   0.000029   0.000015     call setwinvar(win, '&colorcolumn', '')
    2              0.000006     if !empty(border)
                                  call nvim_buf_set_lines(buf, 0, -1, v:true, border)
    2              0.000002     endif
    2              0.000003     return buf

FUNCTION  polyglot#shebang#VimDetect()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/polyglot/shebang.vim:67
Called 6 times
Total time:   0.007502
 Self time:   0.007502

count  total (s)   self (s)
    6              0.000036   let line1 = getline(1)

    6              0.000040   if line1 =~# "^#!"
                                " A script that starts with "#!".

                                " Check for a line like "#!/usr/bin/env {options} bash".  Turn it into
                                " "#!/usr/bin/bash" to make matching easier.
                                " Recognize only a few {options} that are commonly used.
                                if line1 =~# '^#!\s*\S*\<env\s'
                                  let line1 = substitute(line1, '\S\+=\S\+', '', 'g')
                                  let line1 = substitute(line1, '\(-[iS]\|--ignore-environment\|--split-string\)', '', '')
                                  let line1 = substitute(line1, '\<env\s\+', '', '')
                                endif

                                " Get the program name.
                                " Only accept spaces in PC style path "#!c:/program files/perl [args]".
                                " If the word env is used, use the first word after the space:
                                " "#!/usr/bin/env perl [path/args]"
                                " If there is no path use the first word: "#!perl [path/args]".
                                " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                                if line1 =~# '^#!\s*\a:[/\\]'
                                  let name = substitute(line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                                elseif line1 =~# '^#!.*\<env\>'
                                  let name = substitute(line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                                elseif line1 =~# '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                  let name = substitute(line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                                else
                                  let name = substitute(line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                                endif

                                " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                                " third line.  Suggested by Steven Atkinson.
                                if getline(3) =~# '^exec wish'
                                  let name = 'wish'
                                endif

                                " Bourne-like shell script bash bash2 ksh ksh93 sh
                                if name =~# '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                  call dist#ft#SetFileTypeSH(line1)	" defined in filetype.vim
                                  return

                                  " csh scripts
                                elseif name =~# '^csh\>'
                                  if exists("g:filetype_csh")
                                    call dist#ft#SetFileTypeShell(g:filetype_csh)
                                    return
                                  else
                                    call dist#ft#SetFileTypeShell("csh")
                                    return
                                  endif

                                  " tcsh scripts
                                elseif name =~# '^tcsh\>'
                                  call dist#ft#SetFileTypeShell("tcsh")
                                  return

                                  " Z shell scripts
                                elseif name =~# '^zsh\>'
                                  set ft=zsh | return

                                  " TCL scripts
                                elseif name =~# '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                  set ft=tcl | return

                                  " Expect scripts
                                elseif name =~# '^expect\>'
                                  set ft=expect | return

                                  " Gnuplot scripts
                                elseif name =~# '^gnuplot\>'
                                  set ft=gnuplot | return

                                  " Makefiles
                                elseif name =~# 'make\>'
                                  set ft=make | return

                                  " Pike
                                elseif name =~# '^pike\%(\>\|[0-9]\)'
                                  set ft=pike | return

                                  " Lua
                                elseif name =~# 'lua'
                                  set ft=lua | return

                                  " Perl 6
                                elseif name =~# 'perl6'
                                  set ft=perl6 | return

                                  " Perl
                                elseif name =~# 'perl'
                                  set ft=perl | return

                                  " PHP
                                elseif name =~# 'php'
                                  set ft=php | return

                                  " Python
                                elseif name =~# 'python'
                                  set ft=python | return

                                  " Groovy
                                elseif name =~# '^groovy\>'
                                  set ft=groovy | return

                                  " Ruby
                                elseif name =~# 'ruby'
                                  set ft=ruby | return

                                  " JavaScript
                                elseif name =~# 'node\(js\)\=\>\|js\>' || name =~# 'rhino\>'
                                  set ft=javascript | return

                                  " BC calculator
                                elseif name =~# '^bc\>'
                                  set ft=bc | return

                                  " sed
                                elseif name =~# 'sed\>'
                                  set ft=sed | return

                                  " OCaml-scripts
                                elseif name =~# 'ocaml'
                                  set ft=ocaml | return

                                  " Awk scripts; also finds "gawk"
                                elseif name =~# 'awk\>'
                                  set ft=awk | return

                                  " Website MetaLanguage
                                elseif name =~# 'wml'
                                  set ft=wml | return

                                  " Scheme scripts
                                elseif name =~# 'scheme'
                                  set ft=scheme | return

                                  " CFEngine scripts
                                elseif name =~# 'cfengine'
                                  set ft=cfengine | return

                                  " Erlang scripts
                                elseif name =~# 'escript'
                                  set ft=erlang | return

                                  " Haskell
                                elseif name =~# 'haskell'
                                  set ft=haskell | return

                                  " Scala
                                elseif name =~# 'scala\>'
                                  set ft=scala | return

                                  " Clojure
                                elseif name =~# 'clojure'
                                  set ft=clojure | return

                                endif
                                unlet name

    6              0.000007   else
                                " File does not start with "#!".

    6              0.000029     let line2 = getline(2)
    6              0.000024     let line3 = getline(3)
    6              0.000023     let line4 = getline(4)
    6              0.000022     let line5 = getline(5)

                                " Bourne-like shell script sh ksh bash bash2
    6              0.000038     if line1 =~# '^:$'
                                  call dist#ft#SetFileTypeSH(line1)	" defined in filetype.vim
                                  return

                                " Z shell scripts
    6              0.000281     elseif line1 =~# '^#compdef\>' || line1 =~# '^#autoload\>' || "\n".line1."\n".line2."\n".line3."\n".line4."\n".line5 =~# '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                  set ft=zsh | return

                                " ELM Mail files
    6              0.000124     elseif line1 =~# '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                  set ft=mail | return

                                " Mason
    6              0.000043     elseif line1 =~# '^<[%&].*>'
                                  set ft=mason | return

                                " Vim scripts (must have '" vim' as the first line to trigger this)
    6              0.000044     elseif line1 =~# '^" *[vV]im$'
                                  set ft=vim | return

                                " libcxx and libstdc++ standard library headers like "iostream" do not have
                                " an extension, recognize the Emacs file mode.
    6              0.000049     elseif line1 =~? '-\*-.*C++.*-\*-'
                                  set ft=cpp | return

                                " MOO
    6              0.000116     elseif line1 =~# '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                  set ft=moo | return

                                  " Diff file:
                                  " - "diff" in first line (context diff)
                                  " - "Only in " in first line
                                  " - "--- " in first line and "+++ " in second line (unified diff).
                                  " - "*** " in first line and "--- " in second line (context diff).
                                  " - "# It was generated by makepatch " in the second line (makepatch diff).
                                  " - "Index: <filename>" in the first line (CVS file)
                                  " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                  " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                  " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                  " - "# HG changeset patch" in first line (Mercurial export format)
    6              0.000582     elseif line1 =~# '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)' || (line1 =~# '^--- ' && line2 =~# '^+++ ') || (line1 =~# '^\* looking for ' && line2 =~# '^\* comparing to ') || (line1 =~# '^\*\*\* ' && line2 =~# '^--- ') || (line1 =~# '^=== ' && ((line2 =~# '^=\{66\}' && line3 =~# '^--- ' && line4 =~# '^+++') || (line2 =~# '^--- ' && line3 =~# '^+++ '))) || (line1 =~# '^=== \(removed\|added\|renamed\|modified\)')
                                  set ft=diff | return

                                  " PostScript Files (must have %!PS as the first line, like a2ps output)
    6              0.000044     elseif line1 =~# '^%![ \t]*PS'
                                  set ft=postscr | return

                                  " M4 script Guess there is a line that starts with "dnl".
    6              0.000218     elseif line1 =~# '^\s*dnl\>' || line2 =~# '^\s*dnl\>' || line3 =~# '^\s*dnl\>' || line4 =~# '^\s*dnl\>' || line5 =~# '^\s*dnl\>'
                                  set ft=m4 | return

                                  " AmigaDos scripts
    6              0.000049     elseif $TERM == "amiga" && (line1 =~# "^;" || line1 =~? '^\.bra')
                                  set ft=amiga | return

                                  " SiCAD scripts (must have procn or procd as the first line to trigger this)
    6              0.000067     elseif line1 =~? '^ *proc[nd] *$'
                                  set ft=sicad | return

                                  " Purify log files start with "****  Purify"
    6              0.000055     elseif line1 =~# '^\*\*\*\*  Purify'
                                  set ft=purifylog | return

                                  " XML
    6              0.000051     elseif line1 =~# '<?\s*xml.*?>'
                                  set ft=xml | return

                                  " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
    6              0.000055     elseif line1 =~# '\<DTD\s\+XHTML\s'
                                  set ft=xhtml | return

                                  " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                  " Avoid "doctype html", used by slim.
    6              0.000060     elseif line1 =~? '<!DOCTYPE\s\+html\>'
                                  set ft=html | return

                                  " PDF
    6              0.000041     elseif line1 =~# '^%PDF-'
                                  set ft=pdf | return

                                  " XXD output
    6              0.000109     elseif line1 =~# '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                  set ft=xxd | return

                                  " RCS/CVS log output
    6              0.000073     elseif line1 =~# '^RCS file:' || line2 =~# '^RCS file:'
                                  set ft=rcslog | return

                                  " CVS commit
    6              0.000074     elseif line2 =~# '^CV' || getline("$") =~# '^CV '
                                  set ft=cvs | return

                                  " Prescribe
    6              0.000030     elseif line1 =~# '^!R!'
                                  set ft=prescribe | return

                                  " Send-pr
    6              0.000037     elseif line1 =~# '^SEND-PR:'
                                  set ft=sendpr | return

                                  " SNNS files
    6              0.000063     elseif line1 =~# '^SNNS network definition file'
                                  set ft=snnsnet | return
    6              0.000061     elseif line1 =~# '^SNNS pattern definition file'
                                  set ft=snnspat | return
    6              0.000047     elseif line1 =~# '^SNNS result file'
                                  set ft=snnsres | return

                                  " Virata
    6              0.000186     elseif line1 =~# '^%.\{-}[Vv]irata' || line2 =~# '^%.\{-}[Vv]irata' || line3 =~# '^%.\{-}[Vv]irata' || line4 =~# '^%.\{-}[Vv]irata' || line5 =~# '^%.\{-}[Vv]irata'
                                  set ft=virata | return

                                  " Strace
    6              0.000105     elseif line1 =~# '[0-9:.]* *execve(' || line1 =~# '^__libc_start_main'
                                  set ft=strace | return

                                  " VSE JCL
    6              0.000074     elseif line1 =~# '^\* $$ JOB\>' || line1 =~# '^// *JOB\>'
                                  set ft=vsejcl | return

                                  " TAK and SINDA
    6              0.000083     elseif line4 =~# 'K & K  Associates' || line2 =~# 'TAK 2000'
                                  set ft=takout | return
    6              0.000070     elseif line3 =~# 'S Y S T E M S   I M P R O V E D '
                                  set ft=sindaout | return
    6              0.000052     elseif getline(6) =~# 'Run Date: '
                                  set ft=takcmp | return
    6              0.000054     elseif getline(9) =~# 'Node    File  1'
                                  set ft=sindacmp | return

                                  " DNS zone files
    6              0.000173     elseif line1.line2.line3.line4 =~# '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                  set ft=bindzone | return

                                  " BAAN
    6              0.000291     elseif line1 =~# '|\*\{1,80}' && line2 =~# 'VRC ' || line2 =~# '|\*\{1,80}' && line3 =~# 'VRC '
                                  set ft=baan | return

                                " Valgrind
    6              0.000101     elseif line1 =~# '^==\d\+== valgrind' || line3 =~# '^==\d\+== Using valgrind'
                                  set ft=valgrind | return

                                " Go docs
    6              0.000055     elseif line1 =~# '^PACKAGE DOCUMENTATION$'
                                  set ft=godoc | return

                                " Renderman Interface Bytestream
    6              0.000041     elseif line1 =~# '^##RenderMan'
                                  set ft=rib | return

                                " Scheme scripts
    6              0.000087     elseif line1 =~# 'exec\s\+\S*scheme' || line2 =~# 'exec\s\+\S*scheme'
                                  set ft=scheme | return

                                " Git output
    6              0.000176     elseif line1 =~# '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                  set ft=git | return

                                 " Gprof (gnu profiler)
    6              0.000031      elseif line1 == 'Flat profile:' && line2 == '' && line3 =~# '^Each sample counts as .* seconds.$'
                                   set ft=gprof | return

                                " Erlang terms
                                " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
    6              0.000053     elseif line1 =~? '-\*-.*erlang.*-\*-'
                                  set ft=erlang | return

                                " YAML
    6              0.000035     elseif line1 =~# '^%YAML'
                                  set ft=yaml | return

                                " CVS diff
    6              0.000007     else
    6              0.000024       let lnum = 1
    6              0.000067       while getline(lnum) =~# "^? " && lnum < line("$")
                                    let lnum += 1
    6              0.000015       endwhile
    6              0.000060       if getline(lnum) =~# '^Index:\s\+\f\+$'
                                    set ft=diff | return

                                    " locale input file Formal Definitions of Cultural Conventions
                                    " filename must be like en_US, fr_FR@euro or en_US.UTF-8
    6              0.000226       elseif expand("%") =~# '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                    let lnum = 1
                                    while lnum < 100 && lnum < line("$")
                                if getline(lnum) =~# '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                                  setf fdcc | return
                                  break
                                endif
                                let lnum += 1
                                    endwhile
    6              0.000007       endif
    6              0.000019       unlet lnum

    6              0.000007     endif

    6              0.000006   endif

    6              0.000011   return 1

FUNCTION  310()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:177
Called 15 times
Total time:   0.000842
 Self time:   0.000319

count  total (s)   self (s)
   15              0.000037 	if a:0
                            		call self.line.set(a:1)
   15              0.000015 	endif
   15   0.000708   0.000185 	call self.line.input(a:word)

FUNCTION  311()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:184
Called 15 times
Total time:   0.000219
 Self time:   0.000128

count  total (s)   self (s)
   15   0.000210   0.000120 	return self.line.forward()

FUNCTION  312()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:188
Called 15 times
Total time:   0.000340
 Self time:   0.000171

count  total (s)   self (s)
   15   0.000331   0.000162 	return self.line.backward()

FUNCTION  314()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:199
Called 27 times
Total time:   0.032078
 Self time:   0.028526

count  total (s)   self (s)
   27              0.000185 	if type(a:module) == type("")
   10   0.027842   0.000343 		return call(self.connect, [s:Module.make(a:module)] + a:000, self)
   17              0.000018 	endif
   17              0.000054 	if empty(a:module)
                            		return
   17              0.000013 	endif
   17              0.000091 	let name = a:0 > 0 ? a:1 : a:module.name
   17   0.001384   0.000317 	let slot = self.variables.modules.find_first_by("get(v:val.slot, 'name', '') == " . string(name))
   17              0.000059 	if empty(slot)
   17   0.000599   0.000260 		call self.variables.modules.connect({ "name" : name, "module" : a:module })
                            	else
                            		let slot.slot.module = a:module
   17              0.000027 	endif
                            " 	let self.variables.modules[name] = a:module

FUNCTION  vimspector#OnBufferCreated()
    Defined: ~/.vim/plugged/vimspector/autoload/vimspector.vim:508
Called 6 times
Total time:   0.000195
 Self time:   0.000169

count  total (s)   self (s)
    6              0.000052   if len( a:file_name ) == 0
    3              0.000006     return
    3              0.000005   endif

                              " Don't actually load up vimsepctor python in autocommands that trigger
                              " regularly. We'll only create the session obkect in s:Enabled()
    3   0.000087   0.000061   if !s:Initialised()
    3              0.000004     return
                              endif

                              if !s:Enabled()
                                return
                              endif

                              py3 _vimspector_session.RefreshSigns( vim.eval( 'a:file_name' ) )

FUNCTION  <SNR>26_execute_term()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:767
Called 2 times
Total time:   0.137101
 Self time:   0.004977

count  total (s)   self (s)
    2              0.000036   let winrest = winrestcmd()
    2              0.000020   let pbuf = bufnr('')
    2   0.066176   0.000068   let [ppos, winopts, is_popup] = s:split(a:dict)
    2   0.000101   0.000027   call s:use_sh()
    2              0.000005   let b:fzf = a:dict
    2              0.000031   let fzf = { 'buf': bufnr(''), 'pbuf': pbuf, 'ppos': ppos, 'dict': a:dict, 'temps': a:temps, 'winopts': winopts, 'winrest': winrest, 'lines': &lines, 'columns': &columns, 'command': a:command }
    2              0.000006   function! fzf.switch_back(inplace)
                                if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
                                endif
                              endfunction
    2              0.000004   function! fzf.on_exit(id, code, ...)
                                if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
                                else
                                  if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
                                    close
                                  endif
                                  silent! execute 'tabnext' self.ppos.tab
                                  silent! execute self.ppos.win.'wincmd w'
                                endif

                                if bufexists(self.buf)
                                  execute 'bd!' self.buf
                                endif

                                if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
                                  execute self.winrest
                                endif

                                let lines = s:collect(self.temps)
                                if !s:exit_handler(a:code, self.command, 1)
                                  return
                                endif

                                call s:pushd(self.dict)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)
                              endfunction

    2              0.000002   try
    2   0.001363   0.000024     call s:pushd(a:dict)
    2              0.000005     if s:is_win
                                  let fzf.temps.batchfile = s:fzf_tempname().'.bat'
                                  call writefile(s:wrap_cmds(a:command), fzf.temps.batchfile)
                                  let command = fzf.temps.batchfile
    2              0.000002     else
    2              0.000007       let command = a:command
    2              0.000002     endif
    2              0.000018     let command .= s:term_marker
    2              0.000012     if has('nvim')
    2   0.005300   0.004166       call termopen(command, fzf)
                                else
                                  let term_opts = {'exit_cb': function(fzf.on_exit), 'term_kill': 'term'}
                                  if is_popup
                                    let term_opts.hidden = 1
                                  else
                                    let term_opts.curwin = 1
                                  endif
                                  let fzf.buf = term_start([&shell, &shellcmdflag, command], term_opts)
                                  if exists('&termwinkey')
                                    call setbufvar(fzf.buf, '&termwinkey', '<c-z>')
                                  endif
                                  if is_popup && exists('#TerminalWinOpen')
                                    doautocmd <nomodeline> TerminalWinOpen
                                  endif
                                  if !has('patch-8.0.1261') && !s:is_win
                                    call term_wait(fzf.buf, 20)
                                  endif
    2              0.000002     endif
    2              0.000100     tnoremap <buffer> <c-z> <nop>
    2              0.000005   finally
    2   0.001586   0.000054     call s:dopopd()
    2              0.000003   endtry
    2   0.000117   0.000101   setlocal nospell bufhidden=wipe nobuflisted nonumber
    2   0.061951   0.000030   setf fzf
    2              0.000003   startinsert
    2              0.000003   return []

FUNCTION  <SNR>85_is_excluded_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:111
Called 38 times
Total time:   0.003924
 Self time:   0.003924

count  total (s)   self (s)
   38              0.000184   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
   38              0.000072   endfor

  152              0.000352   for matchw in g:airline_exclude_filenames
  114              0.001730     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
  114              0.000082     endif
  152              0.000354   endfor

   38              0.000113   if g:airline_exclude_preview && &previewwindow
                                return 1
   38              0.000032   endif

   38              0.000053   return 0

FUNCTION  20()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:344
Called 11 times
Total time:   0.001688
 Self time:   0.001133

count  total (s)   self (s)
   11              0.000021     let i = 0
   46              0.000138     while i < len(g:NERDTreeSortOrder)
   39   0.001258   0.000704         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
    4              0.000005             return i
   35              0.000022         endif
   35              0.000055         let i = i + 1
   42              0.000037     endwhile

    7              0.000024     return index(g:NERDTreeSortOrder, '*')

FUNCTION  22()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:374
Called 66 times
Total time:   0.008384
 Self time:   0.006538

count  total (s)   self (s)
   66              0.000374     if !exists('self._sortKey') || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
                                    " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
   11              0.000022         let metadata = []
   66              0.000097         for tag in g:NERDTreeSortOrder
   55              0.000300             if tag =~? '\[\[-\?timestamp\]\]'
                                            let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~# '-' ? -1 : 1)]
   55              0.000239             elseif tag =~? '\[\[-\?size\]\]'
                                            let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~# '-' ? -1 : 1)]
   55              0.000262             elseif tag =~? '\[\[extension\]\]'
                                            let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
                                            let metadata += [self.isDirectory ? '' : (extension ==# '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
   55              0.000037             endif
   66              0.000060         endfor

   11              0.000060         if g:NERDTreeSortOrder[0] =~# '\[\[.*\]\]'
                                        " Apply tags' sorting first if specified first.
                                        let self._sortKey = metadata + [self.getSortOrderIndex()]
   11              0.000008         else
                                        " Otherwise, do regex grouping first.
   11   0.001807   0.000119             let self._sortKey = [self.getSortOrderIndex()] + metadata
   11              0.000009         endif

   11   0.000236   0.000078         let path = self.getLastPathComponent(1)
   11              0.000020         if !g:NERDTreeSortHiddenFirst
                                        let path = substitute(path, '^[._]', '', '')
   11              0.000008         endif
   11              0.000020         if !g:NERDTreeCaseSensitiveSort
   11              0.000040             let path = tolower(path)
   11              0.000008         endif

   11              0.000081         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
   66              0.000046     endif
   66              0.000097     return self._sortKey

FUNCTION  24()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:432
Called 451 times
Total time:   0.017322
 Self time:   0.007534

count  total (s)   self (s)
  451   0.016607   0.006819     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  26()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:453
Called 451 times
Total time:   0.124147
 Self time:   0.055100

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
  451   0.012096   0.010139     if a:nerdtree.ui.isIgnoreFilterEnabled()
  902              0.002939         for i in g:NERDTreeIgnore
  451   0.042686   0.004659             if self._ignorePatternMatches(i)
                                            return 1
  451              0.000429             endif
  902              0.001585         endfor

  451   0.014304   0.006154         for Callback in g:NERDTree.PathFilters()
                                        let Callback = type(Callback) ==# type(function('tr')) ? Callback : function(Callback)
                                        if Callback({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
  451              0.000917         endfor
  451              0.000481     endif

                                "dont show hidden files unless instructed to
  451   0.027912   0.007906     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
  164              0.000274         return 1
  287              0.000230     endif

  287   0.004243   0.003336     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
  287              0.000302     endif

  287              0.000348     return 0

FUNCTION  27()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:484
Called 451 times
Total time:   0.038027
 Self time:   0.027721

count  total (s)   self (s)
  451              0.001604     let pat = a:pattern
  451              0.004283     if strpart(pat,len(pat)-7) ==# '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
  451              0.002745     elseif strpart(pat,len(pat)-8) ==# '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
  451              0.000371     endif

  451   0.020338   0.010032     return self.getLastPathComponent(0) =~# pat

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:164
Called 5 times
Total time:   0.003184
 Self time:   0.000327

count  total (s)   self (s)
    5   0.001685   0.000226   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    5   0.001488   0.000089   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>57_strip_trailing_new_line()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:232
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000028   return substitute(a:line, '[[:cntrl:]]$', '', '')

FUNCTION  111()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:88
Called 164 times
Total time:   0.013613
 Self time:   0.004555

count  total (s)   self (s)
  164   0.013495   0.004437     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  112()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:102
Called 165 times
Total time:   0.111192
 Self time:   0.006477

count  total (s)   self (s)
  165   0.111045   0.006330     return self.path.str() ==# a:treenode.path.str()

FUNCTION  115()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:157
Called 1119 times
Total time:   0.005129
 Self time:   0.005129

count  total (s)   self (s)
 1119              0.004140     return self._nerdtree

FUNCTION  119()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:196
Called 165 times
Total time:   0.124037
 Self time:   0.010784

count  total (s)   self (s)
  165   0.003707   0.002619     if !g:NERDTree.ExistsForBuf()
                                    throw 'NERDTree.NoTreeError: No tree exists for the current buffer'
  165              0.000151     endif

  165   0.119311   0.007146     return self.equals(self.getNerdtree().root)

FUNCTION  nerdtree#compareNodes()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:114
Called 33 times
Total time:   0.011068
 Self time:   0.000574

count  total (s)   self (s)
   33   0.011050   0.000556     return nerdtree#compareNodePaths(a:n1.path, a:n2.path)

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:19
Called 3319 times
Total time:   0.072368
 Self time:   0.072368

count  total (s)   self (s)
 3319              0.021967   let nr = get(a:000, 0, 0)
 3319              0.021040   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
 3319              0.003609   else
 3319              0.011815     return winwidth(nr)
                              endif

FUNCTION  <SNR>104_build_sections()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 51 times
Total time:   0.046798
 Self time:   0.012947

count  total (s)   self (s)
  250              0.000616   for key in a:keys
  199              0.001127     if (key == 'warning' || key == 'error') && !a:context.active
   20              0.000021       continue
  179              0.000138     endif
  179   0.043622   0.009770     call s:add_section(a:builder, a:context, key)
  230              0.000370   endfor

FUNCTION  328()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:293
Called 30 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
   30              0.000066 	return self.variables.enable_keymapping

FUNCTION  329()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:303
Called 4 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    4              0.000009 	return self.variables.exit_code

FUNCTION  302()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:131
Called 15 times
Total time:   0.000159
 Self time:   0.000159

count  total (s)   self (s)
   15              0.000062 	if self.variables.tap_key == a:key
                            		let self.variables.tap_key = ""
                            		return 1
   15              0.000024 	endif

FUNCTION  <SNR>110_MapMotion()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:5958
Called 20 times
Total time:   0.025831
 Self time:   0.002239

count  total (s)   self (s)
   20   0.010324   0.000892   call s:Map('n', a:lhs, ":<C-U>" . a:rhs . "<CR>", "<silent>")
   20   0.007139   0.000725   call s:Map('o', a:lhs, ":<C-U>" . a:rhs . "<CR>", "<silent>")
   20   0.008323   0.000576   call s:Map('x', a:lhs, ":<C-U>exe 'normal! gv'<Bar>" . a:rhs . "<CR>", "<silent>")

FUNCTION  <SNR>123_version_requirement()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:51
Called 1 time
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000012   let val = split(a:val, '\.')
    1              0.000009   let min = split(a:min, '\.')
    2              0.000011   for idx in range(0, len(min) - 1)
    2              0.000008     let v = get(val, idx, 0)
    2              0.000009     if     v < min[idx] | return 0
    3              0.000008     elseif v > min[idx] | return 1
    1              0.000001     endif
    1              0.000001   endfor
                              return 1

FUNCTION  303()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:139
Called 501 times
Total time:   0.001558
 Self time:   0.001558

count  total (s)   self (s)
  501              0.001265 	return self.variables.tap_key

FUNCTION  304()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:144
Called 501 times
Total time:   0.013422
 Self time:   0.010644

count  total (s)   self (s)
  501              0.002541 	let prekey = get(a:, 1, "")
  501   0.010403   0.007624 	return self.get_tap_key() ==# prekey		&& self.char() ==# a:key
                            " \		&& self.char() == (prekey . a:key)

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:176
Called 38 times
Total time:   0.014862
 Self time:   0.010854

count  total (s)   self (s)
   38   0.014818   0.010810   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  307()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:162
Called 30 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
   30              0.000069 	return self.variables.prompt

FUNCTION  32()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:562
Called 12 times
Total time:   0.007842
 Self time:   0.000746

count  total (s)   self (s)
   12              0.000359     let l:newPath = copy(self)

   12   0.007144   0.000181     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))

   12              0.000036     let l:newPath.cachedDisplayString = ''
   12   0.000243   0.000110     let l:newPath.flagSet = g:NERDTreeFlagSet.New()

   12              0.000017     return l:newPath

FUNCTION  33()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:578
Called 25 times
Total time:   0.001428
 Self time:   0.001428

count  total (s)   self (s)
   25              0.000736     let tmp = resolve(a:path)
   25              0.000670     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  34()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:587
Called 12 times
Total time:   0.004930
 Self time:   0.002435

count  total (s)   self (s)
   12   0.000589   0.000088     call self.extractDriveLetter(a:fullpath)

   12   0.000377   0.000106     let fullpath = s:Path.WinToUnixPath(a:fullpath)

   12              0.000195     if getftype(fullpath) ==# 'fifo'
                                    throw 'NERDTree.InvalidFiletypeError: Cant handle FIFO files: ' . a:fullpath
   12              0.000009     endif

   12              0.000314     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')

   12              0.000042     let self.isReadOnly = 0
   12              0.000146     if isdirectory(a:fullpath)
    5              0.000020         let self.isDirectory = 1
    7              0.000207     elseif filereadable(a:fullpath)
    7              0.000032         let self.isDirectory = 0
    7              0.000205         let self.isReadOnly = filewritable(a:fullpath) ==# 0
                                else
                                    throw 'NERDTree.InvalidArgumentsError: Invalid path = ' . a:fullpath
   12              0.000008     endif

   12              0.000039     let self.isExecutable = 0
   12              0.000021     if !self.isDirectory
    7              0.000109         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
   12              0.000011     endif

                                "grab the last part of the path (minus the trailing slash)
   12   0.000320   0.000124     let lastPathComponent = self.getLastPathComponent(0)

                                "get the path to the new node with the parent dir fully resolved
   12   0.000981   0.000176     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent

                                "if  the last part of the path is a symlink then flag it as such
   12   0.000853   0.000132     let self.isSymLink = (s:Path.Resolve(hardPath) !=# hardPath)
   12              0.000022     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)

                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)

                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'

                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
   12              0.000007     endif

FUNCTION  36()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:645
Called 480 times
Total time:   0.811917
 Self time:   0.019841

count  total (s)   self (s)
  480   0.740812   0.012831     call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
  480   0.069437   0.005341     call self.cacheDisplayString()

FUNCTION  38()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:695
Called 934 times
Total time:   0.308031
 Self time:   0.135865

count  total (s)   self (s)
  934              0.007733     let options = a:0 ? a:1 : {}
  934              0.002517     let toReturn = ''

  934              0.006462     if has_key(options, 'format')
   41              0.000149         let format = options['format']
   41              0.000200         if has_key(self, '_strFor' . format)
   41   0.002058   0.000813             exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
   41              0.000037         endif
  893              0.000714     else
  893   0.175890   0.013309         let toReturn = self._str()
  934              0.001709     endif

  934   0.028368   0.020028     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
  934              0.000914     endif

  934              0.003419     if has_key(options, 'truncateTo')
   41              0.000156         let limit = options['truncateTo']
   41              0.000253         if strdisplaywidth(toReturn) > limit-1
  820              0.006741             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
  779              0.008500                 let toReturn = substitute(toReturn, '^.', '', '')
  820              0.001091             endwhile
   41              0.000517             if len(split(toReturn, '/')) > 1
   41              0.000683                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
   41              0.000037             endif
   41              0.000035         endif
  934              0.001183     endif

  934              0.002430     return toReturn

FUNCTION  39()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:732
Called 41 times
Total time:   0.001245
 Self time:   0.001245

count  total (s)   self (s)
   41              0.000444     let toReturn = '/' . join(self.pathSegments, '/')
   41              0.000274     if self.isDirectory && toReturn !=# '/'
   41              0.000149         let toReturn  = toReturn . '/'
   41              0.000076     endif
   41              0.000206     return toReturn

FUNCTION  <SNR>110_can_diffoff()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:4841
Called 7 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    7              0.000097   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  <SNR>246_process_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:240
Called 40 times
Total time:   0.035555
 Self time:   0.012004

count  total (s)   self (s)
   40              0.000163   let modifications = []
   40              0.000175   let from_line  = a:hunk[0]
   40              0.000138   let from_count = a:hunk[1]
   40              0.000120   let to_line    = a:hunk[2]
   40              0.000152   let to_count   = a:hunk[3]

   40   0.001017   0.000605   if s:is_added(from_count, to_count)
   12   0.005160   0.000440     call s:process_added(modifications, from_count, to_count, to_line)
   12   0.001743   0.000248     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)

   28   0.001137   0.000992   elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)

   28   0.000665   0.000481   elseif s:is_modified(from_count, to_count)
   16   0.001082   0.000387     call s:process_modified(modifications, from_count, to_count, to_line)
   16   0.004690   0.001762     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)

   12   0.003137   0.000940   elseif s:is_modified_and_added(from_count, to_count)
   12   0.003881   0.000775     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
   12   0.007636   0.001288     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
   12   0.001530   0.000211     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)

                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)

   40              0.000041   endif
   40              0.000098   return modifications

FUNCTION  <SNR>97_check_mixed_indent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:17
Called 3 times
Total time:   0.009940
 Self time:   0.009940

count  total (s)   self (s)
    3              0.000028   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    3              0.000008   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
    3              0.000008   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw', 0, 500)
    3              0.000003   else
    3              0.009833     return search('\v(^\t+ +)|(^ +\t+)', 'nw', 0, 500)
                              endif

FUNCTION  120()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:210
Called 11 times
Total time:   0.000490
 Self time:   0.000260

count  total (s)   self (s)
   11              0.000018     if a:path.isDirectory
    4   0.000263   0.000033         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
    7              0.000006     else
    7              0.000094         let newTreeNode = copy(self)
    7              0.000022         let newTreeNode.path = a:path
    7              0.000017         let newTreeNode.parent = {}
    7              0.000018         let newTreeNode._nerdtree = a:nerdtree
    7              0.000011         return newTreeNode
                                endif

FUNCTION  126()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:262
Called 1 time
Total time:   0.000551
 Self time:   0.000059

count  total (s)   self (s)
    1   0.000508   0.000016     let ln = self.getNerdtree().ui.getLineNum(self)
    1              0.000003     if ln != -1
    1              0.000002         if a:isJump
                                        mark '
    1              0.000001         endif
    1              0.000006         call cursor(ln, col('.'))
                                else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call self._nerdtree.render()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
    1              0.000001     endif

FUNCTION  128()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:288
Called 280 times
Total time:   0.474150
 Self time:   0.005553

count  total (s)   self (s)
  280   0.473878   0.005282     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  <SNR>135_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules.vim:35
Called 10 times
Total time:   0.027499
 Self time:   0.000336

count  total (s)   self (s)
   10   0.027208   0.000135 	let module = s:get(a:name)
   10   0.000278   0.000189 	return call(module.make, a:000, module)

FUNCTION  FugitiveIsGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:155
Called 51 times
Total time:   0.004643
 Self time:   0.004643

count  total (s)   self (s)
   51              0.001194   let path = substitute(a:path, '[\/]$', '', '') . '/'
   51              0.003372   return len(a:path) && getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  <SNR>245_nvim_output_handler()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:232
Called 15 times
Total time:   0.000460
 Self time:   0.000460

count  total (s)   self (s)
   15              0.000221     if a:event == 'stdout' || a:event == 'stderr'
   15              0.000180       let self.buf .=  join(a:data)
   15              0.000023     endif

FUNCTION  334()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:344
Called 1 time
Total time:   0.298912
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000006 	let Old_execute = self.execute
    1              0.000004 	let self.execute = self.__empty
    1              0.000001 	try
    1   0.298886   0.000014 		let exit_code = call(self.start, a:000, self)
    1              0.000002 		if exit_code == 0
                            			return self.getline()
    1              0.000001 		endif
    1              0.000001 	finally
    1              0.000004 		let self.execute = Old_execute
    1              0.000001 	endtry
    1              0.000001 	return ""

FUNCTION  <SNR>19_variables()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:260
Called 5 times
Total time:   0.000969
 Self time:   0.000969

count  total (s)   self (s)
    5              0.000080   let info = getbufinfo(a:bufnr)
    5              0.000117   let variables = empty(info) ? {} : copy(info[0]['variables'])
   54              0.000147   for key in keys(variables)
   49              0.000302     if key !~# '\v^coc'
   48              0.000152       unlet variables[key]
   49              0.000040     endif
   54              0.000050   endfor
    5              0.000013   return variables

FUNCTION  338()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:375
Called 15 times
Total time:   0.000206
 Self time:   0.000162

count  total (s)   self (s)
   15   0.000197   0.000153 	return remove(self.input_key_stack(), 0)

FUNCTION  nerdtree#checkForBrowse()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:73
Called 9 times
Total time:   0.000184
 Self time:   0.000184

count  total (s)   self (s)
    9              0.000155     if !isdirectory(a:dir)
    9              0.000014         return
                                endif

                                if s:reuseWin(a:dir)
                                    return
                                endif

                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  389()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:41
Called 15 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
   15              0.000040 	return self.value

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:37
Called 227 times
Total time:   0.005170
 Self time:   0.005170

count  total (s)   self (s)
  227              0.000885   let x = a:i - 1
  250              0.000512   while x >= 0
  210              0.000833     let group = a:sections[x][0]
  210              0.001270     if group != '' && group != '|'
  187              0.000375       return group
   23              0.000022     endif
   23              0.000035     let x = x - 1
   63              0.000114   endwhile
   40              0.000058   return ''

FUNCTION  <SNR>134_match_key()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Keymapping.vim:48
Called 15 times
Total time:   0.001088
 Self time:   0.001088

count  total (s)   self (s)
   15              0.000202 	let keys = sort(keys(a:keymapping))
   15              0.000870 	return get(filter(keys, 'stridx(a:key, v:val) == 0'), -1, '')

FUNCTION  43()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:790
Called 893 times
Total time:   0.162581
 Self time:   0.095856

count  total (s)   self (s)
  893   0.094817   0.042166     let l:separator = nerdtree#slash()
  893              0.003035     let l:leader = l:separator

  893   0.043429   0.029355     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
  893              0.001327     endif

  893              0.013482     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  44()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:803
Called 12 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
   12              0.000140     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  46()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:830
Called 12 times
Total time:   0.000271
 Self time:   0.000174

count  total (s)   self (s)
   12   0.000239   0.000142     if !nerdtree#runningWindows()
   12              0.000021         return a:pathstr
                                endif

                                let toReturn = a:pathstr

                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', '')

                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', '')

                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', 'g')

                                return toReturn

FUNCTION  <SNR>128__import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:158
Called 31 times
Total time:   0.107728
 Self time:   0.011814

count  total (s)   self (s)
   31              0.000169   if has_key(s:loaded, a:name)
    4              0.000092     return copy(s:loaded[a:name])
   27              0.000025   endif
   27   0.065538   0.000610   let module = self._get_module(a:name)
   27              0.000143   if has_key(module, '_vital_created')
                                call module._vital_created(module)
   27              0.000036   endif
   27              0.001334   let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module.vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
   27              0.000198   let s:loaded[a:name] = export_module
   27              0.000113   if has_key(module, '_vital_loaded')
   10              0.000014     try
   10   0.001111   0.000763       call module._vital_loaded(vital#{s:plugin_name}#new())
                                catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception
   10              0.000014     endtry
   27              0.000023   endif
   27              0.000232   return copy(s:loaded[a:name])

FUNCTION  <SNR>110_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:281
Called 271 times
Total time:   0.054421
 Self time:   0.008074

count  total (s)   self (s)
  271   0.054139   0.007792   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  373()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:78
Called 17 times
Total time:   0.000820
 Self time:   0.000820

count  total (s)   self (s)
   17              0.000803 	return filter(copy(self.variables.slots), a:expr)

FUNCTION  300()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:121
Called 15 times
Total time:   0.000617
 Self time:   0.000124

count  total (s)   self (s)
   15   0.000606   0.000113 	return self.line.set_pos(a:pos)

FUNCTION  <SNR>110_ConfigTimestamps()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:528
Called 3 times
Total time:   0.002272
 Self time:   0.000533

count  total (s)   self (s)
    3              0.000043   let files = ['/etc/gitconfig', '~/.gitconfig', len($XDG_CONFIG_HOME) ? $XDG_CONFIG_HOME . '/git/config' : '~/.config/git/config']
    3              0.000009   if len(a:dir)
    3   0.001789   0.000050     call add(files, fugitive#Find('.git/config', a:dir))
    3              0.000003   endif
    3              0.000022   call extend(files, get(a:dict, 'include.path', []))
    3              0.000398   return join(map(files, 'getftime(expand(v:val))'), ',')

FUNCTION  130()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:310
Called 41 times
Total time:   0.355028
 Self time:   0.000854

count  total (s)   self (s)
   41   0.354966   0.000792     return self._renderToString(0, 0)

FUNCTION  131()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:319
Called 328 times
Total time:   0.532735
 Self time:   0.370160

count  total (s)   self (s)
  328              0.000845     let output = ''
  328              0.000833     if a:drawText ==# 1

  287              0.001578         let treeParts = repeat('  ', a:depth - 1)
  287              0.002533         let treeParts .= (self.path.isDirectory || g:NERDTreeDirArrowExpandable ==# '' ? '' : '  ')

  287   0.158140   0.005236         let line = treeParts . self.displayString()
  287              0.001251         let output = output . line . "\n"
  328              0.000320     endif

                                " if the node is an open dir, draw its children
  328              0.001772     if self.path.isDirectory ==# 1 && self.isOpen ==# 1

   41   0.140473   0.000906         let childNodesToDraw = self.getVisibleChildren()

   41   0.027357   0.001060         if self.isCascadable() && a:depth > 0

                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)

   41              0.000178         elseif len(childNodesToDraw) > 0
  328              0.000668             for i in childNodesToDraw
  287              0.002241                 let output = output . i._renderToString(a:depth + 1, 1)
  328              0.000395             endfor
   41              0.000035         endif
  328              0.000228     endif

  328              0.000606     return output

FUNCTION  137()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:86
Called 11 times
Total time:   0.000911
 Self time:   0.000256

count  total (s)   self (s)
   11   0.000660   0.000145     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
   11   0.000224   0.000084     call self.addChild(newTreeNode, a:inOrder)
   11              0.000016     return newTreeNode

FUNCTION  138()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:95
Called 123 times
Total time:   0.139291
 Self time:   0.014389

count  total (s)   self (s)
  123              0.000407     let l:result = ''

                                " Build a label that identifies this TreeDirNode.
  123              0.000276     let l:label = ''
  123   0.119313   0.002206     let l:cascade = self.getCascade()
  246              0.000663     for l:dirNode in l:cascade
  123   0.003421   0.001543         let l:next = l:dirNode.path.displayString()
  123              0.001004         let l:label .= l:label ==# '' ? l:next : substitute(l:next,'^.','','')
  246              0.000471     endfor

                                " Select the appropriate open/closed status indicator symbol.
  123              0.002431     let l:symbol = (l:cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable )
  123              0.000985     let l:symbol .= (g:NERDTreeDirArrowExpandable ==# '' ? '' : ' ')
  123   0.007803   0.001887     let l:flags = l:cascade[-1].path.flagSet.renderToString()

  123              0.000568     return l:symbol . l:flags . l:label

FUNCTION  378()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:29
Called 1564 times
Total time:   0.003859
 Self time:   0.003859

count  total (s)   self (s)
 1564              0.003088 		return a:val.slot.module

FUNCTION  340()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:388
Called 1 time
Total time:   0.000125
 Self time:   0.000058

count  total (s)   self (s)
    1              0.000003 	let self.variables.tap_key = ""
    1              0.000002 	let self.variables.char = ""
    1              0.000003 	let self.variables.input = ""
    1              0.000002 	let self.variables.exit = 0
    1              0.000003 	let self.variables.exit_code = 1
    1              0.000003 	let self.variables.enable_keymapping = 1
    1              0.000003 	let self.variables.input_key_stack = []
    1   0.000103   0.000037 	let self.line = deepcopy(s:String.make())

FUNCTION  341()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:416
Called 1 time
Total time:   0.000995
 Self time:   0.000201

count  total (s)   self (s)
    1   0.000133   0.000008 	call self.__init_variables()
    1   0.000089   0.000009 	call self.hl_cursor_off()
    1              0.000022 	if !hlexists(self.highlights.cursor)
    1   0.000606   0.000016 		if s:_is_valid_highlight("Cursor")
                            			execute "highlight link " . self.highlights.cursor . " Cursor"
    1              0.000001 		else
                            			" Workaround by CUI Vim Cursor Highlight
                            			" issues #92
                            			" https://github.com/osyo-manga/vital-over/issues/92
    1              0.000032 			execute "highlight " . self.highlights.cursor . " term=reverse cterm=reverse gui=reverse"
    1              0.000001 		endif
    1              0.000001 	endif
    1              0.000022 	if !hlexists(self.highlights.cursor_on)
    1              0.000028 		execute "highlight link " . self.highlights.cursor_on . " " . self.highlights.cursor
    1              0.000001 	endif
    1              0.000021 	if !hlexists(self.highlights.cursor_insert)
    1              0.000029 		execute "highlight " . self.highlights.cursor_insert . " cterm=underline term=underline gui=underline"
    1              0.000001 	endif

FUNCTION  345()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:470
Called 16 times
Total time:   0.086766
 Self time:   0.002172

count  total (s)   self (s)
   16              0.000051 	if a:input == ""
    1              0.000002 		return
   15              0.000012 	endif

   15              0.000054 	let self.variables.input_key = a:input
   15              0.000026 	if a:0 == 0
                            		let keymapping = self.__get_keymapping()
   15              0.000015 	else
   15              0.000041 		let keymapping = a:1
   15              0.000012 	endif
   15   0.000196   0.000152 	if self.is_enable_keymapping()
   15   0.003142   0.000217 		let key = s:Keymapping.unmapping(keymapping, a:input)
                            	else
                            		let key = a:input
   15              0.000013 	endif
   15              0.000032 	if key == ""
                            		return
   15              0.000010 	endif

   15   0.001258   0.000356 	call self.set_input_key_stack(s:String.split_by_keys(key))
   30   0.000640   0.000468 	while !(empty(self.input_key_stack()) || self.is_exit())
   15   0.080890   0.000339 		call self.__input_char(self.input_key_stack_pop())
   30              0.000061 	endwhile

FUNCTION  <SNR>9_Observe()
    Defined: ~/.vim/plugged/vim-polyglot/ftdetect/polyglot.vim:2650
Called 2 times
Total time:   0.000753
 Self time:   0.000753

count  total (s)   self (s)
    2              0.000018   let b:PolyglotObserve = function("polyglot#" . a:fn)
    2              0.000005   augroup polyglot-observer
    2              0.000656     au!
    2              0.000056     au CursorHold,CursorHoldI,BufWritePost <buffer> call b:PolyglotObserve()
    2              0.000006   augroup END

FUNCTION  347()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:530
Called 15 times
Total time:   0.271939
 Self time:   0.001075

count  total (s)   self (s)
                            " 	call self.callevent("on_update")
                            " 	if !getchar(1)
                            " 		continue
                            " 	endif
                            "
                            " 	call self.__input(s:getchar(0))
                            " 	call self.draw()

   15   0.013013   0.000200 	call self.callevent("on_update")
   15   0.105029   0.000486 	call self.__inputting()
                            " 	call self.__input(s:Input.getchar())
   15   0.000182   0.000130 	if self.is_exit()
    1              0.000002 		return -1
   14              0.000011 	endif
   14   0.153561   0.000104 	call self.draw()

FUNCTION  348()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:549
Called 1 time
Total time:   0.298854
 Self time:   0.000589

count  total (s)   self (s)
    1              0.000001 	try
    1   0.001013   0.000018 		call self.__init()
    1   0.005405   0.000015 		call self.callevent("on_enter")

    1   0.000021   0.000015 		call self.__input(get(a:, 1, ""))
    1   0.015969   0.000007 		call self.draw()
   15   0.000191   0.000142 		while !self.is_exit()
   15              0.000019 			try
   15   0.272066   0.000127 				if self.__update()
    1              0.000002 					break
   14              0.000012 				endif
                            			catch
                            				call self.callevent("on_exception")
   15              0.000020 			endtry
   15              0.000019 		endwhile
                            	catch
                            		echohl ErrorMsg | echom v:throwpoint . " " . v:exception | echohl None
                            		let self.variables.exit_code = -1
    1              0.000006 	finally
    1   0.000148   0.000017 		call self.__finish()
    1   0.003810   0.000020 		call self.callevent("on_leave")
    1              0.000002 	endtry
    1   0.000013   0.000010 	return self.exit_code()

FUNCTION  <SNR>110_sub()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:21
Called 1 time
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
    1              0.000214   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  <SNR>246_git_supports_command_line_config_override()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:8
Called 1 time
Total time:   0.051980
 Self time:   0.000101

count  total (s)   self (s)
    1   0.051943   0.000063   call gitgutter#utility#system(g:gitgutter_git_executable.' '.g:gitgutter_git_args.' -c foo.bar=baz --version')
    1              0.000023   return !v:shell_error

FUNCTION  <SNR>28_on_focus_gained()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:77
Called 3 times
Total time:   0.191862
 Self time:   0.001084

count  total (s)   self (s)
    3   0.001079   0.000938   if airline#util#try_focusgained()
    3   0.190760   0.000124     unlet! w:airline_lastmode | :call <sid>airline_refresh(1)
    3              0.000008   endif

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:205
Called 4 times
Total time:   0.006825
 Self time:   0.002102

count  total (s)   self (s)
    4              0.000023   let hunks = []
   44              0.000183   for line in split(a:diff, '\n')
   40   0.005996   0.001273     let hunk_info = gitgutter#diff#parse_hunk(line)
   40              0.000177     if len(hunk_info) == 4
   40              0.000197       call add(hunks, hunk_info)
   40              0.000048     endif
   44              0.000050   endfor
    4              0.000008   return hunks

FUNCTION  386()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Redraw.vim:53
Called 1 time
Total time:   0.001741
 Self time:   0.001741

count  total (s)   self (s)
    1              0.001574 	redraw
                            	" Workaround for the :set cedit=<C-c>
                            	" https://github.com/osyo-manga/vital-over/issues/52
                            	" https://github.com/Lokaltog/vim-easymotion/issues/177#issuecomment-53663431
    1              0.000019 	if &cedit != "<C-c>"	||(v:version > 704 || v:version == 704 && has("patch441"))
    1              0.000130 		normal! :
                            	else
                            		execute "normal! :\<Esc>"
    1              0.000002 	endif

FUNCTION  140()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:141
Called 123 times
Total time:   0.117107
 Self time:   0.005313

count  total (s)   self (s)
  123   0.116492   0.004698     if !self.isCascadable()
  123              0.000381         return [self]
                                endif

                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]

                                return [self] + visChild.getCascade()

FUNCTION  142()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:180
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004     return len(self.children)

FUNCTION  147()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:272
Called 2 times
Total time:   0.001029
 Self time:   0.000736

count  total (s)   self (s)

                                " Construct a path specification such that globpath() will return
                                " relative pathnames, if possible.
    2   0.000440   0.000147     if self.path.str() ==# getcwd()
    2              0.000008         let l:pathSpec = ','
                                else
                                    let l:pathSpec = escape(fnamemodify(self.path.str({'format': 'Glob'}), ':.'), ',')

                                    " On Windows, the drive letter may be removed by "fnamemodify()".
                                    if nerdtree#runningWindows() && l:pathSpec[0] == nerdtree#slash()
                                        let l:pathSpec = self.path.drive . l:pathSpec
                                    endif
    2              0.000001     endif

    2              0.000004     let l:globList = []

                                " See ':h version7.txt' and ':h version8.txt' for details on the
                                " development of the glob() and globpath() functions.
    2              0.000008     if v:version > 704 || (v:version ==# 704 && has('patch654'))
    2              0.000345         let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1, 0)
                                elseif v:version ==# 704 && has('patch279')
                                    let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1)
                                elseif v:version > 702 || (v:version ==# 702 && has('patch051'))
                                    let l:globString = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore)
                                    let l:globList = split(l:globString, "\n")
                                else
                                    let l:globString = globpath(l:pathSpec, a:pattern)
                                    let l:globList = split(l:globString, "\n")
    2              0.000001     endif

                                " If a:all is false, filter '.' and '..' from the output.
    2              0.000003     if !a:all
    1              0.000002         let l:toRemove = []

    2              0.000005         for l:file in l:globList
    2              0.000009             let l:tail = fnamemodify(l:file, ':t')

                                        " If l:file has a trailing slash, then its :tail will be ''. Use
                                        " :h to drop the slash and the empty string after it; then use :t
                                        " to get the directory name.
    2              0.000004             if l:tail ==# ''
                                            let l:tail = fnamemodify(l:file, ':h:t')
    2              0.000002             endif

    2              0.000005             if l:tail ==# '.' || l:tail ==# '..'
    2              0.000008                 call add(l:toRemove, l:file)
    2              0.000006                 if len(l:toRemove) ==# 2
    1              0.000001                     break
    1              0.000001                 endif
    1              0.000001             endif
    2              0.000004         endfor

    3              0.000005         for l:file in l:toRemove
    2              0.000011             call remove(l:globList, index(l:globList, l:file))
    3              0.000003         endfor
    2              0.000002     endif

    2              0.000003     return l:globList

FUNCTION  351()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:586
Called 45 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
   45              0.000112 	return self.variables.exit

FUNCTION  352()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:591
Called 15 times
Total time:   0.008082
 Self time:   0.004295

count  total (s)   self (s)
   15              0.000051 	let result = {}
                            " 	for module in values(self.variables.modules)
  270   0.003418   0.000636 	for module in self.variables.modules.slots()
  255              0.000816 		if has_key(module, "keymapping")
   30              0.000063 			if module isnot self
   15   0.001243   0.000368 				call extend(result, module.keymapping(self))
   30              0.000036 			endif
  255              0.000150 		endif
  270              0.000211 	endfor
   15   0.000443   0.000312 	return extend(extend(result, self.variables.keymapping), self.keymapping())

FUNCTION  353()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:41
Called 23 times
Total time:   0.001026
 Self time:   0.000408

count  total (s)   self (s)
   23   0.001011   0.000392 	return type(a:item) == type("") ? self.set_str(a:item)		 : type(a:item) == type(0)  ? self.set_pos(a:item)		 : self

FUNCTION  354()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:47
Called 45 times
Total time:   0.000340
 Self time:   0.000340

count  total (s)   self (s)
   45              0.000304 	return join(self.list, "")

FUNCTION  355()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:51
Called 22 times
Total time:   0.000713
 Self time:   0.000437

count  total (s)   self (s)
   22   0.000647   0.000371 	let self.col = s:_clamp(a:pos, 0, self.length())
   22              0.000045 	return self

FUNCTION  356()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:56
Called 15 times
Total time:   0.000169
 Self time:   0.000169

count  total (s)   self (s)
   15              0.000156 	return self.col > 0 ? join(self.list[ : self.col-1], '') : ""

FUNCTION  359()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:68
Called 16 times
Total time:   0.000399
 Self time:   0.000399

count  total (s)   self (s)
   16              0.000280 	let self.list = split(a:str, '\zs')
   16              0.000071 	let self.col  = strchars(a:str)
   16              0.000024 	return self

FUNCTION  <SNR>28_airline_refresh()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:216
Called 3 times
Total time:   0.190636
 Self time:   0.000914

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    3              0.000064   let fast=!empty(get(a:000, 0, 0))
    3              0.000026   if !exists("#airline")
                                " disabled
                                return
    3              0.000004   endif
    3   0.007020   0.000104   call airline#util#doautocmd('AirlineBeforeRefresh')
    3   0.001433   0.000147   call airline#highlighter#reset_hlcache()
    3              0.000047   if !fast
                                call airline#load_theme()
    3              0.000008   endif
    3   0.181753   0.000321   call airline#update_statusline()
    3   0.000216   0.000127   call airline#update_tabline()

FUNCTION  <SNR>127_getPromptMessage()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:207
Called 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000003     if a:num_strokes == 1
                                    let prompt = substitute( substitute(g:EasyMotion_prompt,'{n}', a:num_strokes, 'g'), '(s)', '', 'g')
    1              0.000002     elseif a:num_strokes == -1
    1              0.000027         let prompt = substitute( substitute(g:EasyMotion_prompt, '{n}\s\{0,1}', '', 'g'), '(s)', 's', 'g')
                                else
                                    let prompt = substitute( substitute(g:EasyMotion_prompt,'{n}', a:num_strokes, 'g'), '(s)', 's', 'g')
    1              0.000001     endif
    1              0.000003     return prompt

FUNCTION  <SNR>245_set_clean_jobs_variable()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:80
Called 3 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
    3              0.000050   if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
    3              0.000006   endif
    3              0.000032   let s:clean_jobs[a:vcs][a:file]=a:id

FUNCTION  <SNR>110_LinesError()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:465
Called 1 time
Total time:   0.047583
 Self time:   0.000352

count  total (s)   self (s)
    1   0.047319   0.000089   let [out, exec_error] = call('s:ChompError', a:000)
    1              0.000261   return [len(out) && !exec_error ? split(out, "\n", 1) : [], exec_error]

FUNCTION  <SNR>26_popup()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:931
Called 2 times
Total time:   0.065565
 Self time:   0.000242

count  total (s)   self (s)
                              " Size and position
    2              0.000045   let width = min([max([8, a:opts.width > 1 ? a:opts.width : float2nr(&columns * a:opts.width)]), &columns])
    2              0.000038   let height = min([max([4, a:opts.height > 1 ? a:opts.height : float2nr(&lines * a:opts.height)]), &lines - has('nvim')])
    2              0.000020   let row = float2nr(get(a:opts, 'yoffset', 0.5) * (&lines - height))
    2              0.000013   let col = float2nr(get(a:opts, 'xoffset', 0.5) * (&columns - width))

                              " Managing the differences
    2              0.000025   let row = min([max([0, row]), &lines - has('nvim') - height])
    2              0.000015   let col = min([max([0, col]), &columns - width])
    2              0.000010   let row += !has('nvim')
    2              0.000007   let col += !has('nvim')

    2   0.065375   0.000051   call s:create_popup('Normal', { 'row': row, 'col': col, 'width': width, 'height': height })

FUNCTION  <SNR>28_on_window_changed()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:51
Called 23 times
Total time:   0.368564
 Self time:   0.003122

count  total (s)   self (s)
                              " don't trigger for Vim popup windows
   23              0.000165   if &buftype is# 'popup'
                                return
   23              0.000020   endif

   23              0.000140   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                " do not trigger for previewwindows
                                return
   23              0.000016   endif
   23              0.000124   let s:active_winnr = winnr()
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
   23              0.000483   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
   23              0.000398   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    8              0.000012     return
   15              0.000012   endif
   15              0.000196   let g:airline_last_window_changed = l:key
   15   0.000307   0.000221   call s:init()
   15   0.366382   0.001026   call airline#update_statusline()

FUNCTION  <SNR>249_syn_name()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/jsx_pretty/comment.vim:32
Called 51 times
Total time:   0.021499
 Self time:   0.021499

count  total (s)   self (s)
   51              0.020962   let syn_id = get(synstack(a:lnum, a:cnum), -1)
   51              0.000421   return synIDattr(syn_id, "name")

FUNCTION  <SNR>26_exit_handler()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:583
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000005   if a:code == 130
    1              0.000001     return 0
    1              0.000006   elseif has('nvim') && a:code == 129
                                " When deleting the terminal buffer while fzf is still running,
                                " Nvim sends SIGHUP.
                                return 0
    1              0.000001   elseif a:code > 1
                                call s:error('Error running ' . a:command)
                                if !empty(a:000)
                                  sleep
                                endif
                                return 0
    1              0.000001   endif
    1              0.000001   return 1

FUNCTION  airline#section#create()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:74
Called 7 times
Total time:   0.002158
 Self time:   0.000142

count  total (s)   self (s)
    7   0.002153   0.000138   return s:create(a:parts, 0)

FUNCTION  150()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:358
Called 164 times
Total time:   0.142321
 Self time:   0.016772

count  total (s)   self (s)
  164              0.000855     let toReturn = []
  615              0.001452     for i in self.children
  451   0.134402   0.008854         if i.path.ignore(self.getNerdtree()) ==# 0
  287              0.001472             call add(toReturn, i)
  451              0.000426         endif
  615              0.000752     endfor
  164              0.000311     return toReturn

FUNCTION  152()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:382
Called 164 times
Total time:   0.138091
 Self time:   0.009917

count  total (s)   self (s)
  164              0.000612     if g:NERDTreeCascadeSingleChildDir ==# 0
                                    return 0
  164              0.000149     endif

  164   0.125376   0.001691     if self.isRoot()
   41              0.000078         return 0
  123              0.000102     endif

  123              0.000381     if self.path.isSymLink
                                    return 0
  123              0.000123     endif

  123   0.003497   0.001761     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self.path)
                                        return 0
                                    endif
  123              0.000222     endfor

  123   0.004271   0.001517     let c = self.getVisibleChildren()
  123              0.000728     return len(c) ==# 1 && c[0].path.isDirectory

FUNCTION  153()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:413
Called 1 time
Total time:   0.086112
 Self time:   0.000658

count  total (s)   self (s)
                                "remove all the current child nodes
    1              0.000003     let self.children = []

    1   0.001057   0.000028     let files = self._glob('*', 1) + self._glob('.*', 0)

    1              0.000005     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo('Please wait, caching a large dir ...')
    1              0.000001     endif

    1              0.000002     let invalidFilesFound = 0
   12              0.000019     for i in files
   11              0.000010         try
   11   0.007456   0.000144             let path = g:NERDTreePath.New(i)
   11   0.001042   0.000131             call self.createChild(path, 0)
   11   0.008544   0.000182             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
                                    catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                        let invalidFilesFound += 1
   11              0.000012         endtry
   12              0.000009     endfor

    1              0.000006     let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder
    1   0.011381   0.000008     call self.sortChildren()

    1   0.056472   0.000011     call nerdtree#echo('')

    1              0.000002     if invalidFilesFound
                                    call nerdtree#echoWarning(invalidFilesFound . ' file(s) could not be loaded into the NERD tree')
    1              0.000001     endif
    1   0.000015   0.000011     return self.getChildCount()

FUNCTION  154()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:451
Called 5 times
Total time:   0.000305
 Self time:   0.000305

count  total (s)   self (s)
    5              0.000010     if a:path.isDirectory !=# 1
                                    throw 'NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object.'
    5              0.000004     endif

    5              0.000192     let newTreeNode = copy(self)
    5              0.000013     let newTreeNode.path = a:path

    5              0.000011     let newTreeNode.isOpen = 0
    5              0.000012     let newTreeNode.children = []

    5              0.000012     let newTreeNode.parent = {}
    5              0.000013     let newTreeNode._nerdtree = a:nerdtree

    5              0.000007     return newTreeNode

FUNCTION  155()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:472
Called 1 time
Total time:   0.086184
 Self time:   0.000072

count  total (s)   self (s)
    1              0.000003     let l:options = a:0 ? a:1 : {}

                                " If special options were specified, process them and return.
    1              0.000009     if has_key(l:options, 'where') && !empty(l:options['where'])
                                    let l:opener = g:NERDTreeOpener.New(self.path, l:options)
                                    call l:opener.open(self)
                                    return 0
    1              0.000001     endif

                                " Open any ancestors of this node that render within the same cascade.
    1              0.000002     let l:parent = self.parent
    1              0.000005     while !empty(l:parent) && !l:parent.isRoot()
                                    if index(l:parent.getCascade(), self) >= 0
                                        let l:parent.isOpen = 1
                                        let l:parent = l:parent.parent
                                    else
                                        break
                                    endif
    1              0.000002     endwhile

    1              0.000002     let self.isOpen = 1

    1              0.000002     let l:numChildrenCached = 0
    1              0.000003     if empty(self.children)
    1   0.086127   0.000015         let l:numChildrenCached = self._initChildren(0)
    1              0.000001     endif

    1              0.000002     return l:numChildrenCached

FUNCTION  <SNR>146__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:21
Called 1 time
Total time:   0.000098
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.000094   0.000014 	let s:String  = s:V.import("Over.String")

FUNCTION  436()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:776
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000005     if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
    1              0.000001     endif

FUNCTION  361()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:78
Called 15 times
Total time:   0.000524
 Self time:   0.000524

count  total (s)   self (s)
   15              0.000284 	call extend(self.list, split(a:str, '\zs'), self.col)
   15              0.000182 	let self.col += len(split(a:str, '\zs'))
   15              0.000028 	return self

FUNCTION  362()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:84
Called 52 times
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
   52              0.000167 	return len(self.list)

FUNCTION  367()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:112
Called 7 times
Total time:   0.000644
 Self time:   0.000068

count  total (s)   self (s)
    7   0.000638   0.000062 	return self.remove(self.col - 1)

FUNCTION  369()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:40
Called 17 times
Total time:   0.000339
 Self time:   0.000339

count  total (s)   self (s)
   17              0.000068 	let self.variables.counter += 1
   17              0.000119 	let slot = { "id" : self.variables.counter, "slot" : a:slot }
   17              0.000090 	call add(self.variables.slots, slot)
   17              0.000030 	return slot

FUNCTION  airline#util#stl_disabled()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:185
Called 58 times
Total time:   0.024481
 Self time:   0.022600

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
   58   0.024275   0.022393   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  <SNR>26_fzf_expand()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:110
Called 1 time
Total time:   0.000019
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000019   0.000010   return s:fzf_call('expand', a:fmt, 1)

FUNCTION  <SNR>26_use_sh()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:401
Called 4 times
Total time:   0.000258
 Self time:   0.000237

count  total (s)   self (s)
    4              0.000063   let [shell, shellslash, shellcmdflag, shellxquote] = [&shell, &shellslash, &shellcmdflag, &shellxquote]
    4              0.000009   if s:is_win
                                set shell=cmd.exe
                                set noshellslash
                                let &shellcmdflag = has('nvim') ? '/s /c' : '/c'
                                let &shellxquote = has('nvim') ? '"' : '('
    4              0.000005   else
    4   0.000099   0.000079     set shell=sh
    4              0.000008   endif
    4              0.000025   return [shell, shellslash, shellcmdflag, shellxquote]

FUNCTION  <SNR>246_save_last_seen_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:415
Called 4 times
Total time:   0.000247
 Self time:   0.000099

count  total (s)   self (s)
    4   0.000240   0.000093   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  vital#_easymotion#Over#Commandline#Modules#InsertRegister#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:5
Called 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000047     return map({'_vital_depends': '', 'to_string': '', 'input': '', 'get_cmdline_cword': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>9_get_shiftwidth()
    Defined: ~/.vim/plugged/vim-polyglot/ftdetect/polyglot.vim:2679
Called 16 times
Total time:   0.006681
 Self time:   0.006681

count  total (s)   self (s)
   16              0.000056     let shiftwidth = 0
   16              0.000030     let max_count = 0
   16              0.000041     let final_counts = {}
   96              0.000342     for [indent, indent_count] in items(a:indents)
   80              0.000227       let indent_count = indent_count * 1.5
  480              0.001485       for [indent2, indent2_count] in items(a:indents)
  400              0.001196         if indent2 > indent && indent2 % indent == 0
   80              0.000215           let indent_count = indent_count + indent2_count
  400              0.000234         endif
  480              0.000343       endfor
   80              0.000274       let final_counts[indent] = indent_count
   96              0.000083     endfor
   96              0.000281     for [indent, final_count] in items(final_counts)
   80              0.000146       if final_count > max_count
    2              0.000004         let shiftwidth = indent
    2              0.000004         let max_count = final_count
   80              0.000046       endif
   96              0.000066     endfor
   16              0.000029     return shiftwidth

FUNCTION  72()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim:35
Called 1 time
Total time:   0.004040
 Self time:   0.000618

count  total (s)   self (s)
   56              0.000107     for i in values(s:keyMaps)
   55   0.003850   0.000428         call i.bind()
   56              0.000061     endfor

FUNCTION  73()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/key_map.vim:42
Called 55 times
Total time:   0.003422
 Self time:   0.003422

count  total (s)   self (s)
                                " If the key sequence we're trying to map contains any '<>' notation, we
                                " must replace each of the '<' characters with '<lt>' to ensure the string
                                " is not translated into its corresponding keycode during the later part
                                " of the map command below
                                " :he <>
   55              0.000184     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
   55              0.000468     if self.key =~# specialNotationRegex
   12              0.000172         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
   43              0.000036     else
   43              0.000126         let keymapInvokeString = self.key
   55              0.000041     endif
   55              0.000264     let keymapInvokeString = escape(keymapInvokeString, '\')

   55              0.000179     let premap = self.key ==# '<LeftRelease>' ? ' <LeftRelease>' : ' '

   55              0.001424     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'

FUNCTION  <SNR>135__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules.vim:21
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V

FUNCTION  FugitiveVimPath()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:301
Called 278 times
Total time:   0.005312
 Self time:   0.005312

count  total (s)   self (s)
  278              0.002908   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
  278              0.000282   else
  278              0.000630     return a:path
                              endif

FUNCTION  NERDTreeRender()
    Defined: ~/.vim/plugged/nerdtree/plugin/NERD_tree.vim:187
Called 40 times
Total time:   0.405942
 Self time:   0.001350

count  total (s)   self (s)
   40   0.405897   0.001306     call nerdtree#renderView()

FUNCTION  <SNR>26_fzf_tempname()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:114
Called 2 times
Total time:   0.000071
 Self time:   0.000044

count  total (s)   self (s)
    2   0.000069   0.000042   return s:fzf_call('tempname')

FUNCTION  162()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:599
Called 200 times
Total time:   1.104665
 Self time:   0.247679

count  total (s)   self (s)
  200   0.351828   0.005806     call self.path.refreshFlags(self.getNerdtree())
  640              0.002448     for i in self.children
  440   0.478363   0.004213         call i.refreshFlags()
  640              0.001171     endfor

FUNCTION  166()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:665
Called 1 time
Total time:   0.011373
 Self time:   0.000305

count  total (s)   self (s)
    1              0.000005     if count(g:NERDTreeSortOrder, '*') < 1
                                    call add(g:NERDTreeSortOrder, '*')
    1              0.000001     endif
    1              0.000005     let CompareFunc = function('nerdtree#compareNodes')
    1   0.011351   0.000283     call sort(self.children, CompareFunc)
    1              0.000006     let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder

FUNCTION  <SNR>17_SyncAutocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:235
Called 2 times
Total time:   0.640327
 Self time:   0.000066

count  total (s)   self (s)
    2              0.000007   if !g:coc_workspace_initialized
                                return
    2              0.000003   endif
    2              0.000004   if g:coc_service_initialized
    2   0.640290   0.000029     call coc#rpc#request('CocAutocmd', a:000)
                              else
                                call coc#rpc#notify('CocAutocmd', a:000)
    2              0.000002   endif

FUNCTION  vital#easymotion#new()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:24
Called 11 times
Total time:   0.000381
 Self time:   0.000154

count  total (s)   self (s)
   11   0.000367   0.000141   return s:new(s:plugin_name)

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:214
Called 149 times
Total time:   0.219813
 Self time:   0.005758

count  total (s)   self (s)
  149              0.001764   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  149   0.217862   0.003807   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  FugitiveGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:11
Called 548 times
Total time:   0.067579
 Self time:   0.037194

count  total (s)   self (s)
  548              0.004737   if !a:0 || type(a:1) == type(0) && a:1 < 0
  278              0.001317     if exists('g:fugitive_event')
                                  return g:fugitive_event
  278              0.000735     endif
  278              0.001782     let dir = get(b:, 'git_dir', '')
  278              0.002172     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
   45   0.030895   0.004426       return FugitiveExtractGitDir(getcwd())
  233              0.000217     endif
  233              0.000453     return dir
  270              0.002070   elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
  270              0.001173   elseif type(a:1) == type('')
  270   0.011707   0.007790     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  372()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:73
Called 77 times
Total time:   0.213810
 Self time:   0.002407

count  total (s)   self (s)
   77   0.213761   0.002357 	return call("s:call", [self.slots(), a:func] + a:000)

FUNCTION  379()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Exit.vim:26
Called 15 times
Total time:   0.000664
 Self time:   0.000268

count  total (s)   self (s)
   15   0.000531   0.000136 	if a:cmdline.is_input("<Over>(exit)")
                            		call a:cmdline.setchar("")
                            		call a:cmdline.exit(self.exit_code)
   15              0.000016 	endif

FUNCTION  graphql#javascript_tags()
    Defined: ~/.vim/plugged/vim-graphql/autoload/graphql.vim:33
Called 4 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    4              0.000039   return get(g:, 'graphql_javascript_tags', ['gql', 'graphql', 'Relay.QL'])

FUNCTION  NERDTreeWebDevIconsRefreshListener()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:602
Called 491 times
Total time:   0.644544
 Self time:   0.166851

count  total (s)   self (s)
  491              0.002163   let path = a:event.subject
  491              0.003333   let postPadding = g:WebDevIconsNerdTreeAfterGlyphPadding
  491              0.002984   let prePadding = g:WebDevIconsNerdTreeBeforeGlyphPadding
  491   0.018094   0.010207   let hasGitFlags = (len(path.flagSet._flagsForScope('git')) > 0)
  491              0.003786   let hasGitNerdTreePlugin = (exists('g:loaded_nerdtree_git_status') == 1)
  491   0.038457   0.029665   let artifactFix = s:DevIconsGetArtifactFix()

                              " align vertically at the same level: non git-flag nodes with git-flag nodes
  491              0.002977   if g:WebDevIconsNerdTreeGitPluginForceVAlign && !hasGitFlags && hasGitNerdTreePlugin
                                let prePadding .= ' '
  491              0.000513   endif

  491              0.001038   if !path.isDirectory
                                " Hey we got a regular file, lets get it's proper icon
  287   0.269903   0.017741     let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str()) . postPadding

  204              0.000896   elseif path.isDirectory && g:WebDevIconsUnicodeDecorateFolderNodes == 1
                                " Ok we got a directory, some more tests and checks
  204              0.000622     let directoryOpened = 0

  204              0.001337     if g:DevIconsEnableFoldersOpenClose && len(path.flagSet._flagsForScope('webdevicons')) > 0
                                  " did the user set different icons for open and close?

                                  " isOpen is not available on the path listener directly
                                  " but we added one via overriding particular keymappings for NERDTree
                                  if has_key(path, 'isOpen') && path.isOpen == 1
                                    let directoryOpened = 1
                                  endif
  204              0.000156     endif

  204              0.000751     if g:WebDevIconsUnicodeDecorateFolderNodesExactMatches == 1
                                  " Did the user enable exact matching of folder type/names
                                  " think node_modules
  204              0.000686       if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
  204              0.000203       else
                                    " the folder is not open
  204              0.000479         if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
  204              0.000180         else
                                      " We have a regular folder
  204   0.190964   0.015865           let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str(), path.isDirectory) . postPadding
  204              0.000236         endif
  204              0.000150       endif

                                else
                                  " the user did not enable exact matching
                                  if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
                                  else
                                    " the folder is not open
                                    if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
                                    else
                                      " We have a regular folder
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol . artifactFix . postPadding
                                    endif
                                  endif

  204              0.000216     endif

                              else
                                let flag = prePadding . ' ' . artifactFix . postPadding
  491              0.000420   endif

  491   0.017688   0.011669   call path.flagSet.clearFlags('webdevicons')

  491              0.001648   if flag !=? ''
  491   0.034495   0.006761     call path.flagSet.addFlag('webdevicons', flag)
  491              0.000438   endif


FUNCTION  81()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim:35
Called 611 times
Total time:   0.009037
 Self time:   0.009037

count  total (s)   self (s)
  611              0.003900     if !exists('g:NERDTreeBookmarks')
                                    let g:NERDTreeBookmarks = []
  611              0.000560     endif
  611              0.002177     return g:NERDTreeBookmarks

FUNCTION  82()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim:45
Called 1 time
Total time:   0.000075
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000001     try
    1   0.000045   0.000009         call s:Bookmark.BookmarkFor(a:name)
                                    return 1
    1              0.000021     catch /^NERDTree.BookmarkNotFoundError/
    1              0.000002         return 0
    1              0.000001     endtry

FUNCTION  83()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim:57
Called 1 time
Total time:   0.000036
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000003     let l:result = {}
    1   0.000017   0.000008     for l:bookmark in s:Bookmark.Bookmarks()
                                    if l:bookmark.name ==# a:name
                                        let l:result = l:bookmark
                                        break
                                    endif
    1              0.000001     endfor
    1              0.000003     if empty(l:result)
                                    throw 'NERDTree.BookmarkNotFoundError: "' . a:name  . '" not found'
                                endif
                                return l:result

FUNCTION  vital#_easymotion#Over#Commandline#Modules#BufferComplete#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim:5
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000016     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:42
Called 2295 times
Total time:   0.052443
 Self time:   0.043095

count  total (s)   self (s)
 2295   0.037863   0.028515   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 2295              0.001943   endif
 2295              0.004445   return a:text

FUNCTION  coc#util#echo_messages()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:193
Called 2 times
Total time:   0.149740
 Self time:   0.149740

count  total (s)   self (s)
    2              0.000066   if a:hl !~# 'Error' && (mode() !~# '\v^(i|n)$')
                                return
    2              0.000003   endif
    2              0.000029   let msgs = filter(copy(a:msgs), '!empty(v:val)')
    2              0.000005   if empty(msgs)
                                return
    2              0.000001   endif
    2              0.000128   execute 'echohl '.a:hl
    2              0.000121   echom a:msgs[0]
    2              0.149327   redraw
    2              0.000032   echo join(msgs, "\n")
    2              0.000009   echohl None

FUNCTION  <SNR>110_NullError()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:470
Called 2 times
Total time:   0.073665
 Self time:   0.000177

count  total (s)   self (s)
    2   0.073584   0.000096   let [out, exec_error] = s:SystemError(call('fugitive#Prepare', a:000))
    2              0.000075   return [exec_error ? [] : split(out, "\1"), exec_error ? substitute(out, "\n$", "", "") : '', exec_error]

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 10 times
Total time:   0.001223
 Self time:   0.001223

count  total (s)   self (s)
   10              0.000035   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif

                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif

                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END

                                let s:new_log_session = 0
   10              0.000011   endif

FUNCTION  <SNR>13_LoadFTPlugin()
    Defined: /usr/local/Cellar/neovim/HEAD-759a054/share/nvim/runtime/ftplugin.vim:14
Called 5 times
Total time:   0.029542
 Self time:   0.019974

count  total (s)   self (s)
    5              0.000032     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    5              0.000005     endif

    5              0.000105     let s = expand("<amatch>")
    5              0.000017     if s != ""
    5              0.000132       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    5              0.000005       endif

                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   10              0.000099       for name in split(s, '\.')
    5   0.028993   0.019425 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
   10              0.000031       endfor
    5              0.000007     endif

FUNCTION  <SNR>110_FileIgnoreCase()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:120
Called 13 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
   13              0.000121   return (exists('+fileignorecase') && &fileignorecase) || (a:for_completion && exists('+wildignorecase') && &wildignorecase)

FUNCTION  382()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Redraw.vim:29
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004 	let self.is_execute = 0

FUNCTION  387()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:26
Called 15 times
Total time:   0.000167
 Self time:   0.000167

count  total (s)   self (s)
   15              0.000100 	if has_key(self, "value")
   14              0.000025 		return
    1              0.000002 	endif
    1              0.000006 	let self.value = &cmdheight

FUNCTION  <SNR>132_call()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:67
Called 77 times
Total time:   0.200055
 Self time:   0.011635

count  total (s)   self (s)
   77              0.000467 	let args = get(a:, 1, [])
   77              0.000291 	let def = get(a:, 2, 0)
   77   0.199192   0.010772 	return map(copy(a:list), "has_key(v:val, a:func) ? call(v:val.".a:func.", args, v:val) : def")

FUNCTION  nerdtree#echo()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:231
Called 1 time
Total time:   0.056461
 Self time:   0.056461

count  total (s)   self (s)
    1              0.056446     redraw
    1              0.000014     echomsg empty(a:msg) ? '' : ('NERDTree: ' . a:msg)

FUNCTION  <SNR>150_make_special_chars()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/NoInsert.vim:45
Called 1 time
Total time:   0.000038
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000029   0.000012 	let module = s:make([])
    1              0.000002 	function! module.is_no_insert(char)
                            		return char2nr(a:char) == 128 || char2nr(a:char) < 27
                            	endfunction
    1              0.000001 	return module

FUNCTION  <SNR>246_is_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:273
Called 40 times
Total time:   0.000412
 Self time:   0.000412

count  total (s)   self (s)
   40              0.000292   return a:from_count == 0 && a:to_count > 0

FUNCTION  vital#_easymotion#Over#Input#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Input.vim:5
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000016     return map({'getchar': ''},  'function("s:" . v:key)')

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:88
Called 4 times
Total time:   0.001174
 Self time:   0.000084

count  total (s)   self (s)
    4   0.001170   0.000080   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  317()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:231
Called 77 times
Total time:   0.268784
 Self time:   0.002348

count  total (s)   self (s)
   77   0.053675   0.001050 	call self.variables.modules.sort_by("has_key(v:val.slot.module, 'priority') ? v:val.slot.module.priority('" . a:event . "') : 0")
   77   0.214997   0.001187 	return self.variables.modules.call(a:event, [self])
                            " 	call map(filter(copy(self.variables.modules), "has_key(v:val, a:event)"), "v:val." . a:event . "(self)")

FUNCTION  <SNR>127_off_screen_search()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:224
Called 15 times
Total time:   0.003331
 Self time:   0.001622

count  total (s)   self (s)
                                " First: search within visible screen range
   15   0.001479   0.000310     call s:adjust_screen()
                                " Error occur when '\zs' without '!'
   15              0.000390     silent! let pos = searchpos(a:re, s:direction . 'n', s:orig_line_end[1])
   15              0.000069     if pos != [0, 0]
                                    " Restore cursor posision
    5              0.000028         keepjumps call setpos('.', s:orig_pos)
   10              0.000010     else
                                    " Second: if there were no much, search off screen
   10              0.000163         silent! let pos = searchpos(a:re, s:direction)
   10              0.000035         if pos != [0, 0]
                                        " Match
                                        keepjumps call setpos('.', pos)
                                        " Move cursor
                                        if s:save_direction != 'b'
                                            normal! zzH0
                                        else
                                            normal! zzL0
                                        endif
   10              0.000009         else
                                        " No much
   10   0.000692   0.000152             call s:adjust_screen()
   10              0.000044             keepjumps call setpos('.', s:orig_pos)
   10              0.000010         endif
   15              0.000010     endif
                                " redraw

FUNCTION  <SNR>94_format_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:77
Called 8 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    8              0.000017     return a:name

FUNCTION  <SNR>128_plugin_name()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:127
Called 27 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
   27              0.000084   return self._plugin_name

FUNCTION  184()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:15
Called 1 time
Total time:   0.004109
 Self time:   0.000069

count  total (s)   self (s)
    1   0.004051   0.000012     call g:NERDTreeKeyMap.BindAll()

    1              0.000008     command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
    1              0.000009     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark('<args>')
    1              0.000006     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark call nerdtree#ui_glue#openBookmark('<args>')
    1              0.000006     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('<args>')
    1              0.000007     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>', b:NERDTree)
    1              0.000005     command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
    1              0.000005     command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
    1              0.000003     command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
    1              0.000003     command! -buffer -nargs=0 EditBookmarks call g:NERDTreeBookmark.Edit()

FUNCTION  185()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:30
Called 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000032     if exists('#User#NERDTreeInit')
                                    doautocmd User NERDTreeInit
    1              0.000002     endif

FUNCTION  186()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:37
Called 5 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    5              0.000013     return 'NERD_tree_'

FUNCTION  188()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:49
Called 1 time
Total time:   0.199580
 Self time:   0.000098

count  total (s)   self (s)
    1   0.000823   0.000009     let l:path = self._pathForString(a:name)

                                " Abort if an exception was thrown (i.e., if the bookmark or directory
                                " does not exist).
    1              0.000002     if empty(l:path)
                                    return
    1              0.000001     endif

                                " Obey the user's preferences for changing the working directory.
    1              0.000002     if g:NERDTreeChDirMode != 0
                                    call l:path.changeToDir()
    1              0.000001     endif

    1   0.000012   0.000006     if g:NERDTree.ExistsForTab()
                                    call g:NERDTree.Close()
                                    call self._removeTreeBufForTab()
    1              0.000001     endif

    1   0.104345   0.000007     call self._createTreeWin()
    1   0.086409   0.000014     call self._createNERDTree(l:path, 'tab')
    1   0.007347   0.000009     call b:NERDTree.render()
    1   0.000563   0.000012     call b:NERDTree.root.putCursorHere(0, 0)

    1   0.000058   0.000017     call self._broadcastInitEvent()

FUNCTION  <SNR>94_update_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:192
Called 257 times
Total time:   0.145886
 Self time:   0.113063

count  total (s)   self (s)
  257              0.058023   let file = expand("%:p")
  257              0.006288   if empty(file) || isdirectory(file) || !empty(&buftype)
   58              0.000093     return
  199              0.000222   endif

  199              0.000880   let needs_update = 1
  199              0.001977   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  597              0.002486   for vcs in keys(s:vcs_config)
  398              0.005234     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
  398              0.000391     endif
  398              0.002523     if has_key(s:vcs_config[vcs].untracked, file)
  191              0.000506       let needs_update = 0
  191   0.029056   0.021726       call airline#extensions#branch#update_untracked_config(file, vcs)
  398              0.000386     endif
  597              0.001002   endfor

  199              0.000407   if !needs_update
  191              0.000281     return
    8              0.000006   endif

   24              0.000164   for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
   16   0.000723   0.000552     if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                  continue
   16   0.000418   0.000266     elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
    8              0.000014       continue
    8              0.000007     endif
    8              0.000040     let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
    8              0.000076     if index(vcs_checks, 'untracked') > -1
    8   0.010737   0.000491       call airline#async#vcs_untracked(config, file, vcs)
    8              0.000013     endif
                                " Check clean state of repo
    8              0.000084     if index(vcs_checks, 'dirty') > -1
    8   0.015237   0.000313       call airline#async#vcs_clean(config.dirty, file, vcs)
    8              0.000036     endif
   16              0.000087   endfor

FUNCTION  <SNR>154_doautocmd_user()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:35
Called 62 times
Total time:   0.011174
 Self time:   0.008727

count  total (s)   self (s)
   62              0.000293 	let group =  a:prefix . "-vital-over-commandline-doautocmd-dummy"
   62              0.000266 	if !has_key(s:cache_command, a:prefix)
    1              0.000005 		let s:cache_command[a:prefix] = {}
   62              0.000052 	endif

   62              0.000331 	if !has_key(s:cache_command[a:prefix], a:command)
    6              0.000157 		execute "autocmd " . group			. " User " . a:command." silent! execute ''"

    6              0.000032 		if v:version > 703 || v:version == 703 && has("patch438")
    6              0.000049 			let s:cache_command[a:prefix][a:command] = "doautocmd <nomodeline> User " . a:command
                            		else
                            			let s:cache_command[a:prefix][a:command] = "doautocmd User " . a:command
    6              0.000005 		endif
   62              0.000040 	endif

   62   0.008662   0.006216 	execute s:cache_command[a:prefix][a:command]

FUNCTION  393()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:144
Called 1 time
Total time:   0.000052
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000051   0.000016 	call s:cmdheight.restore()

FUNCTION  394()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Delete.vim:24
Called 15 times
Total time:   0.003460
 Self time:   0.001335

count  total (s)   self (s)
   15   0.001044   0.000233 	if a:cmdline.is_input("\<C-h>")	|| a:cmdline.is_input("\<BS>")
    8   0.000086   0.000058 		if a:cmdline.line.length() == 0
    1   0.000015   0.000008 			return a:cmdline.exit(1)
    7              0.000007 		else
    7   0.000693   0.000049 			call a:cmdline.line.remove_prev()
    7   0.000176   0.000053 			call a:cmdline.setchar('')
    7              0.000006 		endif
    7   0.000248   0.000066 	elseif a:cmdline.is_input("\<Del>")
                            		call a:cmdline.line.remove_pos()
                            		call a:cmdline.setchar('')
    7   0.000231   0.000060 	elseif a:cmdline.is_input("\<C-w>")
                            		let word = a:cmdline.backward_word()
                            		let backward = a:cmdline.backward()[ : -strlen(word)-1 ]
                            		call a:cmdline.setline(backward . a:cmdline.line.pos_char() . a:cmdline.forward())
                            		call a:cmdline.setline(strchars(backward))
                            		call a:cmdline.setchar('')
    7   0.000217   0.000060 	elseif a:cmdline.is_input("\<C-u>")
                            		call a:cmdline.setline(a:cmdline.line.pos_char() . a:cmdline.forward())
                            		call a:cmdline.setline(0)
                            		call a:cmdline.setchar('')
   14              0.000012 	endif

FUNCTION  airline#extensions#apply_left_override()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:63
Called 7 times
Total time:   0.002413
 Self time:   0.000255

count  total (s)   self (s)
    7              0.000033   let w:airline_section_a = a:section1
    7              0.000022   let w:airline_section_b = a:section2
    7   0.002308   0.000150   let w:airline_section_c = airline#section#create(['readonly'])
    7              0.000019   let w:airline_render_left = 1
    7              0.000017   let w:airline_render_right = 0

FUNCTION  airline#util#getwinvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:82
Called 415 times
Total time:   0.003721
 Self time:   0.003721

count  total (s)   self (s)
  415              0.003321     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  FugitiveDetect()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:272
Called 3 times
Total time:   0.001610
 Self time:   0.000169

count  total (s)   self (s)
    3              0.000058   if exists('b:git_dir') && b:git_dir =~# '^$\|/$\|^fugitive:'
                                unlet b:git_dir
    3              0.000002   endif
    3              0.000009   if !exists('b:git_dir')
    2   0.001467   0.000026     let dir = FugitiveExtractGitDir(a:path)
    2              0.000004     if dir !=# ''
    2              0.000006       let b:git_dir = dir
    2              0.000002     endif
    3              0.000002   endif
    3              0.000029   if !exists('b:git_dir') || !exists('#User#Fugitive')
    3              0.000004     return ''
                              endif
                              if v:version >= 704 || (v:version == 703 && has('patch442'))
                                doautocmd <nomodeline> User Fugitive
                              elseif &modelines > 0
                                let modelines = &modelines
                                try
                                  set modelines=0
                                  doautocmd User Fugitive
                                finally
                                  let &modelines = modelines
                                endtry
                              else
                                doautocmd User Fugitive
                              endif
                              return ''

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 241 times
Total time:   0.102531
 Self time:   0.072626

count  total (s)   self (s)
  241              0.003199   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  241              0.003888   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
  241              0.000210   endif
  241              0.004858   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')

  241              0.001353   if !exists('b:airline_whitespace_check')
    3              0.000018     let b:airline_whitespace_check = ''
    3              0.000038     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))

    3              0.000009     let trailing = 0
    3              0.000008     let check = 'trailing'
    3              0.000065     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    3              0.000007       try
    3              0.000022         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    3              0.005443         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
    3              0.000007       endtry
    3              0.000004     endif

    3              0.000014     let mixed = 0
    3              0.000009     let check = 'indent'
    3              0.000075     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    3   0.010036   0.000096       let mixed = s:check_mixed_indent()
    3              0.000018     endif

    3              0.000020     let mixed_file = ''
    3              0.000010     let check = 'mixed-indent-file'
    3              0.000079     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    3   0.001646   0.000098       let mixed_file = s:check_mixed_indent_file()
    3              0.000003     endif

    3              0.000008     let long = 0
    3              0.000018     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
    3              0.000003     endif

    3              0.000007     let conflicts = 0
    3              0.000012     if index(checks, 'conflicts') > -1
    3   0.002219   0.000085       let conflicts = s:conflict_marker()
    3              0.000012     endif

    3              0.000034     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif

                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
    3              0.000003     endif
  241              0.000195   endif
  241   0.027388   0.011105   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/po.vim:54
Called 16 times
Total time:   0.000257
 Self time:   0.000257

count  total (s)   self (s)
   16              0.000108   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
   16              0.000014   endif

FUNCTION  <SNR>57_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:214
Called 47 times
Total time:   0.021138
 Self time:   0.002505

count  total (s)   self (s)
   47   0.021080   0.002447   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>246_process_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:293
Called 12 times
Total time:   0.004720
 Self time:   0.004720

count  total (s)   self (s)
   12              0.000045   let offset = 0
  304              0.000745   while offset < a:to_count
  292              0.000946     let line_number = a:to_line + offset
  292              0.001654     call add(a:modifications, [line_number, 'added'])
  292              0.000675     let offset += 1
  304              0.000359   endwhile

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:10
Called 4 times
Total time:   0.000184
 Self time:   0.000083

count  total (s)   self (s)
    4   0.000180   0.000079   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  380()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Cancel.vim:24
Called 15 times
Total time:   0.001065
 Self time:   0.000358

count  total (s)   self (s)
   15   0.000952   0.000245 	if a:cmdline.is_input("\<Esc>")	|| a:cmdline.is_input("\<C-c>")
                            " 		call a:cmdline.cancel()
                            		call a:cmdline.exit(1)
                            		call a:cmdline.setchar("")
   15              0.000012 	endif

FUNCTION  <SNR>110_AddSection()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1704
Called 4 times
Total time:   0.000396
 Self time:   0.000072

count  total (s)   self (s)
    4              0.000011   let note = a:0 ? a:1 : ''
    4              0.000016   if empty(a:lines) && empty(note)
    3              0.000003     return
    1              0.000001   endif
    1   0.000360   0.000036   call append(line('$'), ['', a:label . (len(note) ? ': ' . note : ' (' . len(a:lines) . ')')] + s:Format(a:lines))

FUNCTION  <SNR>14_LoadIndent()
    Defined: /usr/local/Cellar/neovim/HEAD-759a054/share/nvim/runtime/indent.vim:13
Called 5 times
Total time:   0.023604
 Self time:   0.003210

count  total (s)   self (s)
    5              0.000036     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    5              0.000005     endif
    5              0.000036     let s = expand("<amatch>")
    5              0.000016     if s != ""
    5              0.000017       if exists("b:did_indent")
                            	unlet b:did_indent
    5              0.000004       endif

                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   10              0.000067       for name in split(s, '\.')
    5   0.023310   0.002916 	exe 'runtime! indent/' . name . '.vim'
   10              0.000026       endfor
    5              0.000007     endif

FUNCTION  vital#_easymotion#Over#Commandline#Modules#Exit#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Exit.vim:5
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>26_validate_layout()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:325
Called 2 times
Total time:   0.000745
 Self time:   0.000745

count  total (s)   self (s)
    4              0.000296   for key in keys(a:layout)
    2              0.000071     if index(s:layout_keys, key) < 0
                                  throw printf('Invalid entry in g:fzf_layout: %s (allowed: %s)%s', key, join(s:layout_keys, ', '), key == 'options' ? '. Use $FZF_DEFAULT_OPTS.' : '')
    2              0.000023     endif
    4              0.000051   endfor
    2              0.000018   return a:layout

FUNCTION  <SNR>91_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:54
Called 3049 times
Total time:   0.034686
 Self time:   0.034686

count  total (s)   self (s)
 3049              0.031895   return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  <SNR>134_as_key_config()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Keymapping.vim:35
Called 5 times
Total time:   0.000304
 Self time:   0.000304

count  total (s)   self (s)
    5              0.000178 	let base = {		"noremap" : 0,		"lock"    : 0,		"expr"    : 0,	}
    5              0.000114 	return type(a:config) == type({}) ? extend(base, a:config)		 : extend(base, {		 	"key" : a:config,		 })

FUNCTION  385()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Redraw.vim:41
Called 1 time
Total time:   0.001778
 Self time:   0.000032

count  total (s)   self (s)
    1   0.000018   0.000014 	if self.is_execute == 0 && a:cmdline.exit_code() != -1
    1   0.001757   0.000016 		call self.redraw(a:cmdline)
    1              0.000001 	endif

FUNCTION  <SNR>26_split()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:722
Called 2 times
Total time:   0.066108
 Self time:   0.000362

count  total (s)   self (s)
    2              0.000044   let directions = { 'up':    ['topleft', 'resize', &lines], 'down':  ['botright', 'resize', &lines], 'left':  ['vertical topleft', 'vertical resize', &columns], 'right': ['vertical botright', 'vertical resize', &columns] }
    2   0.000163   0.000051   let ppos = s:getpos()
    2              0.000009   let is_popup = 0
    2              0.000005   try
    2   0.000087   0.000047     if s:present(a:dict, 'window')
    2              0.000015       if type(a:dict.window) == type({})
    2   0.000057   0.000027         if !s:popup_support()
                                      throw 'Nvim 0.4+ or Vim 8.2.191+ with popupwin feature is required for pop-up window'
    2              0.000003         end
    2   0.065599   0.000033         call s:popup(a:dict.window)
    2              0.000005         let is_popup = 1
                                  else
                                    execute 'keepalt' a:dict.window
    2              0.000002       endif
                                elseif !s:splittable(a:dict)
                                  execute (tabpagenr()-1).'tabnew'
                                else
                                  for [dir, triple] in items(directions)
                                    let val = get(a:dict, dir, '')
                                    if !empty(val)
                                      let [cmd, resz, max] = triple
                                      if (dir == 'up' || dir == 'down') && val[0] == '~'
                                        let sz = s:calc_size(max, val, a:dict)
                                      else
                                        let sz = s:calc_size(max, val, {})
                                      endif
                                      execute cmd sz.'new'
                                      execute resz sz
                                      return [ppos, {}, is_popup]
                                    endif
                                  endfor
    2              0.000001     endif
    2              0.000011     return [ppos, is_popup ? {} : { '&l:wfw': &l:wfw, '&l:wfh': &l:wfh }, is_popup]
    2              0.000003   finally
    2              0.000003     if !is_popup
                                  setlocal winfixwidth winfixheight
    2              0.000001     endif
    2              0.000002   endtry

FUNCTION  191()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:110
Called 1 time
Total time:   0.086395
 Self time:   0.000032

count  total (s)   self (s)
    1   0.000195   0.000015     let b:NERDTree = g:NERDTree.New(a:path, a:type)

                                " TODO: This assignment is kept for compatibility reasons.  Many other
                                " plugins use b:NERDTreeRoot instead of b:NERDTree.root.  Remove this
                                " assignment in the future.
    1              0.000003     let b:NERDTreeRoot = b:NERDTree.root

    1   0.086193   0.000009     call b:NERDTree.root.open()

FUNCTION  194()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:184
Called 1 time
Total time:   0.104338
 Self time:   0.005701

count  total (s)   self (s)
    1              0.000005     let l:splitLocation = g:NERDTreeWinPos ==# 'left' ? 'topleft ' : 'botright '
    1              0.000003     let l:splitSize = g:NERDTreeWinSize

    1   0.000011   0.000006     if !g:NERDTree.ExistsForTab()
    1   0.000041   0.000008         let t:NERDTreeBufName = self._nextBufferName()
    1   0.055639   0.000540         silent! execute l:splitLocation . 'vertical ' . l:splitSize . ' new'
    1   0.018905   0.005049         silent! execute 'edit ' . t:NERDTreeBufName
    1              0.000023         silent! execute 'vertical resize '. l:splitSize
                                else
                                    silent! execute l:splitLocation . 'vertical ' . l:splitSize . ' split'
                                    silent! execute 'buffer ' . t:NERDTreeBufName
    1              0.000001     endif

    1   0.000017   0.000015     setlocal winfixwidth

    1   0.029655   0.000012     call self._setCommonBufOptions()

    1              0.000007     if has('patch-7.4.1925')
    1              0.000017         clearjumps
    1              0.000001     endif


FUNCTION  196()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:218
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000020     let newCreator = copy(self)
    1              0.000002     return newCreator

FUNCTION  197()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:225
Called 1 time
Total time:   0.000033
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000031   0.000013     let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
    1              0.000001     return name

FUNCTION  198()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:232
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000004     if !exists('s:Creator._NextBufNum')
    1              0.000006         let s:Creator._NextBufNum = 1
                                else
                                    let s:Creator._NextBufNum += 1
    1              0.000001     endif

    1              0.000002     return s:Creator._NextBufNum

FUNCTION  199()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:244
Called 1 time
Total time:   0.000813
 Self time:   0.000161

count  total (s)   self (s)
    1              0.000003     let path = {}
    1   0.000084   0.000010     if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
                                    let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
    1              0.000001     else
    1              0.000080         let dir = a:str ==# '' ? getcwd() : a:str

                                    "hack to get an absolute path if a relative path is given
    1              0.000007         if dir =~# '^\.'
                                        let dir = getcwd() . nerdtree#slash() . dir
    1              0.000001         endif

                                    "hack to prevent removing slash if dir is the root of the file system.
    1              0.000002         if dir !=# '/'
    1   0.000066   0.000017             let dir = g:NERDTreePath.Resolve(dir)
    1              0.000001         endif

    1              0.000001         try
    1   0.000539   0.000010             let path = g:NERDTreePath.New(dir)
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo('No bookmark or directory found for: ' . a:str)
                                        return {}
    1              0.000001         endtry
    1              0.000001     endif
    1              0.000001     if !path.isDirectory
                                    let path = path.getParent()
    1              0.000001     endif

    1              0.000001     return path

FUNCTION  388()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:33
Called 1 time
Total time:   0.000035
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000007 	if has_key(self, "value")
    1   0.000021   0.000016 		let &cmdheight = self.value
    1              0.000004 		unlet self.value
    1              0.000001 	endif

FUNCTION  <SNR>123_get_color()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:231
Called 2 times
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
    2              0.000017   let gui = has('termguicolors') && &termguicolors
    2              0.000006   let fam = gui ? 'gui' : 'cterm'
    2              0.000005   let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
    3              0.000010   for group in a:000
    2              0.000070     let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
    2              0.000026     if code =~? pat
    1              0.000003       return code
    1              0.000001     endif
    2              0.000003   endfor
    1              0.000002   return ''

FUNCTION  284()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:8
Called 38 times
Total time:   0.000430
 Self time:   0.000430

count  total (s)   self (s)
   38              0.000384   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  <SNR>26_getpos()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:692
Called 7 times
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
    7              0.000178   return {'tab': tabpagenr(), 'win': winnr(), 'winid': win_getid(), 'cnt': winnr('$'), 'tcnt': tabpagenr('$')}

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:76
Called 241 times
Total time:   0.077835
 Self time:   0.020200

count  total (s)   self (s)
  241              0.002696   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    1              0.000004     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
    1              0.000004     elseif exists('*GitGutterGetHunkSummary')
    1              0.000003       let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
                                else
                                  let b:source_func = 's:get_hunks_empty'
    1              0.000001     endif
  241              0.000180   endif
  241   0.067079   0.009445   return {b:source_func}()

FUNCTION  <SNR>103_section_is_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:182
Called 227 times
Total time:   0.006204
 Self time:   0.006204

count  total (s)   self (s)
  227              0.002580   let start=1

                              " do not check for inactive windows or the tabline
  227              0.000703   if a:self._context.active == 0
   98              0.000139     return 0
  129              0.000645   elseif get(a:self._context, 'tabline', 0)
                                return 0
  129              0.000093   endif

                              " only check, if airline#skip_empty_sections == 1
  129              0.000621   if get(g:, 'airline_skip_empty_sections', 0) == 0
  129              0.000166     return 0
                              endif

                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>21_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:313
Called 329 times
Total time:   0.004736
 Self time:   0.004736

count  total (s)   self (s)
  329              0.001976   if exists('+shellslash')
                                return tr(a:path, '\', '/')
  329              0.000508   else
  329              0.000758     return a:path
                              endif

FUNCTION  airline#async#nvim_vcs_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:336
Called 8 times
Total time:   0.007222
 Self time:   0.006981

count  total (s)   self (s)
    8              0.000106   let cmd = a:cfg.cmd . shellescape(a:file)
    8              0.000021   let id = -1
    8   0.000778   0.000536   let config = { 'buf': '', 'vcs': a:vcs, 'cfg': a:cfg, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')) }
    8              0.000044   if has("nvim")
    8              0.000235     call extend(config, { 'on_stdout': function('s:nvim_output_handler'), 'on_exit': function('s:nvim_untracked_job_handler')})
    8              0.000055     if has_key(s:untracked_jobs, config.file)
                                  " still running
    5              0.000009       return
    3              0.000002     endif
    3              0.000003     try
    3              0.005570     let id = jobstart(cmd, config)
                                catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
    3              0.000007     endtry
    3              0.000045     let s:untracked_jobs[a:file] = id
    3              0.000008   endif
                              " vim without job feature or nvim jobstart failed
    3              0.000007   if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
    3              0.000003   endif

FUNCTION  <SNR>110_SystemError()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:431
Called 3 times
Total time:   0.101331
 Self time:   0.000475

count  total (s)   self (s)
    3              0.000004   try
    3              0.000010     if &shellredir ==# '>' && &shell =~# 'sh\|cmd'
                                  let shellredir = &shellredir
                                  if &shell =~# 'csh'
                                    set shellredir=>&
                                  else
                                    set shellredir=>%s\ 2>&1
                                  endif
    3              0.000002     endif
    3   0.101032   0.000176     let out = call('system', [type(a:cmd) ==# type([]) ? fugitive#Prepare(a:cmd) : a:cmd] + a:000)
    3              0.000094     return [out, v:shell_error]
                              catch /^Vim\%((\a\+)\)\=:E484:/
                                let opts = ['shell', 'shellcmdflag', 'shellredir', 'shellquote', 'shellxquote', 'shellxescape', 'shellslash']
                                call filter(opts, 'exists("+".v:val) && !empty(eval("&".v:val))')
                                call map(opts, 'v:val."=".eval("&".v:val)')
                                call s:throw('failed to run `' . a:cmd . '` with ' . join(opts, ' '))
    3              0.000007   finally
    3              0.000016     if exists('shellredir')
                                  let &shellredir = shellredir
    3              0.000003     endif
    3              0.000010   endtry

FUNCTION  415()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/NoInsert.vim:31
Called 15 times
Total time:   0.000786
 Self time:   0.000495

count  total (s)   self (s)
   15   0.000532   0.000370 	if self.is_no_insert(a:cmdline.char())
    8   0.000194   0.000065 		call a:cmdline.setchar("", 0)
   15              0.000015 	endif

FUNCTION  <SNR>26_evaluate_opts()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:335
Called 4 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    4              0.000071   return type(a:options) == type([]) ? join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options

FUNCTION  <SNR>91_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:38
Called 12196 times
Total time:   0.524996
 Self time:   0.524996

count  total (s)   self (s)
12196              0.030292   let color = ''
12196              0.088356   if hlexists(a:group)
11812              0.132021     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
12196              0.013119   endif
12196              0.047097   if empty(color) || color == -1
                                " should always exist
  384              0.012854     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                " however, just in case
  384              0.001685     if empty(color) || color == -1
                                  let color = 'NONE'
  384              0.000303     endif
12196              0.007503   endif
12196              0.021196   return color

FUNCTION  <SNR>136_capture()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:39
Called 1 time
Total time:   0.000083
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000021 	if hlexists(a:name) == 0
                            		return ""
    1              0.000001 	endif
    1   0.000059   0.000014 	return s:Message.capture("highlight " . a:name)

FUNCTION  airline#highlighter#add_accent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:219
Called 7 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    7              0.000051   let s:accents[a:accent] = 1

FUNCTION  <SNR>110_TempReadPost()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:2256
Called 2 times
Total time:   0.000189
 Self time:   0.000080

count  total (s)   self (s)
    2   0.000138   0.000029   if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nobuflisted
                                if has_key(dict, 'filetype') && dict.filetype !=# &l:filetype
                                  let &l:filetype = dict.filetype
                                endif
                                setlocal foldmarker=<<<<<<<,>>>>>>>
                                if empty(mapcheck('q', 'n'))
                                  nnoremap <buffer> <silent> q    :<C-U>bdelete<Bar>echohl WarningMsg<Bar>echo "Temp file q is deprecated in favor of the built-in <Lt>C-W>q"<Bar>echohl NONE<CR>
                                endif
                                if !&modifiable
                                  call s:Map('n', 'gq', ":<C-U>bdelete<CR>", '<silent> <unique>')
                                endif
    2              0.000001   endif
    2              0.000002   return ''

FUNCTION  <SNR>130__clamp()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:34
Called 22 times
Total time:   0.000193
 Self time:   0.000193

count  total (s)   self (s)
   22              0.000177 	return min([max([a:x, a:max]), a:min])

FUNCTION  <SNR>131__compare()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Data/List.vim:113
Called 2695 times
Total time:   0.015710
 Self time:   0.015710

count  total (s)   self (s)
 2695              0.014424   return eval(s:expr)

FUNCTION  <SNR>20_request()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:148
Called 4 times
Total time:   0.643383
 Self time:   0.493211

count  total (s)   self (s)
    4   0.000119   0.000087   let channel = coc#client#get_channel(self)
    4              0.000021   if empty(channel) | return '' | endif
    4              0.000005   try
    4              0.000005     if s:is_vim
                                  let res = ch_evalexpr(channel, [a:method, a:args], {'timeout': 60 * 1000})
                                  if type(res) == 1 && res ==# ''
                                    throw 'request '.a:method. ' '.string(a:args).' timeout after 60s'
                                  endif
                                  let [l:errmsg, res] =  res
                                  if !empty(l:errmsg)
                                    throw l:errmsg
                                  else
                                    return res
                                  endif
    4              0.000003     else
    4   0.642945   0.492804       return call('rpcrequest', [channel, a:method] + a:args)
                                endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0) | return | endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on request ('.a:method.'): '.v:exception | echohl None
                                endif
    4              0.000008   endtry

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:156
Called 18 times
Total time:   0.188677
 Self time:   0.003255

count  total (s)   self (s)
   18   0.004494   0.000294   if airline#util#stl_disabled(winnr())
                                return
   18              0.000020   endif
   40              0.000132   for nr in a:range
   22   0.002254   0.000415     if airline#util#stl_disabled(nr)
                                  continue
   22              0.000020     endif
   22              0.000178     call setwinvar(nr, 'airline_active', 0)
   22              0.000205     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
   22              0.000106     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
   22              0.000021     endif
   22   0.180229   0.000845     call s:invoke_funcrefs(context, s:inactive_funcrefs)
   40              0.000109   endfor

FUNCTION  nerdtree#runningWindows()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:214
Called 1844 times
Total time:   0.028737
 Self time:   0.028737

count  total (s)   self (s)
 1844              0.026528     return has('win16') || has('win32') || has('win64')

FUNCTION  365()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:96
Called 7 times
Total time:   0.000576
 Self time:   0.000223

count  total (s)   self (s)
    7   0.000081   0.000058 	if a:index < 0 || self.length() <= a:index
                            		return ""
    7              0.000006 	endif
    7              0.000025 	let result = self.list[a:index]
    7              0.000023 	unlet self.list[a:index]
    7              0.000014 	if a:index < self.col
    7   0.000378   0.000050 		call self.set(self.col - 1)
    7              0.000007 	endif
    7              0.000012 	return result

FUNCTION  vital#_easymotion#Over#Commandline#Modules#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules.vim:5
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000030     return map({'get': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  422()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:89
Called 15 times
Total time:   0.003092
 Self time:   0.000348

count  total (s)   self (s)
   15              0.000057 	let s:cmdline = a:cmdline
   15   0.003020   0.000276 	call s:doautocmd_user(self.prefix, self.prefix . 'Char')

FUNCTION  coc#float#nvim_win_enter()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:1127
Called 9 times
Total time:   0.000259
 Self time:   0.000259

count  total (s)   self (s)
    9              0.000105   let kind = getwinvar(a:winid, 'kind', '')
    9              0.000050   if kind == 'buttons' || kind == 'close'
                                if empty(maparg('<LeftRelease>', 'n'))
                                  nnoremap <buffer><silent> <LeftRelease> :call coc#float#nvim_float_click()<CR>
                                endif
    9              0.000008   endif

FUNCTION  423()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:89
Called 15 times
Total time:   0.004077
 Self time:   0.000334

count  total (s)   self (s)
   15              0.000056 	let s:cmdline = a:cmdline
   15   0.004003   0.000260 	call s:doautocmd_user(self.prefix, self.prefix . 'CharPre')

FUNCTION  gitgutter#all()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:3
Called 5 times
Total time:   0.016459
 Self time:   0.002920

count  total (s)   self (s)
    5              0.000115   let visible = tabpagebuflist()

   24              0.000198   for bufnr in range(1, bufnr('$') + 1)
   19              0.000264     if buflisted(bufnr)
    5              0.001200       let file = expand('#'.bufnr.':p')
    5              0.000043       if !empty(file)
    1              0.000008         if index(visible, bufnr) != -1
    1   0.013643   0.000105           call gitgutter#process_buffer(bufnr, a:force)
                                    elseif a:force
                                      call s:reset_tick(bufnr)
    1              0.000004         endif
    5              0.000006       endif
   19              0.000062     endif
   24              0.000077   endfor

FUNCTION  <SNR>110_BuildEnvPrefix()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:379
Called 3 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    3              0.000012   let pre = ''
    3              0.000018   let env = items(a:env)
    3              0.000010   if empty(env)
    3              0.000005     return ''
                              elseif &shellcmdflag =~# '-Command'
                                return join(map(env, '"$Env:" . v:val[0] . " = ''" . substitute(v:val[1], "''", "''''", "g") . "''; "'), '')
                              elseif s:winshell()
                                return join(map(env, '"set " . substitute(join(v:val, "="), "[&|<>^]", "^^^&", "g") . "& "'), '')
                              else
                                return 'env ' . s:shellesc(map(env, 'join(v:val, "=")')) . ' '
                              endif

FUNCTION  airline#extensions#term#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:26
Called 22 times
Total time:   0.000777
 Self time:   0.000777

count  total (s)   self (s)
   22              0.000198   if getbufvar(a:2.bufnr, '&buftype') ==? 'terminal'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
   22              0.000017   endif

FUNCTION  airline#async#vcs_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:95
Called 8 times
Total time:   0.014925
 Self time:   0.000709

count  total (s)   self (s)
    8              0.000033   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
    8              0.000048   elseif has("nvim")
                                " nvim async
    8   0.014614   0.000398     noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                              else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
    8              0.000009   endif

FUNCTION  <SNR>245_on_exit_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:87
Called 3 times
Total time:   0.000462
 Self time:   0.000139

count  total (s)   self (s)
    3              0.000030   let buf=self.buf
    3   0.000379   0.000057   call s:set_clean_variables(self.file, self.vcs, !empty(buf))
    3              0.000022   if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
    3              0.000018     call remove(s:clean_jobs[self.vcs], self.file)
    3              0.000002   endif

FUNCTION  <SNR>243_on_stderr_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:66
Called 5 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    5              0.000030   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
    5              0.000005   endif

FUNCTION  <SNR>94_update_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:173
Called 257 times
Total time:   0.555136
 Self time:   0.048084

count  total (s)   self (s)
  771              0.004329   for vcs in keys(s:vcs_config)
  514   0.537388   0.030336     call {s:vcs_config[vcs].update_branch}()
  514              0.004066     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
    2              0.000010       let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
    2              0.000004       unlet! b:airline_head
  514              0.000482     endif
  771              0.001389   endfor

FUNCTION  <SNR>136_parse_to_name()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:52
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000011 	return matchstr(a:highlight, '^\zs\w\+\ze')

FUNCTION  FugitiveHead()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:128
Called 257 times
Total time:   0.376724
 Self time:   0.021508

count  total (s)   self (s)
  257   0.049717   0.009136   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
  257              0.000912   if empty(dir)
                                return ''
  257              0.000205   endif
  257   0.324981   0.010346   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  <SNR>145_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/BufferComplete.vim:174
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000008 	return deepcopy(s:module)

FUNCTION  <SNR>110_Format()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1680
Called 13 times
Total time:   0.000571
 Self time:   0.000470

count  total (s)   self (s)
   13              0.000048   if type(a:val) == type({})
   12   0.000195   0.000139     return s:Format{a:val.type}(a:val)
    1              0.000004   elseif type(a:val) == type([])
    1              0.000019     return map(copy(a:val), 's:Format(v:val)')
                              else
                                return '' . a:val
                              endif

FUNCTION  <SNR>127_Cancell()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:198
Called 1 time
Total time:   0.000242
 Self time:   0.000098

count  total (s)   self (s)
    1   0.000136   0.000038     call EasyMotion#highlight#delete_highlight()
    1   0.000058   0.000013     call EasyMotion#helper#VarReset('&scrolloff')
    1              0.000005     keepjumps call setpos('.', s:save_orig_pos)
    1              0.000002     if g:EasyMotion_verbose
    1              0.000033         echo 'EasyMotion: Cancelled'
    1              0.000002     endif
    1              0.000002     return ''

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:237
Called 35 times
Total time:   1.434690
 Self time:   0.201629

count  total (s)   self (s)
   35              0.000171   let bufnr = a:0 ? a:1 : ''
   35              0.000256   let p = g:airline#themes#{g:airline_theme}#palette

                              " draw the base mode, followed by any overrides
   35              0.000512   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   35              0.000166   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   35              0.000106   let airline_grouplist = []
   35              0.000337   let buffers_in_tabpage = sort(tabpagebuflist())
   35              0.000148   if exists("*uniq")
   35              0.000251     let buffers_in_tabpage = uniq(buffers_in_tabpage)
   35              0.000035   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   75              0.000313   for mode in reverse(mapped)
   40              0.000442     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   35              0.000244       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  764              0.002793       for kvp in items(dict)
  729              0.002312         let mode_colors = kvp[1]
  729              0.001846         let name = kvp[0]
  729              0.003313         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    6              0.000024           let name = 'airline_c'.bufnr
  729              0.000597         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  729              0.009860         if name =~# 'airline_c\d\+'
   49              0.001112           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
   49              0.000333           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
   49              0.000039           endif
  680              0.006927         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
  255              0.000348           continue
  474              0.000380         endif
  474   0.017529   0.009150         if s:group_not_done(airline_grouplist, name.suffix)
  418   0.268164   0.008475           call airline#highlighter#exec(name.suffix, mode_colors)
  474              0.000514         endif

  474              0.001997         if !has_key(p, 'accents')
                                      " work around a broken installation
                                      " shouldn't actually happen, p should always contain accents
                                      continue
  474              0.000385         endif

 1422              0.005545         for accent in keys(s:accents)
  948              0.004302           if !has_key(p.accents, accent)
                                        continue
  948              0.000789           endif
  948              0.006981           let colors = copy(mode_colors)
  948              0.004486           if p.accents[accent][0] != ''
  474              0.002206             let colors[0] = p.accents[accent][0]
  948              0.000843           endif
  948              0.003236           if p.accents[accent][2] != ''
  474              0.001838             let colors[2] = p.accents[accent][2]
  948              0.000738           endif
  948              0.002828           if len(colors) >= 5
  948              0.005766             let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
  948              0.000691           endif
  948   0.034691   0.020900           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  946   0.543778   0.023049             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  948              0.000967           endif
 1422              0.001516         endfor
  509              0.000449       endfor

   35              0.000103       if empty(s:separators)
                                    " nothing to be done
                                    continue
   35              0.000024       endif
                                  " TODO: optimize this
  352              0.001377       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
  317   0.438267   0.007793         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  352              0.000476       endfor
   40              0.000033     endif
   75              0.000896   endfor

FUNCTION  coc#rpc#ready()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:31
Called 194 times
Total time:   0.006114
 Self time:   0.006114

count  total (s)   self (s)
  194              0.004557   if empty(s:client) || s:client['running'] == 0
                                return 0
  194              0.000236   endif
  194              0.000403   return 1

FUNCTION  TrimWhitespace()
    Defined: ~/.config/nvim/init.vim:184
Called 2 times
Total time:   0.001653
 Self time:   0.001653

count  total (s)   self (s)
    2              0.000031     let l:save = winsaveview()
    2              0.001579     keeppatterns %s/\s\+$//e
    2              0.000034     call winrestview(l:save)

FUNCTION  331()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:322
Called 1 time
Total time:   0.000080
 Self time:   0.000077

count  total (s)   self (s)
    1              0.000005 	if exists("self.variables.old_t_ve")
                            		return
    1              0.000001 	endif

    1              0.000004 	let self.variables.old_guicursor = &guicursor
    1   0.000057   0.000054 	set guicursor=n:block-NONE
    1              0.000004 	let self.variables.old_t_ve = &t_ve
    1              0.000004 	set t_ve=

FUNCTION  <SNR>123_check_requirements()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:63
Called 2 times
Total time:   0.066374
 Self time:   0.000200

count  total (s)   self (s)
    2              0.000004   if s:checked
    1              0.000001     return
    1              0.000001   endif

    1              0.000004   if !exists('*fzf#run')
                                throw "fzf#run function not found. You also need Vim plugin from the main fzf repository (i.e. junegunn/fzf *and* junegunn/fzf.vim)"
    1              0.000001   endif
    1              0.000003   if !exists('*fzf#exec')
                                throw "fzf#exec function not found. You need to upgrade Vim plugin from the main fzf repository ('junegunn/fzf')"
    1              0.000001   endif
    1   0.000150   0.000015   let exec = fzf#exec()
    1   0.066032   0.000063   let output = split(system(exec . ' --version'), "\n")
    1              0.000011   if v:shell_error || empty(output)
                                throw 'Failed to run "fzf --version": ' . string(output)
    1              0.000001   endif
    1              0.000031   let fzf_version = matchstr(output[-1], '[0-9.]\+')

    1   0.000106   0.000036   if s:version_requirement(fzf_version, s:min_version)
    1              0.000004     let s:checked = 1
    1              0.000001     return
                              end
                              throw printf('You need to upgrade fzf. Found: %s (%s). Required: %s or above.', fzf_version, exec, s:min_version)

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:108
Called 18 times
Total time:   0.001044
 Self time:   0.001044

count  total (s)   self (s)
   18              0.000256   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   18              0.000097   let bomb     = &l:bomb ? '[BOM]' : ''
   18              0.000302   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   18              0.000139   if expected is# &fenc.bomb.ff
                                return ''
   18              0.000062   else
   18              0.000101     return &fenc.bomb.ff
                              endif

FUNCTION  vital#_easymotion#Over#Signals#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:5
Called 1 time
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000055     return map({'_vital_depends': '', 'call': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>131_sort()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Data/List.vim:105
Called 77 times
Total time:   0.039348
 Self time:   0.023638

count  total (s)   self (s)
   77              0.000707   if type(a:expr) == type(function('function'))
                                return sort(a:list, a:expr)
   77              0.000082   endif
   77              0.000221   let s:expr = a:expr
   77   0.037935   0.022226   return sort(a:list, 's:_compare')

FUNCTION  377()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:98
Called 92 times
Total time:   0.014131
 Self time:   0.010272

count  total (s)   self (s)
   92   0.014067   0.010208 	return map(copy(self.variables.slots), "self.get_slot(v:val)")

FUNCTION  <SNR>57_use_known_shell()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:177
Called 1 time
Total time:   0.000070
 Self time:   0.000062

count  total (s)   self (s)
    1              0.000007   if has('unix') && &shell !=# 'sh'
    1              0.000015     let [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote] = [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote]
    1   0.000015   0.000013     let &shell = 'sh'
    1   0.000016   0.000010     set shellcmdflag=-c shellredir=>%s\ 2>&1
    1              0.000001   endif
    1              0.000006   if has('win32') && (&shell ==# 'pwsh' || &shell ==# 'powershell')
                                let [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote] = [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote]
                                let &shell = 'cmd.exe'
                                set shellcmdflag=/s\ /c shellredir=>%s\ 2>&1 shellpipe=>%s\ 2>&1 shellquote= shellxquote="
    1              0.000001   endif

FUNCTION  332()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:334
Called 1 time
Total time:   0.298871
 Self time:   0.000017

count  total (s)   self (s)
    1   0.298868   0.000014 	let exit_code = call(self.__main, a:000, self)
    1              0.000002 	return exit_code

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:73
Called 56 times
Total time:   0.006342
 Self time:   0.006270

count  total (s)   self (s)
   56              0.005388   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   52              0.000240     return a:arg
    4   0.000184   0.000113   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
    4              0.000005   else
    4              0.000023     return shellescape(a:arg)
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:136
Called 249 times
Total time:   0.034695
 Self time:   0.034695

count  total (s)   self (s)
  249              0.004552   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
  249              0.029610   return match(a:name, pat) > -1

FUNCTION  <SNR>26_border_opt()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:696
Called 2 times
Total time:   0.009918
 Self time:   0.000237

count  total (s)   self (s)
    2              0.000027   if type(a:window) != type({})
                                return ''
    2              0.000003   endif

                              " Border style
    2              0.000024   let style = tolower(get(a:window, 'border', 'rounded'))
    2              0.000017   if !has_key(a:window, 'border') && !get(a:window, 'rounded', 1)
                                let style = 'sharp'
    2              0.000002   endif
    2              0.000009   if style == 'none' || style == 'no'
                                return ''
    2              0.000002   endif

                              " For --border styles, we need fzf 0.24.0 or above
    2   0.009739   0.000058   call fzf#exec('0.24.0')
    2              0.000012   let opt = ' --border=' . style
    2              0.000015   if has_key(a:window, 'highlight')
                                let color = s:get_color('fg', a:window.highlight)
                                if len(color)
                                  let opt .= ' --color=border:' . color
                                endif
    2              0.000002   endif
    2              0.000005   return opt

FUNCTION  <SNR>123_get_git_root()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:605
Called 2 times
Total time:   0.035740
 Self time:   0.000183

count  total (s)   self (s)
    2   0.035710   0.000153   let root = split(system('git rev-parse --show-toplevel'), '\n')[0]
    2              0.000021   return v:shell_error ? '' : root

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 5 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    5              0.000016   return s:available

FUNCTION  <SNR>57_abs_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:205
Called 112 times
Total time:   0.042568
 Self time:   0.042568

count  total (s)   self (s)
  112              0.033904   let p = resolve(expand('#'.a:bufnr.':p'))

                              " Remove extra parts from fugitive's filepaths
  112              0.006966   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')

  112              0.000905   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:216
Called 40 times
Total time:   0.004723
 Self time:   0.004723

count  total (s)   self (s)
   40              0.002832   let matches = matchlist(a:line, s:hunk_re)
   40              0.000449   if len(matches) > 0
   40              0.000249     let from_line  = str2nr(matches[1])
   40              0.000287     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   40              0.000258     let to_line    = str2nr(matches[3])
   40              0.000285     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   40              0.000230     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>132__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:21
Called 1 time
Total time:   0.000298
 Self time:   0.000060

count  total (s)   self (s)
    1              0.000004 	let s:V = a:V
    1   0.000292   0.000054 	let s:L = s:V.import("Data.List")

FUNCTION  <SNR>57_restore_shell()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:190
Called 1 time
Total time:   0.000334
 Self time:   0.000277

count  total (s)   self (s)
    1              0.000056   if (has('unix') || has('win32')) && exists('s:shell')
    1   0.000250   0.000192     let [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote] = [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote]
    1              0.000007   endif

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:491
Called 740 times
Total time:   0.388139
 Self time:   0.371555

count  total (s)   self (s)
  740              0.002964   if a:0 == 0
  249              0.002101     let fileNodeExtension = expand('%:e')
  249              0.001621     let fileNode = expand('%:t')
  249              0.000581     let isDirectory = 0
  491              0.000491   else
  491              0.011015     let fileNodeExtension = fnamemodify(a:1, ':e')
  491              0.002822     let fileNode = fnamemodify(a:1, ':t')
  491              0.001018     if a:0 > 1
  204              0.000603       let isDirectory = a:2
  287              0.000274     else
  287              0.000684       let isDirectory = 0
  491              0.000438     endif
  740              0.000562   endif

  740              0.004145   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching

  740              0.003678     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
  740              0.004616     let fileNodeExtension = tolower(fileNodeExtension)
  740              0.003838     let fileNode = tolower(fileNode)

 7400              0.044304     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
 6660              0.133158       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
 6660              0.005854       endif
 7400              0.013100     endfor

  740              0.004632     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
  740              0.006392       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
  123              0.000947         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
  617              0.006617       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
  322              0.003594         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
  295              0.000570       elseif isDirectory == 1
  163              0.000858         let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
  740              0.000648       endif
  740              0.000590     endif

                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
  740              0.000657   endif

  740   0.052474   0.035890   let artifactFix = s:DevIconsGetArtifactFix()

  740              0.002785   return symbol . artifactFix


FUNCTION  324()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:271
Called 15 times
Total time:   0.169419
 Self time:   0.000440

count  total (s)   self (s)
   15   0.152039   0.000195 	call self.callevent("on_draw_pre")
   15   0.017361   0.000227 	call self.callevent("on_draw")

FUNCTION  airline#util#ignore_next_focusgain()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:195
Called 265 times
Total time:   0.005706
 Self time:   0.005706

count  total (s)   self (s)
  265              0.003234   if has('win32')
                                " Setup an ignore for platforms that trigger FocusLost on calls to
                                " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                let s:focusgained_ignore_time = localtime()
  265              0.000313   endif

FUNCTION  <SNR>110_cpath()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:125
Called 13 times
Total time:   0.000983
 Self time:   0.000597

count  total (s)   self (s)
   13   0.000385   0.000236   if s:FileIgnoreCase(0)
                                let path = FugitiveVimPath(tolower(a:path))
   13              0.000018   else
   13   0.000326   0.000164     let path = FugitiveVimPath(a:path)
   13              0.000012   endif
   13              0.000069   return a:0 ? path ==# s:cpath(a:1) : path

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 5 times
Total time:   0.028816
 Self time:   0.026939

count  total (s)   self (s)
    5   0.002219   0.000406   call gitgutter#debug#log('[async] '.a:cmd)

    5              0.000051   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    5   0.000205   0.000141   let command = s:build_command(a:cmd)

    5              0.000024   if has('nvim')
    5              0.025992     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
    5              0.000015   endif

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:49
Called 505 times
Total time:   0.004854
 Self time:   0.004854

count  total (s)   self (s)
  505              0.004257   return get(s:parts, a:key, {})

FUNCTION  <SNR>136_links_to()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:47
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000020 	return matchstr(a:highlight, '^\S\+\s\+xxx links to \zs.*\ze$')

FUNCTION  <SNR>94_update_hg_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:138
Called 257 times
Total time:   0.038881
 Self time:   0.034234

count  total (s)   self (s)
  257   0.014060   0.009413   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
  257              0.000249   else
  257              0.001313     let s:vcs_config['mercurial'].branch = ''
  257              0.000241   endif

FUNCTION  <SNR>128_new()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:37
Called 11 times
Total time:   0.000226
 Self time:   0.000226

count  total (s)   self (s)
   11              0.000143   let base = deepcopy(s:Vital)
   11              0.000045   let base._plugin_name = a:plugin_name
   11              0.000019   return base

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:63
Called 241 times
Total time:   0.002042
 Self time:   0.002042

count  total (s)   self (s)
  241              0.001711   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  337()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:369
Called 15 times
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
   15              0.000072 	let self.variables.input_key_stack = a:stack
   15              0.000035 	return self.variables.input_key_stack

FUNCTION  <SNR>110_BuildShell()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:412
Called 3 times
Total time:   0.001842
 Self time:   0.000543

count  total (s)   self (s)
    3              0.000017   let cmd = copy(a:args)
    3   0.000429   0.000036   let tree = s:Tree(a:dir)
    3   0.000143   0.000089   let pre = s:BuildEnvPrefix(a:env)
    3              0.000043   if empty(tree) || index(cmd, '--') == len(cmd) - 1
                                call insert(cmd, '--git-dir=' . FugitiveGitPath(a:dir))
    3   0.000205   0.000037   elseif fugitive#GitVersion(1, 8, 5)
    3   0.000166   0.000048     call extend(cmd, ['-C', FugitiveGitPath(tree)], 'keep')
                              else
                                let pre = 'cd ' . s:shellesc(tree) . (s:winshell() ? '& ' : '; ') . pre
    3              0.000002   endif
    3   0.000793   0.000228   return pre . g:fugitive_git_executable . ' ' . join(map(cmd, 's:shellesc(v:val)'))

FUNCTION  <SNR>136__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:21
Called 1 time
Total time:   0.002327
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.002323   0.000015 	let s:Message  = s:V.import("Vim.Message")

FUNCTION  airline#update_statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:127
Called 18 times
Total time:   0.546787
 Self time:   0.002962

count  total (s)   self (s)
   18   0.018809   0.000365   if airline#util#stl_disabled(winnr())
                                return
   18              0.000021   endif
   18              0.000387   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
   18   0.189075   0.000398   call airline#update_statusline_inactive(range)

   18              0.000080   unlet! w:airline_render_left w:airline_render_right
   18              0.000465   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')

                              " Now create the active statusline
   18              0.000059   let w:airline_active = 1
   18              0.000222   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
   18   0.337496   0.000791   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>94_reset_untracked_cache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:319
Called 2 times
Total time:   0.013737
 Self time:   0.013574

count  total (s)   self (s)
                              " shellcmdpost - whether function was called as a result of ShellCmdPost hook
    2              0.000017   if !g:airline#init#vim_async && !has('nvim')
                                if a:shellcmdpost
                                  " Clear cache only if there was no error or the script uses an
                                  " asynchronous interface. Otherwise, cache clearing would overwrite
                                  " v:shell_error with a system() call inside get_*_untracked.
                                  if v:shell_error
                                    return
                                  endif
                                endif
    2              0.000001   endif

    2              0.000534   let file = expand("%:p")
    6              0.000046   for vcs in keys(s:vcs_config)
                                " Dump the value of the cache for the current file. Partially mitigates the
                                " issue of cache invalidation happening before a call to
                                " s:update_untracked()
    4   0.012991   0.012828     call airline#extensions#branch#update_untracked_config(file, vcs)
    4              0.000065     let s:vcs_config[vcs].untracked = {}
    6              0.000016   endfor

FUNCTION  <SNR>243_on_stdout_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:56
Called 10 times
Total time:   0.000403
 Self time:   0.000403

count  total (s)   self (s)
   10              0.000128   if empty(self.stdoutbuffer)
    5              0.000025     let self.stdoutbuffer = a:data
    5              0.000009   else
    5              0.000137     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
   10              0.000011   endif

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:183
Called 195 times
Total time:   0.007493
 Self time:   0.007493

count  total (s)   self (s)
  195              0.002777   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
    2              0.000006     return
  193              0.002094   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
  193              0.000180   endif

FUNCTION  airline#update_statusline_focuslost()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:146
Called 3 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
    3              0.000056   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
    3              0.000005   endif

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:71
Called 4 times
Total time:   0.036918
 Self time:   0.002349

count  total (s)   self (s)
    4   0.000351   0.000082   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter author fail'
    4              0.000008   endif

    4   0.000233   0.000063   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
    4              0.000004   endif

                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    4              0.000011   let cmd = '('

                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.

                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    4              0.000028   let buff_file = s:temp_buffer.'.'.a:bufnr

                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    4              0.000018   let s:counter = (s:counter + 1) % 20
    4              0.000022   let buff_file .= '.'.s:counter

    4   0.001280   0.000106   let extension = gitgutter#utility#extension(a:bufnr)
    4              0.000019   if !empty(extension)
    4              0.000024     let buff_file .= '.'.extension
    4              0.000006   endif

                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    4   0.003376   0.000342   call s:write_buffer(a:bufnr, buff_file)

    4              0.000024   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    4              0.000061     let from_file = s:temp_from.'.'.a:bufnr

                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    4              0.000026     let from_file .= '.'.s:counter

    4              0.000019     if !empty(extension)
    4              0.000022       let from_file .= '.'.extension
    4              0.000005     endif

                                " Write file from index to temporary file.
    4   0.001756   0.000221     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
    4              0.000061     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '

                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
    4              0.000005   endif

                              " Call git-diff.
    4              0.000031   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
    4              0.000008   if s:c_flag
    4              0.000018     let cmd .= ' -c "diff.autorefreshindex=0"'
    4              0.000014     let cmd .= ' -c "diff.noprefix=false"'
    4              0.000014     let cmd .= ' -c "core.safecrlf=false"'
    4              0.000004   endif
    4              0.000046   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file

                              " Pipe git-diff output into grep.
    4              0.000024   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    4   0.000581   0.000239     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    4              0.000005   endif

                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    4              0.000017   let cmd .= ' || exit 0'

    4              0.000012   let cmd .= ')'

    4   0.002972   0.000097   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)

    4   0.000083   0.000066   if g:gitgutter_async && gitgutter#async#available()
    4   0.025449   0.000296     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    4              0.000026     return 'async'

                              else
                                let diff = gitgutter#utility#system(cmd)

                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif

                                return diff
                              endif

FUNCTION  <SNR>57_exists_file()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:223
Called 55 times
Total time:   0.031754
 Self time:   0.004349

count  total (s)   self (s)
   55   0.031661   0.004257   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  vital#_easymotion#Over#String#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:5
Called 1 time
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    1              0.000059     return map({'_vital_depends': '', 'length': '', 'index': '', 'split_by_keys': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>249_syn_contains()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/jsx_pretty/comment.vim:37
Called 17 times
Total time:   0.013614
 Self time:   0.013614

count  total (s)   self (s)
   17              0.012757   let stack = synstack(a:lnum, a:cnum)
   17              0.000640   let syn_names = map(stack, 'synIDattr(v:val, "name")')
   17              0.000158   return index(syn_names, a:syn_name) >= 0

FUNCTION  vital#_easymotion#Palette#Keymapping#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Keymapping.vim:5
Called 1 time
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    1              0.000062     return map({'capture': '', '_vital_depends': '', 'escape_special_key': '', 'rhs_key_list': '', 'parse_lhs_list': '', 'lhs_key_list': '', 'capture_list': '', 'parse_lhs': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  391()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:118
Called 15 times
Total time:   0.001190
 Self time:   0.001190

count  total (s)   self (s)
   15              0.001035 	execute self.draw_command
                            " 	execute "echohl" a:cmdline.highlights.prompt
                            " 	call s:echon(a:cmdline.get_prompt())
                            " 	echohl NONE
                            " 	call s:echon(a:cmdline.backward())
                            " 	if empty(a:cmdline.line.pos_char())
                            " 		execute "echohl" a:cmdline.highlights.cursor
                            " 		call s:echon(' ')
                            " 	else
                            " 		execute "echohl" a:cmdline.highlights.cursor_on
                            " 		call s:echon(a:cmdline.line.pos_char())
                            " 	endif
                            " 	echohl NONE
                            " 	call s:echon(a:cmdline.forward())
                            " 	if	a:cmdline.get_suffix() != ""
                            " 		call s:echon(s:suffix(a:cmdline.get_prompt() . a:cmdline.getline() . repeat(" ", empty(a:cmdline.line.pos_char())), a:cmdline.get_suffix()))
                            " 	endif

FUNCTION  fugitive#CommonDir()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:256
Called 264 times
Total time:   0.014758
 Self time:   0.014758

count  total (s)   self (s)
  264              0.001716   if empty(a:dir)
                                return ''
  264              0.000236   endif
  264              0.001503   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
  264              0.000203   endif
  264              0.001094   return s:commondirs[a:dir]

FUNCTION  390()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:88
Called 15 times
Total time:   0.133649
 Self time:   0.002080

count  total (s)   self (s)
   15   0.000267   0.000188 	if empty(a:cmdline.line.pos_char())
   15              0.000087 		let cursor = "echohl " . a:cmdline.highlights.cursor . " | echon ' '"
                            	else
                            		let cursor = "echohl " . a:cmdline.highlights.cursor_on . " | " . s:_as_echon(a:cmdline.line.pos_char())
   15              0.000014 	endif
   15              0.000028 	let suffix = ""
   15   0.000193   0.000145 	if	a:cmdline.get_suffix() != ""
                            		let suffix = s:_as_echon(s:suffix(a:cmdline.get_prompt() . a:cmdline.getline() . repeat(" ", empty(a:cmdline.line.pos_char())), a:cmdline.get_suffix()))
   15              0.000013 	endif
   15   0.002014   0.001067 	let self.draw_command  = join([		"echohl " . a:cmdline.highlights.prompt,		s:_as_echon(a:cmdline.get_prompt()),		"echohl NONE",		s:_as_echon(a:cmdline.backward()),		cursor,		"echohl NONE",		s:_as_echon(a:cmdline.forward()),		suffix,	], " | ")

   15   0.130677   0.000181 	call s:_redraw(a:cmdline)

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:89
Called 335 times
Total time:   0.055152
 Self time:   0.020456

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
  335   0.048457   0.013761   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
   86              0.000162     return ''
  249              0.000316   endif
  249              0.001553   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
  249              0.000256   else
  249              0.000847     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  vital#_easymotion#Over#Commandline#Modules#Delete#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Delete.vim:5
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000025     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  fugitive#Head()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:497
Called 257 times
Total time:   0.314635
 Self time:   0.067071

count  total (s)   self (s)
  257              0.002624   let dir = a:0 > 1 ? a:2 : s:Dir()
  257              0.001032   if empty(dir)
                                return ''
  257              0.000337   endif
  257   0.253848   0.006285   let file = fugitive#Find('.git/HEAD', dir)
  257              0.022356   let ftime = getftime(file)
  257              0.001036   if ftime == -1
                                return ''
  257              0.003229   elseif ftime != get(s:head_cache, dir, [-1])[0]
    5              0.000463     let s:head_cache[dir] = [ftime, readfile(file)[0]]
  257              0.000264   endif
  257              0.001447   let head = s:head_cache[dir][1]
  257              0.004177   if head =~# '^ref: '
  257              0.018663     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  <SNR>26_fzf_call()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:73
Called 30 times
Total time:   0.000601
 Self time:   0.000601

count  total (s)   self (s)
   30              0.000570     return call(a:fn, a:000)

FUNCTION  <SNR>246_process_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:310
Called 16 times
Total time:   0.000695
 Self time:   0.000695

count  total (s)   self (s)
   16              0.000054   let offset = 0
   38              0.000110   while offset < a:to_count
   22              0.000087     let line_number = a:to_line + offset
   22              0.000142     call add(a:modifications, [line_number, 'modified'])
   22              0.000062     let offset += 1
   38              0.000064   endwhile

FUNCTION  396()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Paste.vim:25
Called 15 times
Total time:   0.000882
 Self time:   0.000429

count  total (s)   self (s)
   15   0.000635   0.000183 	if a:cmdline.is_input("<Over>(paste)")
                            		let register = v:register == "" ? '"' : v:register
                            		call a:cmdline.insert(tr(getreg("*"), "\n", "\r"))
                            		call a:cmdline.setchar('')
   15              0.000014 	endif

FUNCTION  nerdtree#has_opt()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:182
Called 934 times
Total time:   0.008339
 Self time:   0.008339

count  total (s)   self (s)
  934              0.007217     return has_key(a:options, a:name) && a:options[a:name] ==# 1

FUNCTION  vital#_easymotion#Over#Commandline#Modules#Redraw#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Redraw.vim:5
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:130
Called 126 times
Total time:   0.108235
 Self time:   0.010015

count  total (s)   self (s)
  126              0.000594   if a:group1 == a:group2
                                return 0
  126              0.000101   endif
  126   0.052643   0.004816   let color1 = airline#highlighter#get_highlight(a:group1)
  126   0.053287   0.002894   let color2 = airline#highlighter#get_highlight(a:group2)
  126              0.001077   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  vital#_easymotion#Over#Commandline#Modules#Cancel#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Cancel.vim:5
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  fugitive#BufReadStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1726
Called 1 time
Total time:   0.186741
 Self time:   0.004109

count  total (s)   self (s)
    1   0.000049   0.000035   let amatch = s:Slash(expand('%:p'))
    1              0.000005   let b:fugitive_type = 'index'
    1              0.000003   unlet! b:fugitive_reltime
    1              0.000003   try
    1   0.000196   0.000018     silent doautocmd BufReadPre
    1   0.000927   0.000013     let config = fugitive#Config()

    1              0.000019     let cmd = [fnamemodify(amatch, ':h')]
    1              0.000030     setlocal noro ma nomodeline buftype=nowrite
    1   0.001021   0.000074     if s:cpath(fnamemodify($GIT_INDEX_FILE !=# '' ? $GIT_INDEX_FILE : fugitive#Find('.git/index'), ':p')) !=# s:cpath(amatch)
                                  let cmd += ['-c', 'GIT_INDEX_FILE=' . amatch]
    1              0.000001     endif

    1   0.000081   0.000011     if fugitive#GitVersion(2, 15)
    1              0.000004       call add(cmd, '--no-optional-locks')
    1              0.000001     endif

    1              0.000005     let b:fugitive_files = {'Staged': {}, 'Unstaged': {}}
    1              0.000006     let [staged, unstaged, untracked] = [[], [], []]
    1              0.000002     let props = {}

    1   0.000071   0.000011     if fugitive#GitVersion(2, 11)
    1              0.000005       let cmd += ['status', '--porcelain=v2', '-bz']
    1   0.032541   0.000029       let [output, message, exec_error] = s:NullError(cmd)
    1              0.000002       if exec_error
                                    throw 'fugitive: ' . message
    1              0.000001       endif

    1              0.000003       let i = 0
   17              0.000048       while i < len(output)
   16              0.000042         let line = output[i]
   16              0.000192         let prop = matchlist(line, '# \(\S\+\) \(.*\)')
   16              0.000036         if len(prop)
    4              0.000018           let props[prop[1]] = prop[2]
   12              0.000027         elseif line[0] ==# '?'
                                      call add(untracked, {'type': 'File', 'status': line[0], 'filename': line[2:-1]})
   12              0.000026         elseif line[0] !=# '#'
   12              0.000024           if line[0] ==# 'u'
                                        let file = matchstr(line, '^.\{37\} \x\{40,\} \x\{40,\} \x\{40,\} \zs.*$')
   12              0.000008           else
   12              0.000188             let file = matchstr(line, '^.\{30\} \x\{40,\} \x\{40,\} \zs.*$')
   12              0.000010           endif
   12              0.000026           if line[0] ==# '2'
                                        let i += 1
                                        let file = matchstr(file, ' \zs.*')
                                        let files = output[i] . ' -> ' . file
   12              0.000008           else
   12              0.000024             let files = file
   12              0.000008           endif
   12              0.000119           let sub = matchstr(line, '^[12u] .. \zs....')
   12              0.000027           if line[2] !=# '.'
                                        call add(staged, {'type': 'File', 'status': line[2], 'filename': files, 'sub': sub})
   12              0.000008           endif
   12              0.000024           if line[3] !=# '.'
   12              0.000219             call add(unstaged, {'type': 'File', 'status': get({'C':'M','M':'?','U':'?'}, matchstr(sub, 'S\.*\zs[CMU]'), line[3]), 'filename': file, 'sub': sub})
   12              0.000009           endif
   16              0.000010         endif
   16              0.000033         let i += 1
   17              0.000018       endwhile
    1              0.000014       let branch = substitute(get(props, 'branch.head', '(unknown)'), '\C^(\%(detached\|unknown\))$', '', '')
    1              0.000003       if len(branch)
    1              0.000002         let head = branch
                                  elseif has_key(props, 'branch.oid')
                                    let head = props['branch.oid'][0:10]
                                  else
                                    let head = FugitiveHead(11)
    1              0.000001       endif
    1              0.000004       let pull = get(props, 'branch.upstream', '')
                                else " git < 2.11
                                  let cmd += ['status', '--porcelain', '-bz']
                                  let [output, message, exec_error] = s:NullError(cmd)
                                  if exec_error
                                    throw 'fugitive: ' . message
                                  endif

                                  while get(output, 0, '') =~# '^\l\+:'
                                    call remove(output, 0)
                                  endwhile
                                  let head = matchstr(output[0], '^## \zs\S\+\ze\%($\| \[\)')
                                  let pull = ''
                                  if head =~# '\.\.\.'
                                    let [head, pull] = split(head, '\.\.\.')
                                    let branch = head
                                  elseif head ==# 'HEAD' || empty(head)
                                    let head = FugitiveHead(11)
                                    let branch = ''
                                  else
                                    let branch = head
                                  endif

                                  let i = 0
                                  while i < len(output)
                                    let line = output[i]
                                    let file = line[3:-1]
                                    let files = file
                                    let i += 1
                                    if line[2] !=# ' '
                                      continue
                                    endif
                                    if line[0:1] =~# '[RC]'
                                      let files = output[i] . ' -> ' . file
                                      let i += 1
                                    endif
                                    if line[0] !~# '[ ?!#]'
                                      call add(staged, {'type': 'File', 'status': line[0], 'filename': files, 'sub': ''})
                                    endif
                                    if line[0:1] ==# '??'
                                      call add(untracked, {'type': 'File', 'status': line[1], 'filename': files})
                                    elseif line[1] !~# '[ !#]'
                                      call add(unstaged, {'type': 'File', 'status': line[1], 'filename': file, 'sub': ''})
                                    endif
                                  endwhile
    1              0.000001     endif

    1   0.000115   0.000020     if empty(s:Tree())
                                  let [unstaged, untracked] = [[], []]
    1              0.000001     endif

    1              0.000004     for dict in staged
                                  let b:fugitive_files['Staged'][dict.filename] = dict
    1              0.000001     endfor
   13              0.000014     for dict in unstaged
   12              0.000051       let b:fugitive_files['Unstaged'][dict.filename] = dict
   13              0.000009     endfor

    1              0.000002     let pull_type = 'Pull'
    1              0.000002     if len(pull)
    1   0.000104   0.000017       let rebase = fugitive#Config('branch.' . branch . '.rebase', config)
    1              0.000003       if empty(rebase)
    1   0.000080   0.000011         let rebase = fugitive#Config('pull.rebase', config)
    1              0.000001       endif
    1              0.000020       if rebase =~# '^\%(true\|yes\|on\|1\|interactive\|merges\|preserve\)$'
                                    let pull_type = 'Rebase'
    1              0.000011       elseif rebase =~# '^\%(false\|no|off\|0\|\)$'
    1              0.000002         let pull_type = 'Merge'
    1              0.000001       endif
    1              0.000001     endif

    1   0.000139   0.000013     let push_remote = fugitive#Config('branch.' . branch . '.pushRemote', config)
    1              0.000003     if empty(push_remote)
    1   0.000082   0.000011       let push_remote = fugitive#Config('remote.pushDefault', config)
    1              0.000001     endif
    1   0.000079   0.000012     let fetch_remote = fugitive#Config('branch.' . branch . '.remote', config)
    1              0.000003     if empty(fetch_remote)
                                  let fetch_remote = 'origin'
    1              0.000001     endif
    1              0.000002     if empty(push_remote)
    1              0.000002       let push_remote = fetch_remote
    1              0.000001     endif

    1   0.000942   0.000011     let push_default = fugitive#Config('push.default')
    1              0.000003     if empty(push_default)
    1   0.000087   0.000014       let push_default = fugitive#GitVersion(2) ? 'simple' : 'matching'
    1              0.000001     endif
    1              0.000002     if push_default ==# 'upstream'
                                  let push = pull
    1              0.000001     else
    1              0.000007       let push = len(branch) ? (push_remote ==# '.' ? '' : push_remote . '/') . branch : ''
    1              0.000001     endif

    1   0.000612   0.000023     if isdirectory(fugitive#Find('.git/rebase-merge/'))
                                  let rebasing_dir = fugitive#Find('.git/rebase-merge/')
    1   0.000546   0.000021     elseif isdirectory(fugitive#Find('.git/rebase-apply/'))
                                  let rebasing_dir = fugitive#Find('.git/rebase-apply/')
    1              0.000001     endif

    1              0.000003     let rebasing = []
    1              0.000003     let rebasing_head = 'detached HEAD'
    1              0.000005     if exists('rebasing_dir') && filereadable(rebasing_dir . 'git-rebase-todo')
                                  let rebasing_head = substitute(readfile(rebasing_dir . 'head-name')[0], '\C^refs/heads/', '', '')
                                  let len = 11
                                  let lines = readfile(rebasing_dir . 'git-rebase-todo')
                                  for line in lines
                                    let hash = matchstr(line, '^[^a-z].*\s\zs[0-9a-f]\{4,\}\ze\.\.')
                                    if len(hash)
                                      let len = len(hash)
                                      break
                                    endif
                                  endfor
                                  if getfsize(rebasing_dir . 'done') > 0
                                    let done = readfile(rebasing_dir . 'done')
                                    call map(done, 'substitute(v:val, ''^\l\+\>'', "done", "")')
                                    let done[-1] = substitute(done[-1], '^\l\+\>', 'stop', '')
                                    let lines = done + lines
                                  endif
                                  call reverse(lines)
                                  for line in lines
                                    let match = matchlist(line, '^\(\l\+\)\s\+\(\x\{4,\}\)\s\+\(.*\)')
                                    if len(match) && match[1] !~# 'exec\|merge\|label'
                                      call add(rebasing, {'type': 'Rebase', 'status': get(s:rebase_abbrevs, match[1], match[1]), 'commit': strpart(match[2], 0, len), 'subject': match[3]})
                                    endif
                                  endfor
    1              0.000001     endif

    1              0.000004     let diff = {'Staged': [], 'Unstaged': []}
    1              0.000002     if len(staged)
                                  let diff['Staged'] = s:LinesError(['diff', '--color=never', '--no-ext-diff', '--no-prefix', '--cached'])[0]
    1              0.000001     endif
    1              0.000002     if len(unstaged)
    1   0.047617   0.000034       let diff['Unstaged'] = s:LinesError(['diff', '--color=never', '--no-ext-diff', '--no-prefix'])[0]
    1              0.000003     endif
    1              0.000006     let b:fugitive_diff = diff
    1              0.000012     let expanded = get(b:, 'fugitive_expanded', {'Staged': {}, 'Unstaged': {}})
    1              0.000005     let b:fugitive_expanded = {'Staged': {}, 'Unstaged': {}}

    1              0.000015     silent keepjumps %delete_

    1   0.000118   0.000030     call s:AddHeader('Head', head)
    1   0.000063   0.000017     call s:AddHeader(pull_type, pull)
    1              0.000004     if push !=# pull
                                  call s:AddHeader('Push', push)
    1              0.000001     endif
    1   0.000133   0.000014     if empty(s:Tree())
                                  call s:AddHeader('Bare', 'yes')
    1              0.000001     endif
    1   0.000076   0.000025     if get(FugitiveConfigGetAll('advice.statusHints', config), 0, 'true') !~# '^\%(false\|no|off\|0\|\)$'
    1   0.000111   0.000050       call s:AddHeader('Help', 'g?')
    1              0.000001     endif

    1   0.000023   0.000014     call s:AddSection('Rebasing ' . rebasing_head, rebasing)
    1   0.000018   0.000010     call s:AddSection('Untracked', untracked)
    1   0.000383   0.000013     call s:AddSection('Unstaged', unstaged)
    1              0.000008     let unstaged_end = len(unstaged) ? line('$') : 0
    1   0.000025   0.000015     call s:AddSection('Staged', staged)
    1              0.000005     let staged_end = len(staged) ? line('$') : 0

    1              0.000012     if len(pull) && get(props, 'branch.ab') !~# ' -0$'
                                  call s:AddSection('Unpulled from ' . pull, s:QueryLog(head . '..' . pull))
    1              0.000001     endif
    1              0.000004     if len(push) && push !=# pull
                                  call s:AddSection('Unpulled from ' . push, s:QueryLog(head . '..' . push))
    1              0.000001     endif
    1              0.000003     if len(pull) && push !=# pull
                                  call s:AddSection('Unpushed to ' . pull, s:QueryLog(pull . '..' . head))
    1              0.000001     endif
    1              0.000010     if len(push) && !(push ==# pull && get(props, 'branch.ab') =~# '^+0 ')
                                  call s:AddSection('Unpushed to ' . push, s:QueryLog(push . '..' . head))
    1              0.000001     endif

    1              0.000028     setlocal nomodified readonly noswapfile
    1   0.005565   0.000011     silent doautocmd BufReadPost
    1              0.000007     setlocal nomodifiable
    1              0.000003     if &bufhidden ==# ''
    1              0.000006       setlocal bufhidden=delete
    1              0.000001     endif
    1              0.000003     let b:dispatch = ':Git fetch --all'
    1   0.042009   0.000015     call fugitive#MapJumps()
    1   0.000247   0.000063     call s:Map('n', '-', ":<C-U>execute <SID>Do('Toggle',0)<CR>", '<silent>')
    1   0.000194   0.000014     call s:Map('x', '-', ":<C-U>execute <SID>Do('Toggle',1)<CR>", '<silent>')
    1   0.000227   0.000014     call s:Map('n', 's', ":<C-U>execute <SID>Do('Stage',0)<CR>", '<silent>')
    1   0.000180   0.000013     call s:Map('x', 's', ":<C-U>execute <SID>Do('Stage',1)<CR>", '<silent>')
    1   0.000179   0.000013     call s:Map('n', 'u', ":<C-U>execute <SID>Do('Unstage',0)<CR>", '<silent>')
    1   0.000176   0.000013     call s:Map('x', 'u', ":<C-U>execute <SID>Do('Unstage',1)<CR>", '<silent>')
    1   0.000176   0.000012     call s:Map('n', 'U', ":exe <SID>EchoExec('reset', '-q')<CR>", '<silent>')
    1   0.000648   0.000012     call s:MapMotion('gu', "exe <SID>StageJump(v:count, 'Untracked', 'Unstaged')")
    1   0.000653   0.000012     call s:MapMotion('gU', "exe <SID>StageJump(v:count, 'Unstaged', 'Untracked')")
    1   0.000711   0.000069     call s:MapMotion('gs', "exe <SID>StageJump(v:count, 'Staged')")
    1   0.000649   0.000011     call s:MapMotion('gp', "exe <SID>StageJump(v:count, 'Unpushed')")
    1   0.000650   0.000011     call s:MapMotion('gP', "exe <SID>StageJump(v:count, 'Unpulled')")
    1   0.000627   0.000011     call s:MapMotion('gr', "exe <SID>StageJump(v:count, 'Rebasing')")
    1   0.000169   0.000012     call s:Map('n', 'C', ":echoerr ':Gstatus C has been removed in favor of cc'<CR>", '<silent>')
    1   0.000168   0.000012     call s:Map('n', 'a', ":<C-U>execute <SID>Do('Toggle',0)<CR>", '<silent>')
    1   0.000168   0.000012     call s:Map('n', 'i', ":<C-U>execute <SID>NextExpandedHunk(v:count1)<CR>", '<silent>')
    1   0.000167   0.000012     call s:Map('n', "=", ":<C-U>execute <SID>StageInline('toggle',line('.'),v:count)<CR>", '<silent>')
    1   0.000171   0.000012     call s:Map('n', "<", ":<C-U>execute <SID>StageInline('hide',  line('.'),v:count)<CR>", '<silent>')
    1   0.000167   0.000012     call s:Map('n', ">", ":<C-U>execute <SID>StageInline('show',  line('.'),v:count)<CR>", '<silent>')
    1   0.000171   0.000013     call s:Map('x', "=", ":<C-U>execute <SID>StageInline('toggle',line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
    1   0.000170   0.000013     call s:Map('x', "<", ":<C-U>execute <SID>StageInline('hide',  line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
    1   0.000170   0.000013     call s:Map('x', ">", ":<C-U>execute <SID>StageInline('show',  line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
    1   0.000177   0.000014     call s:Map('n', 'D', ":<C-U>execute <SID>StageDiff('Gdiffsplit')<Bar>redraw<Bar>echohl WarningMsg<Bar> echo ':Gstatus D is deprecated in favor of dd'<Bar>echohl NONE<CR>", '<silent>')
    1   0.000198   0.000012     call s:Map('n', 'dd', ":<C-U>execute <SID>StageDiff('Gdiffsplit')<CR>", '<silent>')
    1   0.000197   0.000012     call s:Map('n', 'dh', ":<C-U>execute <SID>StageDiff('Ghdiffsplit')<CR>", '<silent>')
    1   0.000328   0.000014     call s:Map('n', 'ds', ":<C-U>execute <SID>StageDiff('Ghdiffsplit')<CR>", '<silent>')
    1   0.000209   0.000015     call s:Map('n', 'dp', ":<C-U>execute <SID>StageDiffEdit()<CR>", '<silent>')
    1   0.000197   0.000013     call s:Map('n', 'dv', ":<C-U>execute <SID>StageDiff('Gvdiffsplit')<CR>", '<silent>')
    1   0.000194   0.000012     call s:Map('n', 'd?', ":<C-U>help fugitive_d<CR>", '<silent>')
    1   0.000172   0.000013     call s:Map('n', 'P', ":<C-U>execute <SID>StagePatch(line('.'),line('.')+v:count1-1)<CR>", '<silent>')
    1   0.000170   0.000012     call s:Map('x', 'P', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
    1   0.000178   0.000014     call s:Map('n', 'p', ":<C-U>if v:count<Bar>silent exe <SID>GF('pedit')<Bar>else<Bar>echoerr 'Use = for inline diff, P for :Git add/reset --patch, 1p for :pedit'<Bar>endif<CR>", '<silent>')
    1   0.000170   0.000013     call s:Map('x', 'p', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
    1   0.000222   0.000017     call s:Map('n', 'I', ":<C-U>execute <SID>StagePatch(line('.'),line('.'))<CR>", '<silent>')
    1   0.000332   0.000034     call s:Map('x', 'I', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
    1              0.000023     if empty(mapcheck('q', 'n'))
    1              0.000031       nnoremap <buffer> <silent> q :<C-U>if bufnr('$') == 1<Bar>quit<Bar>else<Bar>bdelete<Bar>endif<Bar>echohl WarningMsg<Bar>echo ':Gstatus q is deprecated in favor of gq or the built-in <Lt>C-W>q'<Bar>echohl NONE<CR>
    1              0.000001     endif
    1   0.000222   0.000019     call s:Map('n', 'gq', ":<C-U>if bufnr('$') == 1<Bar>quit<Bar>else<Bar>bdelete<Bar>endif<CR>", '<silent>')
    1   0.000191   0.000015     call s:Map('n', 'R', ":echohl WarningMsg<Bar>echo 'Reloading is automatic.  Use :e to force'<Bar>echohl NONE<CR>", '<silent>')
    1   0.000208   0.000014     call s:Map('n', 'g<Bar>', ":<C-U>echoerr 'Changed to X'<CR>", '<silent>')
    1   0.000244   0.000014     call s:Map('x', 'g<Bar>', ":<C-U>echoerr 'Changed to X'<CR>", '<silent>')
    1   0.000176   0.000015     call s:Map('n', 'X', ":<C-U>execute <SID>StageDelete(line('.'), 0, v:count)<CR>", '<silent>')
    1   0.000175   0.000013     call s:Map('x', 'X', ":<C-U>execute <SID>StageDelete(line(\"'<\"), line(\"'>\"), v:count)<CR>", '<silent>')
    1   0.000212   0.000013     call s:Map('n', 'gI', ":<C-U>execute <SID>StageIgnore(line('.'), line('.'), v:count)<CR>", '<silent>')
    1   0.000201   0.000013     call s:Map('x', 'gI', ":<C-U>execute <SID>StageIgnore(line(\"'<\"), line(\"'>\"), v:count)<CR>", '<silent>')
    1   0.000170   0.000011     call s:Map('n', '.', ':<C-U> <C-R>=<SID>StageArgs(0)<CR><Home>')
    1   0.000169   0.000011     call s:Map('x', '.', ':<C-U> <C-R>=<SID>StageArgs(1)<CR><Home>')
    1   0.038580   0.000017     setlocal filetype=fugitive

    3              0.000013     for [lnum, section] in [[staged_end, 'Staged'], [unstaged_end, 'Unstaged']]
   15              0.000048       while len(getline(lnum))
   13              0.000193         let filename = matchstr(getline(lnum), '^[A-Z?] \zs.*')
   13              0.000053         if has_key(expanded[section], filename)
                                      call s:StageInline('show', lnum)
   13              0.000008         endif
   13              0.000020         let lnum -= 1
   15              0.000011       endwhile
    3              0.000003     endfor

    1              0.000004     let b:fugitive_reltime = reltime()
    1   0.000038   0.000029     return 'silent ' . s:DoAutocmd('User FugitiveIndex')
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
    1              0.000005   endtry

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 70 times
Total time:   0.002467
 Self time:   0.002467

count  total (s)   self (s)
   70              0.000370   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   70              0.000405   let ggvars = getbufvar(buffer, 'gitgutter')
   70              0.000339   if type(ggvars) == type('')
    4              0.000010     unlet ggvars
    4              0.000012     let ggvars = {}
    4              0.000025     call setbufvar(buffer, 'gitgutter', ggvars)
   70              0.000084   endif
   70              0.000393   let ggvars[a:varname] = a:val

FUNCTION  <SNR>106_setup_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:156
Called 42 times
Total time:   0.014925
 Self time:   0.001777

count  total (s)   self (s)
   42   0.009019   0.001666   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif

    1   0.005829   0.000035   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  <SNR>110_StatusCommand()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:2704
Called 1 time
Total time:   0.002156
 Self time:   0.000262

count  total (s)   self (s)
    1   0.000532   0.000009   let dir = a:0 ? a:1 : s:Dir()
    1   0.000092   0.000013   exe s:DirCheck(dir)
    1              0.000001   try
    1   0.000059   0.000012     let mods = s:Mods(a:mods, &splitbelow ? 'botright' : 'topleft')
    1   0.001009   0.000011     let file = fugitive#Find(':', dir)
    1   0.000031   0.000013     let arg = ' +setl\ foldmethod=syntax\ foldlevel=1\|let\ w:fugitive_status=FugitiveGitDir() ' . s:fnameescape(file)
    3              0.000010     for winnr in range(1, winnr('$'))
    2   0.000351   0.000123       if s:cpath(file, fnamemodify(bufname(winbufnr(winnr)), ':p'))
                                    if winnr == winnr()
                                      call s:ReloadStatus()
                                    else
                                      call s:ExpireStatus(dir)
                                      exe winnr . 'wincmd w'
                                    endif
                                    let w:fugitive_status = dir
                                    1
                                    return ''
    2              0.000001       endif
    3              0.000004     endfor
    1              0.000002     if a:count ==# 0
                                  return mods . 'edit' . (a:bang ? '!' : '') . arg
    1              0.000001     elseif a:bang
                                  return mods . 'pedit' . arg . '|wincmd P'
    1              0.000001     else
    1              0.000004       return mods . 'keepalt split' . arg
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
    1              0.000001   endtry
                              return ''

FUNCTION  <SNR>243_build_command()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 5 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    5              0.000030   if has('unix')
    5              0.000023     return ['sh', '-c', a:cmd]
                              endif

                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif

                              throw 'unknown os'

FUNCTION  <SNR>141__as_echon()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/DrawCommandline.vim:83
Called 45 times
Total time:   0.000341
 Self time:   0.000341

count  total (s)   self (s)
   45              0.000312 	return "echon " . strtrans(string(a:str))

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:231
Called 4 times
Total time:   0.037310
 Self time:   0.001756

count  total (s)   self (s)
    4              0.000020   let modified_lines = []
   44              0.000114   for hunk in a:hunks
   40   0.037022   0.001468     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   44              0.000092   endfor
    4              0.000009   return modified_lines

FUNCTION  nerdtree#exec()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:169
Called 48 times
Total time:   0.009327
 Self time:   0.009327

count  total (s)   self (s)
   48              0.000441     let old_ei = &eventignore
   48              0.000123     if a:ignoreAll
   48              0.000642         set eventignore=all
   48              0.000063     endif
   48              0.000069     try
   48              0.006241         exec a:cmd
   48              0.000214     finally
   48              0.001129         let &eventignore = old_ei
   48              0.000102     endtry

FUNCTION  <SNR>57_winshell()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:68
Called 4 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    4              0.000066   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>93_get_hunks_gitgutter()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:60
Called 241 times
Total time:   0.057634
 Self time:   0.023296

count  total (s)   self (s)
  241   0.010777   0.006414   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
    7              0.000010     return ''
  234              0.000247   endif
  234   0.043985   0.014010   return GitGutterGetHunkSummary()

FUNCTION  <SNR>120_Initialised()
    Defined: ~/.vim/plugged/vimspector/autoload/vimspector.vim:32
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000017   return s:enabled != v:null

FUNCTION  fugitive#Command()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:2467
Called 1 time
Total time:   0.046292
 Self time:   0.000162

count  total (s)   self (s)
    1   0.000484   0.000012   let dir = s:Dir()
    1   0.043374   0.000046   let config = copy(fugitive#Config(dir))
    1   0.000201   0.000027   let [args, after] = s:SplitExpandChain(a:arg, s:Tree(dir))
    1              0.000002   let flags = []
    1              0.000002   let pager = -1
    1              0.000003   while len(args)
                                if args[0] ==# '-c' && len(args) > 1
                                  call extend(flags, remove(args, 0, 1))
                                elseif args[0] =~# '^-p$\|^--paginate$'
                                  let pager = 1
                                  call remove(args, 0)
                                elseif args[0] =~# '^-P$\|^--no-pager$'
                                  let pager = 0
                                  call remove(args, 0)
                                elseif args[0] =~# '^--\%([[:lower:]-]\+-pathspecs\|no-optional-locks\)$'
                                  call add(flags, remove(args, 0))
                                elseif args[0] =~# '^-C$\|^--\%(exec-path=\|git-dir=\|work-tree=\|bare$\)'
                                  return 'echoerr ' . string('fugitive: ' . args[0] . ' is not supported')
                                else
                                  break
                                endif
    1              0.000003   endwhile
    1              0.000002   if pager is# 0
                                call add(flags, '--no-pager')
    1              0.000001   endif
    1              0.000003   if empty(args) && pager is# -1
    1   0.002175   0.000019     let cmd = s:StatusCommand(a:line1, a:line2, a:range, a:line2, a:bang, a:mods, '', '', [])
    1              0.000008     return (empty(cmd) ? 'exe' : cmd) . after
                              endif
                              let alias = fugitive#Config('alias.' . get(args, 0, ''), config)
                              if get(args, 1, '') !=# '--help' && alias !~# '^$\|^!\|[\"'']' && !filereadable(s:ExecPath() . '/git-' . args[0]) && !(has('win32') && filereadable(s:ExecPath() . '/git-' . args[0] . '.exe'))
                                call remove(args, 0)
                                call extend(args, split(alias, '\s\+'), 'keep')
                              endif
                              let name = substitute(get(args, 0, ''), '\%(^\|-\)\(\l\)', '\u\1', 'g')
                              let git = split(get(g:, 'fugitive_git_command', g:fugitive_git_executable), '\s\+')
                              let options = {'git': git, 'dir': dir, 'flags': flags}
                              if pager is# -1 && exists('*s:' . name . 'Subcommand') && get(args, 1, '') !=# '--help'
                                try
                                  let overrides = s:{name}Subcommand(a:line1, a:line2, a:range, a:bang, a:mods, extend({'command': args[0], 'args': args[1:-1]}, options))
                                  if type(overrides) == type('')
                                    return 'exe ' . string(overrides) . after
                                  endif
                                  let args = [get(overrides, 'command', args[0])] + get(overrides, 'insert_args', []) + args[1:-1]
                                catch /^fugitive:/
                                  return 'echoerr ' . string(v:exception)
                                endtry
                              else
                                let overrides = {}
                              endif
                              let env = get(overrides, 'env', {})
                              let i = 0
                              while i < len(flags) - 1
                                if flags[i] ==# '-c'
                                  let i += 1
                                  let config_name = tolower(matchstr(flags[i], '^[^=]\+'))
                                  if has_key(s:prepare_env, config_name) && flags[i] =~# '=.'
                                    let env[s:prepare_env[config_name]] = matchstr(flags[i], '=\zs.*')
                                  endif
                                  if flags[i] =~# '='
                                    let config[config_name] = [matchstr(flags[i], '=\zs.*')]
                                  else
                                    let config[config_name] = [1]
                                  endif
                                endif
                                let i += 1
                              endwhile
                              let editcmd = a:line2 ? 'split' : 'edit'
                              if pager is# 1
                                if a:bang && a:line2 >= 0
                                  let editcmd = 'read'
                                elseif a:bang
                                  let editcmd = 'pedit'
                                endif
                              elseif pager is# -1
                                let pager = fugitive#PagerFor(args, config)
                                if a:bang && pager isnot# 1
                                  return 'echoerr ' .  string('fugitive: :Git! for temp buffer output has been replaced by :Git --paginate')
                                endif
                              endif
                              if pager is# 1
                                if editcmd ==# 'read'
                                  return s:ReadExec(a:line1, a:line2, a:range, a:mods, env, args, options) . after
                                else
                                  return s:OpenExec(editcmd, a:mods, env, args, options) . after
                                endif
                              endif
                              if s:HasOpt(args, ['add', 'checkout', 'commit', 'stage', 'stash', 'reset'], '-p', '--patch') || s:HasOpt(args, ['add', 'clean', 'stage'], '-i', '--interactive') || type(pager) == type('')
                                let mods = substitute(s:Mods(a:mods), '\<tab\>', '-tab', 'g')
                                let assign = len(dir) ? '|let b:git_dir = ' . string(dir) : ''
                                if has('nvim')
                                  if &autowrite || &autowriteall | silent! wall | endif
                                  return mods . (a:line2 ? 'split' : 'edit') . ' term://' . s:fnameescape(s:UserCommand(options, args)) . assign . '|startinsert' . after
                                elseif has('terminal')
                                  if &autowrite || &autowriteall | silent! wall | endif
                                  return 'exe ' . string(mods . 'terminal ' . (a:line2 ? '' : '++curwin ') . join(map(s:UserCommandList(options) + args, 's:fnameescape(v:val)'))) . assign . after
                                endif
                              endif
                              if s:RunJobs()
                                let state = { 'dir': dir, 'mods': s:Mods(a:mods), 'title': ':Git ' . a:arg, 'echo_buffer': '', 'escape_buffer': '', 'log': [], 'temp': tempname()}
                                let state.pty = get(g:, 'fugitive_pty', has('unix') && (has('patch-8.0.0744') || has('nvim')))
                                if !state.pty
                                  let args = s:AskPassArgs(dir) + args
                                endif
                                let env.FUGITIVE_TEMP = state.temp
                                let editor = 'sh ' . s:TempScript( '[ -f "$FUGITIVE_TEMP.exit" ] && exit 1', 'echo "$1" > "$FUGITIVE_TEMP.edit"', 'printf "\033]51;fugitive:edit\007"', 'while [ -f "$FUGITIVE_TEMP.edit" -a ! -f "$FUGITIVE_TEMP.exit" ]; do sleep 0.05 2>/dev/null || sleep 1; done', 'exit 0')
                                call extend(env, { 'NO_COLOR': '1', 'GIT_EDITOR': editor, 'GIT_SEQUENCE_EDITOR': editor, 'GIT_MERGE_AUTOEDIT': '1', 'GIT_PAGER': 'cat', 'PAGER': 'cat'}, 'keep')
                                let args = s:disable_colors + flags + ['-c', 'advice.waitingForEditor=false'] + args
                                let argv = s:UserCommandList({'git': git, 'dir': dir}) + args
                                let [argv, jobopts] = s:JobOpts(argv, env)
                                let state.cmd = argv
                                let g:_fugitive_last_job = state
                                if &autowrite || &autowriteall | silent! wall | endif
                                if exists('*job_start')
                                  call extend(jobopts, { 'mode': 'raw', 'callback': function('s:RunReceive', [state]), })
                                  if state.pty
                                    let jobopts.pty = 1
                                  endif
                                  let job = job_start(argv, jobopts)
                                else
                                  let job = jobstart(argv, extend(jobopts, { 'pty': state.pty, 'TERM': 'dumb', 'on_stdout': function('s:RunReceive', [state]), 'on_stderr': function('s:RunReceive', [state]), }))
                                endif
                                let state.job = job
                                call s:RunWait(state, job)
                                return 'silent checktime' . after
                              elseif has('win32')
                                return 'echoerr ' . string('fugitive: Vim 8 with job support required to use :Git on Windows')
                              elseif has('gui_running')
                                return 'echoerr ' . string('fugitive: Vim 8 with job support required to use :Git in GVim')
                              else
                                let pre = s:BuildEnvPrefix(env)
                                return 'exe ' . string('noautocmd !' . escape(pre . s:UserCommand(options, args), '!#%')) . '|call fugitive#ReloadStatus(' . string(dir) . ', 1)' . after
                              endif

FUNCTION  430()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:59
Called 15 times
Total time:   0.003349
 Self time:   0.001360

count  total (s)   self (s)
   15   0.000865   0.000207     if a:cmdline.is_input("<Over>(em-scroll-f)")
                                    call s:scroll(0)
                                    call a:cmdline.setchar('')
   15   0.000743   0.000192     elseif a:cmdline.is_input("<Over>(em-scroll-b)")
                                    call s:scroll(1)
                                    call a:cmdline.setchar('')
   15   0.000531   0.000134     elseif a:cmdline.is_input("<Over>(em-jumpback)")
                                    keepjumps call setpos('.', s:save_orig_pos)
                                    let s:orig_pos = s:save_orig_pos
                                    let s:orig_line_start = getpos('w0')
                                    let s:orig_line_end = getpos('w$')
                                    let s:direction = s:save_direction
                                    call a:cmdline.setchar('')
   15   0.000545   0.000162     elseif a:cmdline.is_input("<Over>(em-openallfold)")
                                    " TODO: better solution
                                    normal! zR
                                    call a:cmdline.setchar('')
   15              0.000017     endif

FUNCTION  <SNR>91_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:26
Called 1422 times
Total time:   0.022169
 Self time:   0.022169

count  total (s)   self (s)
 1422              0.010350   if index(a:list, a:name) == -1
 1364              0.006726     call add(a:list, a:name)
 1364              0.002071     return 1
   58              0.000048   else
   58              0.000207     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
   58              0.000041     endif
   58              0.000066     return 0
                              endif

FUNCTION  vital#_easymotion#Over#Commandline#Base#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:5
Called 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000042     return map({'_vital_depends': '', 'make_plain': '', 'is_input_waiting': '', 'make': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>26_defaults()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:319
Called 2 times
Total time:   0.008715
 Self time:   0.002254

count  total (s)   self (s)
    2              0.000169   let rules = copy(get(g:, 'fzf_colors', {}))
    2   0.008078   0.001888   let colors = join(map(items(filter(map(rules, 'call("s:get_color", v:val)'), '!empty(v:val)')), 'join(v:val, ":")'), ',')
    2   0.000428   0.000156   return empty(colors) ? '' : fzf#shellescape('--color='.colors)

FUNCTION  432()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:123
Called 1 time
Total time:   0.004110
 Self time:   0.000426

count  total (s)   self (s)
    1              0.000003     if s:num_strokes == -1
    1   0.000120   0.000016         call EasyMotion#highlight#delete_highlight()
    1   0.003871   0.000362         call EasyMotion#helper#VarReset('&scrolloff', 0)
    1              0.000002         if g:EasyMotion_do_shade
    1   0.000075   0.000018             call EasyMotion#highlight#add_highlight('\_.*', g:EasyMotion_hl_group_shade)
    1              0.000001         endif
    1              0.000001     endif
    1              0.000003     if g:EasyMotion_cursor_highlight
    1   0.000031   0.000016         call EasyMotion#highlight#add_highlight('\%#', g:EasyMotion_hl_inc_cursor)
    1              0.000001     endif

FUNCTION  airline#extensions#fzf#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:37
Called 22 times
Total time:   0.000408
 Self time:   0.000408

count  total (s)   self (s)
   22              0.000138   if getbufvar(a:2.bufnr, '&filetype') ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
   22              0.000017   endif

FUNCTION  375()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:88
Called 77 times
Total time:   0.052626
 Self time:   0.001640

count  total (s)   self (s)
   77   0.052566   0.001581 	let self.variables.slots = s:L.sort_by(self.variables.slots, a:expr)

FUNCTION  <SNR>91_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:93
Called 1555 times
Total time:   0.036124
 Self time:   0.036124

count  total (s)   self (s)
 1555              0.012363   if !hlexists(a:group)
                                return 0
 1555              0.013760   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
 1555              0.001067   endif
 1555              0.001718   return 1

FUNCTION  EasyMotionCoc()
    Defined: ~/.config/nvim/init.vim:201
Called 67 times
Total time:   0.009494
 Self time:   0.008721

count  total (s)   self (s)
   67   0.007042   0.006269     if EasyMotion#is_active()
                                    let g:easymotion#is_active = 1
                                    silent! CocDisable
   67              0.000125     else
   67              0.000263         if g:easymotion#is_active == 1
                                        let g:easymotion#is_active = 0
                                        silent! CocEnable
   67              0.000083         endif
   67              0.000065     endif

FUNCTION  coc#float#close_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:773
Called 3 times
Total time:   0.000489
 Self time:   0.000345

count  total (s)   self (s)
    3   0.000238   0.000094   if !coc#float#valid(a:winid)
                                return
    3              0.000004   endif
    3              0.000042   let timer = getwinvar(a:winid, 'timer', 0)
    3              0.000007   if timer
                                call timer_stop(timer)
    3              0.000003   endif
    3              0.000022   let kind = get(a:, 1, '')
    3              0.000020   let winids = getwinvar(a:winid, 'related', [])
    3              0.000012   for id in winids
                                if s:is_vim
                                  " vim doesn't throw
                                  call popup_close(id)
                                elseif nvim_win_is_valid(id)
                                  if empty(kind) || getwinvar(id, 'kind', '') ==# kind
                                    noa call nvim_win_close(id, 1)
                                  endif
                                endif
    3              0.000008   endfor

FUNCTION  <SNR>110_RunBufDelete()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:2412
Called 4 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
    4              0.000037   if has_key(s:edit_jobs, a:bufnr) |
                                call add(s:resume_queue, remove(s:edit_jobs, a:bufnr))
                                call feedkeys(":redraw!|call fugitive#Resume()|silent checktime\r", 'n')
    4              0.000007   endif

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:102
Called 1865 times
Total time:   1.041702
 Self time:   0.244402

count  total (s)   self (s)
 1865              0.005882   if pumvisible()
                                return
 1865              0.001414   endif
 1865              0.006627   let colors = a:colors
 1865              0.003400   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
 1865              0.001536   endif
 1865   0.674524   0.048303   let old_hi = airline#highlighter#get_highlight(a:group)
 1865              0.006976   if len(colors) == 4
  473              0.001890     call add(colors, '')
 1865              0.001690   endif
 1865              0.026243   let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
 1865   0.117722   0.035025   let colors = s:CheckDefined(colors)
 1865   0.069361   0.033238   if old_hi != new_hi || !s:hl_group_exists(a:group)
  310   0.058254   0.005996     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
  310              0.005577     exe cmd
  310              0.001555     if has_key(s:hl_groups, a:group)
  310              0.001331       let s:hl_groups[a:group] = colors
  310              0.000265     endif
 1865              0.001157   endif

FUNCTION  299()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:116
Called 15 times
Total time:   0.000170
 Self time:   0.000130

count  total (s)   self (s)
   15   0.000160   0.000120 	return self.line.pos()

FUNCTION  <SNR>128__dot_to_sharp()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:235
Called 27 times
Total time:   0.000392
 Self time:   0.000392

count  total (s)   self (s)
   27              0.000370   return substitute(a:name, '\.', '#', 'g')

FUNCTION  fugitive#Config()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:539
Called 8 times
Total time:   0.045593
 Self time:   0.001499

count  total (s)   self (s)
    8   0.000779   0.000111   let dir = s:Dir()
    8              0.000013   let name = ''
    8              0.000033   if a:0 >= 2 && type(a:2) == type({})
    5              0.000135     let name = substitute(a:1, '^[^.]\+\|[^.]\+$', '\L&', 'g')
    5              0.000038     return len(a:1) ? get(get(a:2, name, []), 0, '') : a:2
    3              0.000004   elseif a:0 >= 2
                                let dir = a:2
                                let name = a:1
    3              0.000013   elseif a:0 == 1 && type(a:1) == type({})
                                return a:1
    3              0.000022   elseif a:0 == 1 && a:1 =~# '^[[:alnum:]-]\+\.'
    1              0.000002     let name = a:1
    2              0.000002   elseif a:0 == 1
    1              0.000002     let dir = a:1
    3              0.000002   endif
    3              0.000043   let name = substitute(name, '^[^.]\+\|[^.]\+$', '\L&', 'g')
    3              0.000013   let dir_key = len(dir) ? dir : '_'
    3   0.001481   0.000055   if has_key(s:config, dir_key) && s:config[dir_key][0] ==# s:ConfigTimestamps(dir, s:config[dir_key][1])
    2              0.000013     let dict = s:config[dir_key][1]
    1              0.000001   else
    1              0.000002     let dict = {}
    1   0.041187   0.000034     let [lines, message, exec_error] = s:NullError([dir, 'config', '--list', '-z'])
    1              0.000002     if exec_error
                                  return {}
    1              0.000001     endif
   21              0.000031     for line in lines
   20              0.000185       let key = matchstr(line, "^[^\n]*")
   20              0.000065       if !has_key(dict, key)
   19              0.000055         let dict[key] = []
   20              0.000013       endif
   20              0.000081       if len(key) ==# len(line)
                                    call add(dict[key], 1)
   20              0.000012       else
   20              0.000133         call add(dict[key], strpart(line, len(key) + 1))
   20              0.000012       endif
   21              0.000019     endfor
    1   0.000878   0.000032     let s:config[dir_key] = [s:ConfigTimestamps(dir, dict), dict]
    1              0.000004     lockvar! dict
    3              0.000003   endif
    3              0.000028   return len(name) ? get(get(dict, name, []), 0, '') : dict

FUNCTION  fugitive#ReloadStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:2918
Called 5 times
Total time:   0.001234
 Self time:   0.000463

count  total (s)   self (s)
    5   0.000735   0.000153   call s:ExpireStatus(a:0 ? a:1 : -1)
    5              0.000018   if a:0 > 1 ? a:2 : 1
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
                                exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
    5              0.000007   else
    5   0.000277   0.000088     call s:ReloadWinStatus()
    5              0.000007   endif
    5              0.000009   return ''

FUNCTION  fugitive#GitVersion()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:234
Called 9 times
Total time:   0.016515
 Self time:   0.000702

count  total (s)   self (s)
    9              0.000045   if !has_key(s:git_versions, g:fugitive_git_executable)
    1   0.015915   0.000102     let s:git_versions[g:fugitive_git_executable] = matchstr(system(g:fugitive_git_executable.' --version'), '\d[^[:space:]]\+')
    9              0.000013   endif
    9              0.000012   if !a:0
                                return s:git_versions[g:fugitive_git_executable]
    9              0.000006   endif
    9              0.000160   let components = split(s:git_versions[g:fugitive_git_executable], '\D\+')
    9              0.000027   if empty(components)
                                return -1
    9              0.000006   endif
   12              0.000063   for i in range(len(a:000))
   11              0.000052     if a:000[i] > +get(components, i)
                                  return 0
   11              0.000043     elseif a:000[i] < +get(components, i)
    8              0.000011       return 1
    3              0.000002     endif
    4              0.000004   endfor
    1              0.000004   return a:000[i] ==# get(components, i)

FUNCTION  <SNR>130_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:121
Called 1 time
Total time:   0.000066
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000006 	let default = get(a:, 1, "")
    1              0.000016 	let result = deepcopy(s:base)
    1   0.000042   0.000008 	call result.set(default)
    1              0.000002 	return result

FUNCTION  <SNR>110_ChompError()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:455
Called 1 time
Total time:   0.047230
 Self time:   0.000120

count  total (s)   self (s)
    1   0.046955   0.000062   let [out, exec_error] = s:SystemError(call('fugitive#Prepare', a:000))
    1   0.000273   0.000055   return [s:sub(out, '\n$', ''), exec_error]

FUNCTION  <SNR>26_fzf_getcwd()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:102
Called 9 times
Total time:   0.000504
 Self time:   0.000166

count  total (s)   self (s)
    9   0.000497   0.000159   return s:fzf_call('getcwd')

FUNCTION  <SNR>97_check_mixed_indent_file()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:34
Called 3 times
Total time:   0.001548
 Self time:   0.001548

count  total (s)   self (s)
    3              0.000038   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    3              0.000023   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
    3              0.000004   else
    3              0.000009     let head_spc = '\v(^ +)'
    3              0.000003   endif
    3              0.000163   let indent_tabs = search('\v(^\t+)', 'nw')
    3              0.000126   let indent_spc  = search(head_spc, 'nw')
    3              0.001129   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
    3              0.000004   else
    3              0.000005     return ''
                              endif

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 54 times
Total time:   0.007054
 Self time:   0.005358

count  total (s)   self (s)
   54   0.006499   0.004945   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   54   0.000481   0.000339   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>245_nvim_untracked_job_handler()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:238
Called 3 times
Total time:   0.000400
 Self time:   0.000233

count  total (s)   self (s)
    3              0.000025     if a:event == 'exit'
    3   0.000252   0.000085       call s:untracked_output(self, self.buf)
    3              0.000039       if has_key(s:untracked_jobs, self.file)
    3              0.000039         call remove(s:untracked_jobs, self.file)
    3              0.000006       endif
    3              0.000002     endif

FUNCTION  <SNR>134_unmapping()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Keymapping.vim:73
Called 15 times
Total time:   0.002925
 Self time:   0.000673

count  total (s)   self (s)
   15              0.000077 	let is_locking = get(a:, 1, 0)
   15   0.001274   0.000186 	let key = s:match_key(a:keymapping, a:key)
   15              0.000035 	if key == ""
   15   0.001512   0.000347 		return s:String.length(a:key) <= 1 ? a:key : s:unmapping(a:keymapping, a:key[0], is_locking) . s:unmapping(a:keymapping, a:key[1:], is_locking)
                            	endif

                            	let map_conf = s:as_key_config(a:keymapping[key])

                            	let next_input = s:unmapping(a:keymapping, a:key[len(key) : ], is_locking)
                            	if map_conf.lock == 0 && is_locking
                            		return key . next_input
                            	elseif map_conf.lock
                            		return s:unmapping(a:keymapping, s:_get_key(map_conf), is_locking) . next_input
                            	else
                            		return s:unmapping(a:keymapping, s:_get_key(map_conf), map_conf.noremap) . next_input
                            	endif

FUNCTION  jsx_pretty#comment#update_commentstring()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/jsx_pretty/comment.vim:5
Called 51 times
Total time:   0.047316
 Self time:   0.012203

count  total (s)   self (s)
   51              0.000640   let line = getline(".")
   51              0.000398   let col = col('.')
   51              0.001479   if line !~# '^\s*$' && line[: col - 1] =~# '^\s*$'    " skip indent
   11              0.000070     let col = indent('.') + 1
   51              0.000064   endif
   51   0.022994   0.001495   let syn_start = s:syn_name(line('.'), col)
   51              0.000754   let save_cursor = getcurpos()

   51              0.000511   if syn_start =~? '^jsx'
   17              0.000150     if line =~ '^\s*//'
                                  let &l:commentstring = '// %s'
   17   0.016671   0.003057     elseif s:syn_contains(line('.'), col, 'jsxTaggedRegion')
                                  let &l:commentstring = '<!-- %s -->'
   17              0.000246     elseif syn_start =~? '^jsxAttrib'
    7              0.000092       let &l:commentstring = '// %s'
   10              0.000016     else
   10              0.000198       let &l:commentstring = '{/* %s */}'
   17              0.000024     endif
   34              0.000031   else
   34              0.000734     let &l:commentstring = a:original
   51              0.000071   endif

                              " Restore the cursor position
   51              0.000400   call setpos('.', save_cursor)

FUNCTION  <SNR>245_valid_dir()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:50
Called 16 times
Total time:   0.000497
 Self time:   0.000497

count  total (s)   self (s)
   16              0.000341   if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
   16              0.000018   endif
   16              0.000035   return a:dir

FUNCTION  <SNR>57_unc_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:169
Called 5 times
Total time:   0.001364
 Self time:   0.000167

count  total (s)   self (s)
    5   0.001357   0.000160   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  vital#_easymotion#Over#Commandline#Modules#Paste#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Paste.vim:5
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>246_is_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:277
Called 28 times
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
   28              0.000120   return a:from_count > 0 && a:to_count == 0

FUNCTION  374()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:83
Called 17 times
Total time:   0.001067
 Self time:   0.000247

count  total (s)   self (s)
   17   0.001053   0.000233 	return get(self.find_by(a:expr), 0, {})

FUNCTION  <SNR>110_DirCheck()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:85
Called 1 time
Total time:   0.000079
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000077   0.000011   if !empty(a:0 ? s:Dir(a:1) : s:Dir())
    1              0.000001     return ''
                              elseif empty(bufname(''))
                                return 'return ' . string('echoerr "fugitive: working directory does not belong to a Git repository"')
                              else
                                return 'return ' . string('echoerr "fugitive: file does not belong to a Git repository"')
                              endif

FUNCTION  <SNR>57_is_file_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:63
Called 65 times
Total time:   0.001333
 Self time:   0.001333

count  total (s)   self (s)
   65              0.001207   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 5 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
    5              0.000088   return has('win64') || has('win32') || has('win16')

FUNCTION  fzf#wrap()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:341
Called 2 times
Total time:   0.011878
 Self time:   0.001695

count  total (s)   self (s)
    2              0.000012   let args = ['', {}, 0]
    2              0.000041   let expects = map(copy(args), 'type(v:val)')
    2              0.000004   let tidx = 0
    8              0.000025   for arg in copy(a:000)
    6              0.000061     let tidx = index(expects, type(arg) == 6 ? type(0) : type(arg), tidx)
    6              0.000013     if tidx < 0
                                  throw 'Invalid arguments (expected: [name string] [opts dict] [fullscreen boolean])'
    6              0.000006     endif
    6              0.000020     let args[tidx] = arg
    6              0.000014     let tidx += 1
    6              0.000011     unlet arg
    8              0.000012   endfor
    2              0.000011   let [name, opts, bang] = args

    2              0.000008   if len(name)
    2              0.000007     let opts.name = name
    2              0.000002   end

                              " Layout: g:fzf_layout (and deprecated g:fzf_height)
    2              0.000003   if bang
                                for key in s:layout_keys
                                  if has_key(opts, key)
                                    call remove(opts, key)
                                  endif
                                endfor
    2   0.000186   0.000046   elseif !s:has_any(opts, s:layout_keys)
    2              0.000017     if !exists('g:fzf_layout') && exists('g:fzf_height')
                                  let opts.down = g:fzf_height
    2              0.000002     else
    2   0.001806   0.000686       let opts = extend(opts, s:validate_layout(get(g:, 'fzf_layout', s:default_layout())))
    2              0.000009     endif
    2              0.000003   endif

                              " Colors: g:fzf_colors
    2   0.009002   0.000243   let opts.options = s:defaults() .' '. s:evaluate_opts(get(opts, 'options', ''))

                              " History: g:fzf_history_dir
    2              0.000026   if len(name) && len(get(g:, 'fzf_history_dir', ''))
                                let dir = s:fzf_expand(g:fzf_history_dir)
                                if !isdirectory(dir)
                                  call mkdir(dir, 'p')
                                endif
                                let history = fzf#shellescape(dir.'/'.name)
                                let opts.options = join(['--history', history, opts.options])
    2              0.000003   endif

                              " Action: g:fzf_action
    2   0.000221   0.000057   if !s:has_any(opts, ['sink', 'sink*'])
    2              0.000055     let opts._action = get(g:, 'fzf_action', s:default_action)
    2              0.000040     let opts.options .= ' --expect='.join(keys(opts._action), ',')
    2              0.000014     function! opts.sink(lines) abort
                                  return s:common_sink(self._action, a:lines)
                                endfunction
    2              0.000023     let opts['sink*'] = remove(opts, 'sink')
    2              0.000003   endif

    2              0.000005   return opts

FUNCTION  <SNR>110_ExpandSplit()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1143
Called 1 time
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000002   let list = []
    1              0.000002   let string = a:string
    1              0.000003   let handle_bar = a:0 && a:1
    1              0.000003   let dquote = handle_bar ? '"\%([^"]\|""\|\\"\)*"\|' : ''
    1              0.000003   let cwd = a:0 > 1 ? a:2 : getcwd()
    1              0.000006   while string =~# '\S'
                                if handle_bar && string =~# '^\s*|'
                                  return [list, substitute(string, '^\s*', '', '')]
                                endif
                                let arg = matchstr(string, '^\s*\%(' . dquote . '''[^'']*''\|\\.\|[^[:space:] ' . (handle_bar ? '|' : '') . ']\)\+')
                                let string = strpart(string, len(arg))
                                let arg = substitute(arg, '^\s\+', '', '')
                                if !exists('seen_separator')
                                  let arg = substitute(arg, '^\%([^:.][^:]*:\|^:\|^:[0-3]:\)\=\zs\.\.\=\%(/.*\)\=$', '\=s:DotRelative(s:Slash(simplify(getcwd() . "/" . submatch(0))), cwd)', '')
                                endif
                                let arg = substitute(arg, '\(' . dquote . '''\%(''''\|[^'']\)*''\|\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand, '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),submatch(5), cwd)', 'g')
                                call add(list, arg)
                                if arg ==# '--'
                                  let seen_separator = 1
                                endif
    1              0.000003   endwhile
    1              0.000003   return handle_bar ? [list, ''] : list

FUNCTION  fugitive#MapJumps()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:5964
Called 1 time
Total time:   0.041994
 Self time:   0.001832

count  total (s)   self (s)
    1              0.000002   if !&modifiable
    1              0.000005     if get(b:, 'fugitive_type', '') ==# 'blob'
                                  let blame_map = 'Git blame<C-R>=v:count ? " --reverse" : ""<CR><CR>'
                                  call s:Map('n', '<2-LeftMouse>', ':<C-U>0,1' . blame_map, '<silent>')
                                  call s:Map('n', '<CR>', ':<C-U>0,1' . blame_map, '<silent>')
                                  call s:Map('n', 'o',    ':<C-U>0,2' . blame_map, '<silent>')
                                  call s:Map('n', 'p',    ':<C-U>0,3' . blame_map, '<silent>')
                                  call s:Map('n', 'gO',   ':<C-U>0,4' . blame_map, '<silent>')
                                  call s:Map('n', 'O',    ':<C-U>0,5' . blame_map, '<silent>')

                                  call s:Map('n', 'D',  ":<C-U>call fugitive#DiffClose()<Bar>Gdiffsplit!<Bar>redraw<Bar>echohl WarningMsg<Bar> echo ':Gstatus D is deprecated in favor of dd'<Bar>echohl NONE<CR>", '<silent>')
                                  call s:Map('n', 'dd', ":<C-U>call fugitive#DiffClose()<Bar>Gdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'dh', ":<C-U>call fugitive#DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'ds', ":<C-U>call fugitive#DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'dv', ":<C-U>call fugitive#DiffClose()<Bar>Gvdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'd?', ":<C-U>help fugitive_d<CR>", '<silent>')

    1              0.000001     else
    1   0.000283   0.000022       call s:Map('n', '<2-LeftMouse>', ':<C-U>exe <SID>GF("edit")<CR>', '<silent>')
    1   0.000292   0.000052       call s:Map('n', '<CR>', ':<C-U>exe <SID>GF("edit")<CR>', '<silent>')
    1   0.000200   0.000017       call s:Map('n', 'o',    ':<C-U>exe <SID>GF("split")<CR>', '<silent>')
    1   0.000218   0.000014       call s:Map('n', 'gO',   ':<C-U>exe <SID>GF("vsplit")<CR>', '<silent>')
    1   0.000186   0.000014       call s:Map('n', 'O',    ':<C-U>exe <SID>GF("tabedit")<CR>', '<silent>')
    1   0.000183   0.000013       call s:Map('n', 'p',    ':<C-U>exe <SID>GF("pedit")<CR>', '<silent>')

    1              0.000004       if !exists('g:fugitive_no_maps')
    1              0.000010         if exists(':CtrlP') && get(g:, 'ctrl_p_map') =~? '^<c-p>$'
                                      nnoremap <buffer> <silent> <C-P> :<C-U>execute line('.') == 1 ? 'CtrlP ' . fnameescape(<SID>Tree()) : <SID>PreviousItem(v:count1)<CR>
    1              0.000001         else
    1              0.000026           nnoremap <buffer> <silent> <C-P> :<C-U>execute <SID>PreviousItem(v:count1)<CR>
    1              0.000001         endif
    1              0.000017         nnoremap <buffer> <silent> <C-N> :<C-U>execute <SID>NextItem(v:count1)<CR>
    1              0.000001       endif
    1   0.002888   0.000088       call s:MapMotion('(', 'exe <SID>PreviousItem(v:count1)')
    1   0.006638   0.000073       call s:MapMotion(')', 'exe <SID>NextItem(v:count1)')
    1   0.001624   0.000039       call s:MapMotion('K', 'exe <SID>PreviousHunk(v:count1)')
    1   0.002533   0.000041       call s:MapMotion('J', 'exe <SID>NextHunk(v:count1)')
    1   0.001889   0.000021       call s:MapMotion('[c', 'exe <SID>PreviousHunk(v:count1)')
    1   0.000694   0.000026       call s:MapMotion(']c', 'exe <SID>NextHunk(v:count1)')
    1   0.000627   0.000012       call s:MapMotion('[/', 'exe <SID>PreviousFile(v:count1)')
    1   0.001237   0.000019       call s:MapMotion(']/', 'exe <SID>NextFile(v:count1)')
    1   0.000876   0.000042       call s:MapMotion('[m', 'exe <SID>PreviousFile(v:count1)')
    1   0.000795   0.000016       call s:MapMotion(']m', 'exe <SID>NextFile(v:count1)')
    1   0.000797   0.000016       call s:MapMotion('[[', 'exe <SID>PreviousSection(v:count1)')
    1   0.000625   0.000012       call s:MapMotion(']]', 'exe <SID>NextSection(v:count1)')
    1   0.000613   0.000011       call s:MapMotion('[]', 'exe <SID>PreviousSectionEnd(v:count1)')
    1   0.000610   0.000011       call s:MapMotion('][', 'exe <SID>NextSectionEnd(v:count1)')
    1   0.000426   0.000013       call s:Map('nxo', '*', '<SID>PatchSearchExpr(0)', '<expr>')
    1   0.000371   0.000013       call s:Map('nxo', '#', '<SID>PatchSearchExpr(1)', '<expr>')
    1              0.000001     endif
    1   0.000168   0.000012     call s:Map('n', 'S',    ':<C-U>echoerr "Use gO"<CR>', '<silent>')
    1   0.000195   0.000012     call s:Map('n', 'dq', ":<C-U>call fugitive#DiffClose()<CR>", '<silent>')
    1   0.000181   0.000016     call s:Map('n', '-', ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>NavigateUp(v:count1))<Bar> if getline(1) =~# '^tree \x\{40,\}$' && empty(getline(2))<Bar>call search('^'.escape(expand('#:t'),'.*[]~\').'/\=$','wc')<Bar>endif<CR>", '<silent>')
    1   0.000264   0.000015     call s:Map('n', 'P',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'^'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
    1   0.000250   0.000023     call s:Map('n', '~',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'~'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
    1   0.000199   0.000019     call s:Map('n', 'C',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
    1   0.000204   0.000014     call s:Map('n', 'cp',    ":<C-U>echoerr 'Use gC'<CR>", '<silent>')
    1   0.000202   0.000013     call s:Map('n', 'gC',    ":<C-U>exe 'Gpedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
    1   0.000207   0.000013     call s:Map('n', 'gc',    ":<C-U>exe 'Gpedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
    1   0.000200   0.000014     call s:Map('n', 'gi',    ":<C-U>exe 'Gsplit' (v:count ? '.gitignore' : '.git/info/exclude')<CR>", '<silent>')
    1   0.000198   0.000013     call s:Map('x', 'gi',    ":<C-U>exe 'Gsplit' (v:count ? '.gitignore' : '.git/info/exclude')<CR>", '<silent>')

    1   0.000254   0.000012     call s:Map('n', 'c<Space>', ':Git commit<Space>')
    1   0.000196   0.000012     call s:Map('n', 'c<CR>', ':Git commit<CR>')
    1   0.000224   0.000012     call s:Map('n', 'cv<Space>', ':tab Git commit -v<Space>')
    1   0.000222   0.000012     call s:Map('n', 'cv<CR>', ':tab Git commit -v<CR>')
    1   0.000195   0.000012     call s:Map('n', 'ca', ':<C-U>Git commit --amend<CR>', '<silent>')
    1   0.000193   0.000012     call s:Map('n', 'cc', ':<C-U>Git commit<CR>', '<silent>')
    1   0.000195   0.000012     call s:Map('n', 'ce', ':<C-U>Git commit --amend --no-edit<CR>', '<silent>')
    1   0.000194   0.000012     call s:Map('n', 'cw', ':<C-U>Git commit --amend --only<CR>', '<silent>')
    1   0.000221   0.000012     call s:Map('n', 'cva', ':<C-U>tab Git commit -v --amend<CR>', '<silent>')
    1   0.000269   0.000012     call s:Map('n', 'cvc', ':<C-U>tab Git commit -v<CR>', '<silent>')
    1   0.000225   0.000013     call s:Map('n', 'cRa', ':<C-U>Git commit --reset-author --amend<CR>', '<silent>')
    1   0.000225   0.000013     call s:Map('n', 'cRe', ':<C-U>Git commit --reset-author --amend --no-edit<CR>', '<silent>')
    1   0.000224   0.000013     call s:Map('n', 'cRw', ':<C-U>Git commit --reset-author --amend --only<CR>', '<silent>')
    1   0.000195   0.000012     call s:Map('n', 'cf', ':<C-U>Git commit --fixup=<C-R>=<SID>SquashArgument()<CR>')
    1   0.000205   0.000014     call s:Map('n', 'cF', ':<C-U><Bar>Git -c sequence.editor=true rebase --interactive --autosquash<C-R>=<SID>RebaseArgument()<CR><Home>Git commit --fixup=<C-R>=<SID>SquashArgument()<CR>')
    1   0.000195   0.000012     call s:Map('n', 'cs', ':<C-U>Git commit --no-edit --squash=<C-R>=<SID>SquashArgument()<CR>')
    1   0.000207   0.000013     call s:Map('n', 'cS', ':<C-U><Bar>Git -c sequence.editor=true rebase --interactive --autosquash<C-R>=<SID>RebaseArgument()<CR><Home>Git commit --no-edit --squash=<C-R>=<SID>SquashArgument()<CR>')
    1   0.000195   0.000012     call s:Map('n', 'cA', ':<C-U>Git commit --edit --squash=<C-R>=<SID>SquashArgument()<CR>')
    1   0.000191   0.000012     call s:Map('n', 'c?', ':<C-U>help fugitive_c<CR>', '<silent>')

    1   0.000273   0.000011     call s:Map('n', 'cr<Space>', ':Git revert<Space>')
    1   0.000223   0.000011     call s:Map('n', 'cr<CR>', ':Git revert<CR>')
    1   0.000232   0.000013     call s:Map('n', 'crc', ':<C-U>Git revert <C-R>=<SID>SquashArgument()<CR><CR>', '<silent>')
    1   0.000250   0.000014     call s:Map('n', 'crn', ':<C-U>Git revert --no-commit <C-R>=<SID>SquashArgument()<CR><CR>', '<silent>')
    1   0.000244   0.000013     call s:Map('n', 'cr?', ':<C-U>help fugitive_cr<CR>', '<silent>')

    1   0.000245   0.000012     call s:Map('n', 'cm<Space>', ':Git merge<Space>')
    1   0.000242   0.000012     call s:Map('n', 'cm<CR>', ':Git merge<CR>')
    1   0.000240   0.000012     call s:Map('n', 'cmt', ':Git mergetool')
    1   0.000278   0.000058     call s:Map('n', 'cm?', ':<C-U>help fugitive_cm<CR>', '<silent>')

    1   0.000226   0.000012     call s:Map('n', 'cz<Space>', ':Git stash<Space>')
    1   0.000327   0.000015     call s:Map('n', 'cz<CR>', ':Git stash<CR>')
    1   0.000283   0.000025     call s:Map('n', 'cza', ':<C-U>Git stash apply --quiet --index stash@{<C-R>=v:count<CR>}<CR>')
    1   0.000236   0.000016     call s:Map('n', 'czA', ':<C-U>Git stash apply --quiet stash@{<C-R>=v:count<CR>}<CR>')
    1   0.000231   0.000014     call s:Map('n', 'czp', ':<C-U>Git stash pop --quiet --index stash@{<C-R>=v:count<CR>}<CR>')
    1   0.000228   0.000013     call s:Map('n', 'czP', ':<C-U>Git stash pop --quiet stash@{<C-R>=v:count<CR>}<CR>')
    1   0.000228   0.000014     call s:Map('n', 'czv', ':<C-U>exe "Gedit" fugitive#RevParse("stash@{" . v:count . "}")<CR>', '<silent>')
    1   0.000317   0.000015     call s:Map('n', 'czw', ':<C-U>Git stash --keep-index<C-R>=v:count > 1 ? " --all" : v:count ? " --include-untracked" : ""<CR><CR>')
    1   0.000248   0.000016     call s:Map('n', 'czz', ':<C-U>Git stash <C-R>=v:count > 1 ? " --all" : v:count ? " --include-untracked" : ""<CR><CR>')
    1   0.000241   0.000014     call s:Map('n', 'cz?', ':<C-U>help fugitive_cz<CR>', '<silent>')

    1   0.000243   0.000013     call s:Map('n', 'co<Space>', ':Git checkout<Space>')
    1   0.000239   0.000013     call s:Map('n', 'co<CR>', ':Git checkout<CR>')
    1   0.000242   0.000013     call s:Map('n', 'coo', ':<C-U>Git checkout <C-R>=<SID>SquashArgument()<CR> --<CR>')
    1   0.000239   0.000013     call s:Map('n', 'co?', ':<C-U>help fugitive_co<CR>', '<silent>')

    1   0.000291   0.000013     call s:Map('n', 'cb<Space>', ':Git branch<Space>')
    1   0.000237   0.000013     call s:Map('n', 'cb<CR>', ':Git branch<CR>')
    1   0.000236   0.000013     call s:Map('n', 'cb?', ':<C-U>help fugitive_cb<CR>', '<silent>')

    1   0.000209   0.000012     call s:Map('n', 'r<Space>', ':Git rebase<Space>')
    1   0.000242   0.000016     call s:Map('n', 'r<CR>', ':Git rebase<CR>')
    1   0.000234   0.000023     call s:Map('n', 'ri', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><CR>', '<silent>')
    1   0.000215   0.000015     call s:Map('n', 'rf', ':<C-U>Git -c sequence.editor=true rebase --interactive --autosquash<C-R>=<SID>RebaseArgument()<CR><CR>', '<silent>')
    1   0.000210   0.000013     call s:Map('n', 'ru', ':<C-U>Git rebase --interactive @{upstream}<CR>', '<silent>')
    1   0.000207   0.000013     call s:Map('n', 'rp', ':<C-U>Git rebase --interactive @{push}<CR>', '<silent>')
    1   0.000212   0.000014     call s:Map('n', 'rw', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/reword/e<CR>', '<silent>')
    1   0.000276   0.000014     call s:Map('n', 'rm', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/edit/e<CR>', '<silent>')
    1   0.000228   0.000016     call s:Map('n', 'rd', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>', '<silent>')
    1   0.000228   0.000015     call s:Map('n', 'rk', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>', '<silent>')
    1   0.000227   0.000015     call s:Map('n', 'rx', ':<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>', '<silent>')
    1   0.000221   0.000013     call s:Map('n', 'rr', ':<C-U>Git rebase --continue<CR>', '<silent>')
    1   0.000222   0.000014     call s:Map('n', 'rs', ':<C-U>Git rebase --skip<CR>', '<silent>')
    1   0.000220   0.000013     call s:Map('n', 're', ':<C-U>Git rebase --edit-todo<CR>', '<silent>')
    1   0.000228   0.000013     call s:Map('n', 'ra', ':<C-U>Git rebase --abort<CR>', '<silent>')
    1   0.000222   0.000013     call s:Map('n', 'r?', ':<C-U>help fugitive_r<CR>', '<silent>')

    1   0.000194   0.000014     call s:Map('n', '.',     ":<C-U> <C-R>=<SID>fnameescape(fugitive#Real(@%))<CR><Home>")
    1   0.000195   0.000014     call s:Map('x', '.',     ":<C-U> <C-R>=<SID>fnameescape(fugitive#Real(@%))<CR><Home>")
    1   0.000222   0.000013     call s:Map('n', 'g?',    ":<C-U>help fugitive-map<CR>", '<silent>')
    1   0.000200   0.000014     call s:Map('n', '<F1>',  ":<C-U>help fugitive-map<CR>", '<silent>')
    1              0.000001   endif

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:67
Called 241 times
Total time:   0.013256
 Self time:   0.013256

count  total (s)   self (s)
  241              0.005986   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  241              0.001028   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
  241              0.000432   endif
  241              0.000335   return ''

FUNCTION  402()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:76
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000007 	let self.cword = expand("<cword>")
    1              0.000004 	let self.cWORD = expand("<cWORD>")
    1              0.000006 	let self.cfile = expand("<cfile>")

FUNCTION  403()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:82
Called 1 time
Total time:   0.000028
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000027   0.000008 	call self.reset()
                            " 	let self.prefix_key = ""

FUNCTION  405()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:143
Called 15 times
Total time:   0.001065
 Self time:   0.000594

count  total (s)   self (s)
   15   0.000654   0.000183 	if a:cmdline.is_input("\<C-r>")
                            		call a:cmdline.tap_keyinput(self.prefix_key)
                            		call a:cmdline.disable_keymapping()
                            		call a:cmdline.setpos(a:cmdline.getpos()-1)
   15              0.000014 	else
   15              0.000062 		if exists("self.prefix_key")
                            			call a:cmdline.untap_keyinput(self.prefix_key)
                            			call a:cmdline.enable_keymapping()
                            			unlet! self.prefix_key
   15              0.000012 		endif
   15              0.000011 	endif

FUNCTION  408()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionMessage.vim:35
Called 15 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
   15              0.000052 	if has_key(self, "exception")
                            		call self.message(a:cmdline)
                            		unlet self.exception
   15              0.000011 	endif

FUNCTION  vital#_easymotion#Palette#Highlight#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:5
Called 1 time
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    1              0.000057     return map({'capture': '', '_vital_depends': '', 'parse': '', 'group_list': '', 'set': '', 'parse_to_name': '', 'links_to': '', 'get': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  fzf#shellescape()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:94
Called 18 times
Total time:   0.001165
 Self time:   0.000937

count  total (s)   self (s)
   18              0.000185   let shell = get(a:000, 0, s:is_win ? 'cmd.exe' : 'sh')
   18              0.000215   if shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
   18              0.000024   endif
   18   0.000579   0.000352   return s:fzf_call('shellescape', a:arg)

FUNCTION  FugitiveGitPath()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:309
Called 3 times
Total time:   0.000118
 Self time:   0.000082

count  total (s)   self (s)
    3   0.000114   0.000078   return s:Slash(a:path)

FUNCTION  <SNR>129_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:49
Called 1 time
Total time:   0.000203
 Self time:   0.000104

count  total (s)   self (s)
    1              0.000077 	let result = deepcopy(s:base)
    1   0.000019   0.000014 	call result.set_prompt(get(a:, 1, ":"))
    1   0.000104   0.000009 	call result.connect(result, "_")
    1              0.000001 	return result

FUNCTION  <SNR>103_get_accented_line()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:163
Called 189 times
Total time:   0.018807
 Self time:   0.018807

count  total (s)   self (s)
  189              0.000615   if a:self._context.active
                                " active window
  113              0.000369     let contents = []
  113              0.002987     let content_parts = split(a:contents, '__accent')
  245              0.000651     for cpart in content_parts
  132              0.003399       let accent = matchstr(cpart, '_\zs[^#]*\ze')
  132              0.000827       call add(contents, cpart)
  245              0.000394     endfor
  113              0.000938     let line = join(contents, a:group)
  113              0.001410     let line = substitute(line, '__restore__', a:group, 'g')
   76              0.000070   else
                                " inactive window
   76              0.001695     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   76              0.000848     let line = substitute(line, '%#__restore__#', '', 'g')
  189              0.000195   endif
  189              0.000367   return line

FUNCTION  335()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:359
Called 45 times
Total time:   0.000172
 Self time:   0.000172

count  total (s)   self (s)
   45              0.000139 	return self.variables.input_key_stack

FUNCTION  <SNR>136_parse()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:57
Called 1 time
Total time:   0.000394
 Self time:   0.000361

count  total (s)   self (s)
    1              0.000004 	let highlight = a:highlight

    1              0.000013 	if highlight !~# '^\w\+\s\+xxx\s'
                            		return {}
    1              0.000001 	endif

    1   0.000025   0.000013 	let name = s:parse_to_name(a:highlight)
    1              0.000005 	let result = { "_name" : name }

    1              0.000064 	if highlight =~# '^\w\+\s\+xxx cleared'
                            		let result.cleared = 1
                            		return result
    1              0.000001 	endif

    1   0.000034   0.000013 	let link = s:links_to(highlight)
    1              0.000003 	if link != ""
                            		let result.link = link
                            		return result
    1              0.000001 	endif

    1              0.000007 	let attrs = [		"term",		"cterm",		"ctermfg",		"ctermbg",		"gui",		"font",		"guifg",		"guibg",		"guisp",	]
   10              0.000015 	for attr in attrs
    9              0.000143 		let item = matchstr(highlight, '\s' . attr . '=\zs#\?\w\+\ze')
    9              0.000017 		if item != ""
    2              0.000008 			let result[attr] = item
    9              0.000006 		endif
   10              0.000009 	endfor
    1              0.000002 	return result

FUNCTION  <SNR>26_popup_support()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:125
Called 4 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
    4              0.000129   return has('nvim') ? has('nvim-0.4') : has('popupwin') && has('patch-8.2.191')

FUNCTION  <SNR>128__get_module()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:184
Called 27 times
Total time:   0.064928
 Self time:   0.002502

count  total (s)   self (s)
   27   0.002133   0.001009   let funcname = s:_import_func_name(self.plugin_name(), a:name)
   27   0.060742   0.000568   if s:_exists_autoload_func_with_source(funcname)
   27   0.001989   0.000861     return call(funcname, [])
                              else
                                return s:_get_builtin_module(a:name)
                              endif

FUNCTION  <SNR>21_CeilingDirectories()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:198
Called 50 times
Total time:   0.002099
 Self time:   0.002099

count  total (s)   self (s)
   50              0.000281   if !exists('s:ceiling_directories')
                                let s:ceiling_directories = []
                                let resolve = 1
                                for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
                                  if empty(dir)
                                    let resolve = 0
                                  elseif resolve
                                    call add(s:ceiling_directories, resolve(dir))
                                  else
                                    call add(s:ceiling_directories, dir)
                                  endif
                                endfor
   50              0.000042   endif
   50              0.000351   return s:ceiling_directories + get(g:, 'ceiling_directories', [])

FUNCTION  201()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:293
Called 1 time
Total time:   0.029642
 Self time:   0.000401

count  total (s)   self (s)

                                " Options for a non-file/control buffer.
    1   0.000009   0.000008     setlocal bufhidden=hide
    1   0.000006   0.000005     setlocal buftype=nofile
    1   0.000006   0.000006     setlocal noswapfile

                                " Options for controlling buffer/window appearance.
    1   0.000007   0.000005     setlocal foldcolumn=0
    1   0.000005   0.000005     setlocal foldmethod=manual
    1   0.000082   0.000006     setlocal nobuflisted
    1   0.000005   0.000004     setlocal nofoldenable
    1   0.000004   0.000004     setlocal nolist
    1   0.000004   0.000004     setlocal nospell
    1   0.000005   0.000003     setlocal nowrap

    1              0.000002     if g:NERDTreeShowLineNumbers
                                    setlocal number
    1              0.000001     else
    1   0.000005   0.000004         setlocal nonumber
    1              0.000002         if v:version >= 703
    1   0.000010   0.000007             setlocal norelativenumber
    1              0.000001         endif
    1              0.000001     endif

    1              0.000002     iabc <buffer>

    1              0.000002     if g:NERDTreeHighlightCursorline
    1   0.000006   0.000004         setlocal cursorline
    1              0.000001     endif

    1   0.000025   0.000009     call self._setupStatusline()
    1   0.004116   0.000008     call self._bindMappings()

    1   0.025320   0.000294     setlocal filetype=nerdtree

FUNCTION  202()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:331
Called 1 time
Total time:   0.000016
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000003     if g:NERDTreeStatusline != -1
    1   0.000010   0.000009         let &l:statusline = g:NERDTreeStatusline
    1              0.000001     endif

FUNCTION  204()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:359
Called 1 time
Total time:   0.199675
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000035   0.000011     let creator = s:Creator.New()
    1   0.199640   0.000010     call creator.toggleTabTree(a:dir)

FUNCTION  205()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:372
Called 1 time
Total time:   0.199629
 Self time:   0.000044

count  total (s)   self (s)
    1   0.000013   0.000007     if g:NERDTree.ExistsForTab()
                                    if !g:NERDTree.IsOpen()
                                        call self._createTreeWin()
                                        if !empty(a:dir) && a:dir !=# b:NERDTree.root.path.str()
                                            call self.createTabTree(a:dir)
                                        elseif !&hidden
                                            call b:NERDTree.render()
                                        endif
                                        call b:NERDTree.ui.restoreScreenState()
                                    else
                                        call g:NERDTree.Close()
                                    endif
    1              0.000001     else
    1   0.199590   0.000010         call self.createTabTree(a:dir)
    1              0.000002     endif

FUNCTION  207()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:7
Called 491 times
Total time:   0.027734
 Self time:   0.017826

count  total (s)   self (s)
  491   0.019217   0.009309     let flags = self._flagsForScope(a:scope)
  491              0.002545     if index(flags, a:flag) == -1
  491              0.002572         call add(flags, a:flag)
  491              0.000539     end

FUNCTION  208()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:15
Called 491 times
Total time:   0.006019
 Self time:   0.006019

count  total (s)   self (s)
  491              0.005443     let self._flags[a:scope] = []

FUNCTION  209()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:20
Called 982 times
Total time:   0.017795
 Self time:   0.017795

count  total (s)   self (s)
  982              0.008160     if !has_key(self._flags, a:scope)
   12              0.000050         let self._flags[a:scope] = []
  982              0.001093     endif
  982              0.004860     return self._flags[a:scope]

FUNCTION  <SNR>26_pushd()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:519
Called 3 times
Total time:   0.001946
 Self time:   0.000682

count  total (s)   self (s)
    3   0.000092   0.000053   if s:present(a:dict, 'dir')
    3   0.000411   0.000079     let cwd = s:fzf_getcwd()
    3              0.000050     let w:fzf_pushd = {   'command': haslocaldir() ? 'lcd' : (exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd'),   'origin': cwd,   'bufname': bufname('') }
    3   0.001240   0.000404     execute 'lcd' s:escape(a:dict.dir)
    3   0.000105   0.000048     let cwd = s:fzf_getcwd()
    3              0.000013     let w:fzf_pushd.dir = cwd
    3              0.000019     let a:dict.pushd = w:fzf_pushd
    3              0.000005     return cwd
                              endif
                              return ''

FUNCTION  410()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionMessage.vim:49
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000006 	if has_key(self, "exception")
                            		call self.message(a:cmdline)
                            		unlet self.exception
    1              0.000001 	endif

FUNCTION  412()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/History.vim:40
Called 1 time
Total time:   0.000020
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000019   0.000010 	call s:_reset()

FUNCTION  413()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/History.vim:44
Called 15 times
Total time:   0.002680
 Self time:   0.000851

count  total (s)   self (s)
   15   0.002205   0.000566 	if !a:cmdline.is_input("\<Up>") && !a:cmdline.is_input("\<Down>")	&& !a:cmdline.is_input("\<C-p>") && !a:cmdline.is_input("\<C-n>")
   15   0.000424   0.000234 		call s:_reset()
   15              0.000021 		return
                            	else
                            		if s:count == 0 && empty(s:cmdhist)	|| s:is_match_mode != s:_should_match_cmdline(a:cmdline)
                            			let cmdline = '^' . a:cmdline.getline()
                            			let s:is_match_mode = s:_should_match_cmdline(a:cmdline)
                            			let s:cmdhist = [a:cmdline.getline()] + (s:is_match_mode ?	filter(self.histories(), 'v:val =~ cmdline') : self.histories())
                            		endif
                            	endif
                            	call a:cmdline.setchar("")
                            	if a:cmdline.is_input("\<Down>") || a:cmdline.is_input("\<C-n>")
                            		let s:count = max([s:count - 1, 0])
                            	endif
                            	if a:cmdline.is_input("\<Up>") || a:cmdline.is_input("\<C-p>")
                            		let s:count = min([s:count + 1, len(s:cmdhist)])
                            	endif
                            	call a:cmdline.setline(get(s:cmdhist, s:count, a:cmdline.getline()))

FUNCTION  417()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/KeyMapping.vim:37
Called 15 times
Total time:   0.000875
 Self time:   0.000875

count  total (s)   self (s)
   15              0.000854 	return {		"\<C-f>" : {			"key" : "\<Right>",			"noremap" : 1,			"lock" : 1,		},		"\<C-b>" : {			"key" : "\<Left>",			"noremap" : 1,			"lock" : 1,		},		"\<C-n>" : {			"key" : "\<Down>",			"noremap" : 1,			"lock" : 1,		},		"\<C-p>" : {			"key" : "\<Up>",			"noremap" : 1,			"lock" : 1,		},		"\<C-a>" : {			"key" : "\<Home>",			"noremap" : 1,			"lock" : 1,		},		"\<C-e>" : {			"key" : "\<End>",			"noremap" : 1,			"lock" : 1,		},		"\<C-d>" : {			"key" : "\<Del>",			"noremap" : 1,			"lock" : 1,		},		"\<A-d>" : {			"key" : "\<C-w>",			"noremap" : 1,			"lock" : 1,		},		"\<A-b>" : {			"key" : "\<S-Left>",			"noremap" : 1,			"lock" : 1,		},		"\<A-f>" : {			"key" : "\<S-Right>",			"noremap" : 1,			"lock" : 1,		},	}

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:15
Called 249 times
Total time:   0.086729
 Self time:   0.084248

count  total (s)   self (s)
  249              0.002019   if !exists('b:fugitive_name')
    4              0.000013     let b:fugitive_name = ''
    4              0.000005     try
    4              0.000051       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
    4              0.000024       elseif exists('b:git_dir') && exists('*fugitive#repo')
    2              0.000011         if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
    2              0.000002         endif
    2              0.000007       elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
    4              0.000003       endif
                                catch
    4              0.000004     endtry
  249              0.000221   endif

  249   0.010109   0.007627   let fmod = s:ModifierFlags()
  249              0.001074   if empty(b:fugitive_name)
  249              0.058791     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  230()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:195
Called 451 times
Total time:   0.008150
 Self time:   0.008150

count  total (s)   self (s)
  451              0.004719     if !exists('s:NERDTree._PathFilters')
    1              0.000010         let s:NERDTree._PathFilters = []
  451              0.000407     endif
  451              0.001319     return s:NERDTree._PathFilters

FUNCTION  330()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:308
Called 1 time
Total time:   0.000109
 Self time:   0.000092

count  total (s)   self (s)
    1              0.000011 	if exists("self.variables.old_guicursor")
    1   0.000049   0.000039 		set guicursor&
    1   0.000026   0.000019 		let &guicursor = self.variables.old_guicursor
    1              0.000004 		unlet self.variables.old_guicursor
    1              0.000001 	endif

    1              0.000008 	if exists("self.variables.old_t_ve")
    1              0.000002 		let &t_ve = self.variables.old_t_ve
    1              0.000002 		unlet self.variables.old_t_ve
    1              0.000001 	endif

FUNCTION  <SNR>123_wrap()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:190
Called 2 times
Total time:   0.012061
 Self time:   0.000184

count  total (s)   self (s)
                              " fzf#wrap does not append --expect if sink or sink* is found
    2              0.000016   let opts = copy(a:opts)
    2              0.000006   let options = ''
    2              0.000009   if has_key(opts, 'options')
    2              0.000021     let options = type(opts.options) == s:TYPE.list ? join(opts.options) : opts.options
    2              0.000002   endif
    2              0.000025   if options !~ '--expect' && has_key(opts, 'sink*')
                                let Sink = remove(opts, 'sink*')
                                let wrapped = fzf#wrap(a:name, opts, a:bang)
                                let wrapped['sink*'] = Sink
    2              0.000002   else
    2   0.011939   0.000062     let wrapped = fzf#wrap(a:name, opts, a:bang)
    2              0.000003   endif
    2              0.000006   return wrapped

FUNCTION  <SNR>143_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/CursorMove.vim:52
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000008 	return deepcopy(s:module)

FUNCTION  <SNR>17_Autocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:228
Called 190 times
Total time:   0.101477
 Self time:   0.011105

count  total (s)   self (s)
  190              0.001066   if !g:coc_workspace_initialized
                                return
  190              0.000244   endif
  190   0.099304   0.008932   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  <SNR>248_highlight_name_for_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:234
Called 502 times
Total time:   0.005172
 Self time:   0.005172

count  total (s)   self (s)
  502              0.002738   if a:text ==# 'added'
  436              0.000896     return 'GitGutterLineAdded'
   66              0.000154   elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
   66              0.000156   elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
   66              0.000146   elseif a:text ==# 'modified'
   66              0.000111     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  <SNR>110_AddHeader()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1690
Called 3 times
Total time:   0.000196
 Self time:   0.000196

count  total (s)   self (s)
    3              0.000013   if empty(a:value)
                                return
    3              0.000002   endif
    3              0.000007   let before = 1
    6              0.000038   while !empty(getline(before))
    3              0.000007     let before += 1
    6              0.000007   endwhile
    3              0.000073   call append(before - 1, [a:key . ':' . (len(a:value) ? ' ' . a:value : '')])
    3              0.000012   if before == 1 && line('$') == 2
    1              0.000010     silent keepjumps 2delete _
    3              0.000003   endif

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:59
Called 241 times
Total time:   0.004091
 Self time:   0.004091

count  total (s)   self (s)
  241              0.003820   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  210()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:28
Called 12 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
   12              0.000072     let newObj = copy(self)
   12              0.000032     let newObj._flags = {}
   12              0.000017     return newObj

FUNCTION  212()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:45
Called 287 times
Total time:   0.012910
 Self time:   0.012910

count  total (s)   self (s)
  287              0.000843     let flagstring = ''
  861              0.002635     for i in values(self._flags)
  574              0.003421         let flagstring .= join(i)
  861              0.001017     endfor

  287              0.001319     if len(flagstring) == 0
                                    return ''
  287              0.000222     endif

  287              0.000950     return '[' . flagstring . ']'

FUNCTION  218()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:101
Called 44 times
Total time:   0.022561
 Self time:   0.007126

count  total (s)   self (s)
   44   0.004415   0.000509     call g:NERDTree.MustBeOpen()
   44   0.018042   0.006513     call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', a:0 >0 ? a:1 : 1)

FUNCTION  219()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:108
Called 165 times
Total time:   0.001088
 Self time:   0.001088

count  total (s)   self (s)
  165              0.000937     return exists('b:NERDTree')

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 241 times
Total time:   0.020610
 Self time:   0.020610

count  total (s)   self (s)
  241              0.003719   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  241              0.001811     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
  241              0.002360     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
  241              0.001332     let default = get(g:, 'airline#extensions#keymap#default', '')
  241              0.000732     if (label !=# '')
  241              0.000939       let label .= ' '
  241              0.000270     endif
  241              0.000962     let keymap = &keymap
  241              0.001142     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
  241              0.000219     endif
  241              0.004347     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  420()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:89
Called 1 time
Total time:   0.000208
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000004 	let s:cmdline = a:cmdline
    1   0.000204   0.000016 	call s:doautocmd_user(self.prefix, self.prefix . 'Enter')

FUNCTION  421()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:89
Called 1 time
Total time:   0.000214
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000006 	let s:cmdline = a:cmdline
    1   0.000207   0.000018 	call s:doautocmd_user(self.prefix, self.prefix . 'Leave')

FUNCTION  424()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:89
Called 15 times
Total time:   0.002173
 Self time:   0.000294

count  total (s)   self (s)
   15              0.000059 	let s:cmdline = a:cmdline
   15   0.002098   0.000220 	call s:doautocmd_user(self.prefix, self.prefix . 'Draw')

FUNCTION  425()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:89
Called 15 times
Total time:   0.002759
 Self time:   0.000327

count  total (s)   self (s)
   15              0.000049 	let s:cmdline = a:cmdline
   15   0.002680   0.000249 	call s:doautocmd_user(self.prefix, self.prefix . 'DrawPre')

FUNCTION  <SNR>91_GetHiCmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:158
Called 310 times
Total time:   0.052258
 Self time:   0.052258

count  total (s)   self (s)
                              " a:list needs to have 5 items!
  310              0.000721   let res = ''
  310              0.000610   let i = -1
 1860              0.002565   while i < 4
 1550              0.002416     let i += 1
 1550              0.006148     let item = get(a:list, i, '')
 1550              0.003116     if item is ''
  236              0.000269       continue
 1314              0.000867     endif
 1314              0.001804     if i == 0
  310              0.001267       let res .= ' guifg='.item
 1004              0.001110     elseif i == 1
  310              0.001037       let res .= ' guibg='.item
  694              0.000693     elseif i == 2
  310              0.001254       let res .= ' ctermfg='.item
  384              0.000435     elseif i == 3
  310              0.001040       let res .= ' ctermbg='.item
   74              0.000079     elseif i == 4
   74              0.000525       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
 1314              0.001001     endif
 1624              0.002131   endwhile
  310              0.000589   return res

FUNCTION  <SNR>110_DoAutocmd()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:158
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000005   if v:version >= 704 || (v:version == 703 && has('patch442'))
    1              0.000003     return 'doautocmd <nomodeline>' . a:cmd
                              elseif &modelines > 0
                                return 'try|set modelines=0|doautocmd ' . a:cmd . '|finally|set modelines=' . &modelines . '|endtry'
                              else
                                return 'doautocmd ' . a:cmd
                              endif

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:239
Called 257 times
Total time:   0.732788
 Self time:   0.030555

count  total (s)   self (s)
  257              0.001954   if !exists('b:buffer_vcs_config')
    2   0.000096   0.000024     call s:init_buffer()
  257              0.000615   endif

  257   0.567168   0.012032   call s:update_branch()
  257   0.154782   0.008896   call s:update_untracked()

  257              0.002105   if exists('b:airline_head') && !empty(b:airline_head)
  249              0.000616     return b:airline_head
    8              0.000008   endif

    8              0.000033   let b:airline_head = ''
    8              0.000101   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])

    8              0.000022   let heads = []
   24              0.000056   for vcs in vcs_priority
   16              0.000094     if !empty(b:buffer_vcs_config[vcs].branch)
    8              0.000040       let heads += [vcs]
   16              0.000015     endif
   24              0.000029   endfor

   16              0.000033   for vcs in heads
    8              0.000028     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
    8              0.000008     endif
    8              0.000029     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
    8              0.000006     endif
    8   0.001497   0.000358     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
    8              0.000042     let additional = b:buffer_vcs_config[vcs].untracked
    8              0.000073     if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
    4              0.000022       let additional = g:airline_symbols['dirty']
    8              0.000007     endif
    8              0.000030     let b:airline_head .= additional
   16              0.000028   endfor

    8              0.000023   if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
    8              0.000006   endif

    8              0.000021   if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
    8              0.000005   endif

    8              0.000046   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
    8              0.000005   endif

    8              0.000022   return b:airline_head

FUNCTION  NERDTreeFocus()
    Defined: ~/.vim/plugged/nerdtree/plugin/NERD_tree.vim:191
Called 1 time
Total time:   0.199801
 Self time:   0.000058

count  total (s)   self (s)
    1   0.000080   0.000012     if g:NERDTree.IsOpen()
                                    call g:NERDTree.CursorToTreeWin(0)
    1              0.000001     else
    1   0.199713   0.000038         call g:NERDTreeCreator.ToggleTabTree('')
    1              0.000002     endif

FUNCTION  WebDevIconsGetFileFormatSymbol()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:553
Called 249 times
Total time:   0.034363
 Self time:   0.026934

count  total (s)   self (s)
  249              0.000957   let fileformat = ''
  249              0.000471   let bomb = ''

  249              0.001078   if (&bomb && g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol !=? '')
                                let bomb = g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol . ' '
  249              0.000219   endif

  249              0.000694   if &fileformat ==? 'dos'
                                let fileformat = ''
  249              0.000598   elseif &fileformat ==? 'unix'
  249   0.010931   0.008228     let fileformat = s:isDarwin() ? '' : s:getDistro()
                              elseif &fileformat ==? 'mac'
                                let fileformat = ''
  249              0.000193   endif

  249   0.014084   0.009358   let artifactFix = s:DevIconsGetArtifactFix()

  249              0.001050   return bomb . fileformat . artifactFix

FUNCTION  <SNR>144_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Paste.vim:34
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005 	return deepcopy(s:module)

FUNCTION  <SNR>132_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Signals.vim:112
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000013 	let result = deepcopy(s:base)
    1              0.000002 	return result

FUNCTION  <SNR>63_isDarwin()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:126
Called 249 times
Total time:   0.002703
 Self time:   0.002703

count  total (s)   self (s)
  249              0.001469   if exists('s:is_darwin')
  249              0.000637     return s:is_darwin
                              endif

                              if exists('g:WebDevIconsOS')
                                let s:is_darwin = g:WebDevIconsOS ==? 'Darwin'
                                return s:is_darwin
                              endif

                              if has('macunix')
                                let s:is_darwin = 1
                                return s:is_darwin
                              endif

                              if ! has('unix')
                                let s:is_darwin = 0
                                return s:is_darwin
                              endif

                              if system('uname -s') ==# "Darwin\n"
                                let s:is_darwin = 1
                              else
                                let s:is_darwin = 0
                              endif

                              return s:is_darwin

FUNCTION  <SNR>134__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Keymapping.vim:22
Called 1 time
Total time:   0.000105
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.000101   0.000013 	let s:String  = s:V.import("Over.String")

FUNCTION  <SNR>110_TempReadPre()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:2242
Called 2 times
Total time:   0.000273
 Self time:   0.000081

count  total (s)   self (s)
    2   0.000224   0.000033   if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nomodeline
                                setlocal bufhidden=delete
                                setlocal buftype=nowrite
                                setlocal nomodifiable
                                if len(dict.dir)
                                  let b:git_dir = dict.dir
                                  call extend(b:, {'fugitive_type': 'temp'}, 'keep')
                                endif
    2              0.000002   endif

FUNCTION  <SNR>152__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Keymapping.vim:24
Called 1 time
Total time:   0.002045
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000003 	let s:V = a:V
    1   0.002041   0.000013 	let s:Capture  = s:V.import("Palette.Capture")

FUNCTION  220()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:114
Called 3 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    3              0.000011     if !exists('t:NERDTreeBufName')
    3              0.000003         return
                                end

                                "check b:NERDTree is still there and hasn't been e.g. :bdeleted
                                return !empty(getbufvar(bufnr(t:NERDTreeBufName), 'NERDTree'))

FUNCTION  224()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:148
Called 144 times
Total time:   0.008405
 Self time:   0.008389

count  total (s)   self (s)
  144              0.001287     if exists('t:NERDTreeBufName')
  140              0.006506         return bufwinnr(t:NERDTreeBufName)
    4              0.000005     endif

                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
    8              0.000053     for w in range(1,winnr('$'))
    4   0.000141   0.000125         if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
    4              0.000006         endif
    8              0.000016     endfor

    4              0.000008     return -1

FUNCTION  225()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:164
Called 100 times
Total time:   0.007742
 Self time:   0.001694

count  total (s)   self (s)
  100   0.007626   0.001577     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  228()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:179
Called 44 times
Total time:   0.003906
 Self time:   0.000815

count  total (s)   self (s)
   44   0.003620   0.000529     if !s:NERDTree.IsOpen()
                                    throw 'NERDTree.TreeNotOpen'
   44              0.000067     endif

FUNCTION  229()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:186
Called 1 time
Total time:   0.000180
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000025     let newObj = copy(self)
    1   0.000061   0.000014     let newObj.ui = g:NERDTreeUI.New(newObj)
    1   0.000088   0.000013     let newObj.root = g:NERDTreeDirNode.New(a:path, newObj)
    1              0.000002     let newObj._type = a:type
    1              0.000001     return newObj

FUNCTION  <SNR>140_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Redraw.vim:66
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000008 	return deepcopy(s:module)

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:187
Called 234 times
Total time:   0.029975
 Self time:   0.008463

count  total (s)   self (s)
  234   0.029276   0.007764   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  431()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:84
Called 15 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
   15              0.000118     return {       "\<CR>"   : {           "key" : "<Over>(exit)",           "noremap" : 1,           "lock" : 1,       },   }

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 241 times
Total time:   0.034631
 Self time:   0.013866

count  total (s)   self (s)
  241   0.034289   0.013524   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  433()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:137
Called 1 time
Total time:   0.000194
 Self time:   0.000066

count  total (s)   self (s)
    1              0.000004     if s:num_strokes == -1
    1   0.000061   0.000017         call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_inc_search)
    1              0.000003         if g:EasyMotion_do_shade
    1   0.000061   0.000017             call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_group_shade)
    1              0.000001         endif
    1              0.000001     endif
    1              0.000003     if g:EasyMotion_cursor_highlight
    1   0.000055   0.000015         call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_inc_cursor)
    1              0.000001     endif

FUNCTION  434()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:148
Called 15 times
Total time:   0.008008
 Self time:   0.001729

count  total (s)   self (s)
   15              0.000062     if s:num_strokes == -1
   15   0.000459   0.000158         let re = s:search.getline()
   15   0.000918   0.000305         if EasyMotion#helper#should_case_sensitive(re, 1)
   15              0.000056             let case_flag = '\c'
                                    else
                                        let case_flag = '\C'
   15              0.000013         endif
   15              0.000062         let re .= case_flag
   15              0.000038         if g:EasyMotion_inc_highlight
   15   0.002334   0.000301             call s:inc_highlight(re)
   15              0.000013         endif
   15              0.000042         if g:EasyMotion_off_screen_search
   15   0.003773   0.000442             call s:off_screen_search(re)
   15              0.000015         endif
                                elseif s:search.line.length() >=  s:num_strokes
                                    call s:search.exit()
   15              0.000011     endif

FUNCTION  437()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:787
Called 1 time
Total time:   0.327137
 Self time:   0.001908

count  total (s)   self (s)
    1   0.000036   0.000020     if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
    1              0.000001     else
    1              0.000004       if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
    1   0.032700   0.001712         close
    1              0.000001       endif
    1              0.000009       silent! execute 'tabnext' self.ppos.tab
    1              0.000006       silent! execute self.ppos.win.'wincmd w'
    1              0.000001     endif

    1              0.000003     if bufexists(self.buf)
                                  execute 'bd!' self.buf
    1              0.000001     endif

    1   0.000035   0.000022     if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
    1              0.000009       execute self.winrest
    1              0.000001     endif

    1   0.000282   0.000018     let lines = s:collect(self.temps)
    1   0.000043   0.000018     if !s:exit_handler(a:code, self.command, 1)
                                  return
    1              0.000001     endif

    1   0.000617   0.000010     call s:pushd(self.dict)
    1   0.293307   0.000023     call s:callback(self.dict, lines)
    1   0.000053   0.000022     call self.switch_back(s:getpos() == self.ppos)

FUNCTION  coc#util#get_bufoptions()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:225
Called 5 times
Total time:   0.002648
 Self time:   0.001679

count  total (s)   self (s)
    5              0.000120   if !bufloaded(a:bufnr) | return v:null | endif
    5              0.000068   let bufname = bufname(a:bufnr)
    5              0.000055   let buftype = getbufvar(a:bufnr, '&buftype')
    5              0.000016   let previewwindow = 0
    5              0.000024   let winid = bufwinid(a:bufnr)
    5              0.000014   if winid != -1
    5              0.000040     let previewwindow = getwinvar(winid, '&previewwindow', 0)
    5              0.000007   endif
    5              0.000011   let size = -1
    5              0.000021   if bufnr('%') == a:bufnr
    5              0.000044     let size = line2byte(line("$") + 1)
                              elseif !empty(bufname)
                                let size = getfsize(bufname)
    5              0.000005   endif
    5              0.000014   let lines = []
    5              0.000092   if getbufvar(a:bufnr, 'coc_enabled', 1) && (buftype == '' || buftype == 'acwrite') && size < a:maxFileSize
    1              0.000054     let lines = getbufline(a:bufnr, 1, '$')
    5              0.000006   endif
    5   0.001964   0.000995   return { 'bufname': bufname, 'size': size, 'buftype': buftype, 'winid': winid, 'previewwindow': previewwindow == 0 ? v:false : v:true, 'variables': s:variables(a:bufnr), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'), 'eol': getbufvar(a:bufnr, '&eol'), 'filetype': getbufvar(a:bufnr, '&filetype'), 'iskeyword': getbufvar(a:bufnr, '&iskeyword'), 'changedtick': getbufvar(a:bufnr, 'changedtick'), 'lines': lines,}

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 18 times
Total time:   0.000323
 Self time:   0.000323

count  total (s)   self (s)
   18              0.000101   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
   18              0.000018   endif

FUNCTION  <SNR>128__function()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:11
Called 9 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    9              0.000080     return function(a:fstr)

FUNCTION  <SNR>27_p()
    Defined: ~/.vim/plugged/fzf.vim/plugin/fzf.vim:47
Called 2 times
Total time:   0.000845
 Self time:   0.000110

count  total (s)   self (s)
    2              0.000021   let preview_args = get(g:, 'fzf_preview_window', ['right', 'ctrl-/'])
    2              0.000008   if empty(preview_args)
                                return { 'options': ['--preview-window', 'hidden'] }
    2              0.000003   endif

                              " For backward-compatiblity
    2              0.000009   if type(preview_args) == type('')
                                let preview_args = [preview_args]
    2              0.000001   endif
    2   0.000784   0.000049   return call('fzf#vim#with_preview', extend(copy(a:000), preview_args))

FUNCTION  fugitive#Find()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:920
Called 265 times
Total time:   0.252701
 Self time:   0.167042

count  total (s)   self (s)
  265              0.001634   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
  265              0.003969   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
  265   0.015807   0.011296   elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
  265   0.011961   0.008497   elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
  265              0.000262   endif
  265   0.001653   0.001523   let dir = a:0 ? a:1 : s:Dir()
  265              0.000892   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                                endif
  265              0.000219   endif
  265   0.008350   0.004995   let rev = s:Slash(a:object)
  265   0.058556   0.004843   let tree = s:Tree(dir)
  265              0.001764   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
  265              0.000671   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
  265              0.002601   elseif rev =~# '^\.git/'
  264              0.004998     let f = substitute(rev, '^\.git', '', '')
  264   0.038149   0.023391     let cdir = fugitive#CommonDir(dir)
  264              0.003664     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
  264              0.002311     elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
  264              0.003069     elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
  264              0.000246     else
  264              0.001844       let f = simplify(dir . f)
  264              0.000264     endif
    1              0.000002   elseif rev ==# ':/'
                                let f = base
    1              0.000004   elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
    1              0.000006   elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
    1              0.000005   elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
    1              0.000004   elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
    1              0.000018   elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
    1              0.000005   elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
    1              0.000002   elseif rev ==# ':'
    1              0.000015     if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
    1              0.000001     else
    1              0.000005       let f = fugitive#Find('.git/index', dir)
    1              0.000001     endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) || v:val ==# "@" ? "HEAD" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
  265              0.000215   endif
  265   0.010323   0.005174   return FugitiveVimPath(f)

FUNCTION  233()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:213
Called 41 times
Total time:   0.409302
 Self time:   0.000793

count  total (s)   self (s)
   41   0.409259   0.000750     call self.ui.render()

FUNCTION  235()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:25
Called 41 times
Total time:   0.011180
 Self time:   0.010806

count  total (s)   self (s)
   41   0.000840   0.000675     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 3 ? 'single' : 'double') ."-click,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"

                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 1 ? 'double' : 'single') ."-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= '" '. g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= '" '. g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenExpl.": explore selected dir\n"

                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": preview file\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": find dir in tree\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapDeleteBookmark .": delete bookmark\n"

                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= '" '. g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= '" '. g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= '" '. g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= '" '. g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= '" '. g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= '" '. g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"

                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= '" '. g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= '" '. g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= '" '. g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= '" '. g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= '" '. g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapCWD .":change tree root to CWD\n"

                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= '" '. g:NERDTreeMapToggleHidden .': hidden files (' . (self.getShowHidden() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFilters .': file filters (' . (self.isIgnoreFilterEnabled() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFiles .': files (' . (self.getShowFiles() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleBookmarks .': bookmarks (' . (self.getShowBookmarks() ? 'on' : 'off') . ")\n"

                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= '" '. i.key .': '. i.quickhelpText ."\n"
                                        endif
                                    endfor

                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= '" '. g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    let help .= "\" :ReadBookmarks\n"
                                    let help .= "\" :WriteBookmarks\n"
                                    let help .= "\" :EditBookmarks\n"
                                    silent! put =help
   41   0.000704   0.000495     elseif !self.isMinimal()
   41              0.000261         let help ='" Press '. g:NERDTreeMapHelp ." for help\n"
   41              0.000473         silent! put =help
   41              0.000048     endif

FUNCTION  236()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:142
Called 1 time
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    1              0.000026     let newObj = copy(self)
    1              0.000003     let newObj.nerdtree = a:nerdtree
    1              0.000002     let newObj._showHelp = 0
    1              0.000002     let newObj._ignoreEnabled = 1
    1              0.000003     let newObj._showFiles = g:NERDTreeShowFiles
    1              0.000003     let newObj._showHidden = g:NERDTreeShowHidden
    1              0.000003     let newObj._showBookmarks = g:NERDTreeShowBookmarks

    1              0.000002     return newObj

FUNCTION  238()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:211
Called 1 time
Total time:   0.000489
 Self time:   0.000025

count  total (s)   self (s)

    1   0.000360   0.000007     if a:node.isRoot()
    1   0.000127   0.000015         return self.getRootLineNum()
                                endif

                                let l:pathComponents = [substitute(self.nerdtree.root.path.str({'format': 'UI'}), '/\s*$', '', '')]
                                let l:currentPathComponent = 1

                                let l:fullPath = a:node.path.str({'format': 'UI'})

                                for l:lineNumber in range(self.getRootLineNum() + 1, line('$'))
                                    let l:currentLine = getline(l:lineNumber)
                                    let l:indentLevel = self._indentLevelFor(l:currentLine)

                                    if l:indentLevel !=# l:currentPathComponent
                                        continue
                                    endif

                                    let l:currentLine = self._stripMarkup(l:currentLine)
                                    let l:currentPath =  join(l:pathComponents, '/') . '/' . l:currentLine

                                    " Directories: If the current path 'starts with' the full path, then
                                    " either the paths are equal or the line is a cascade containing the
                                    " full path.
                                    if l:fullPath[-1:] ==# '/' && stridx(l:currentPath, l:fullPath) ==# 0
                                        return l:lineNumber
                                    endif

                                    " Files: The paths must exactly match.
                                    if l:fullPath ==# l:currentPath
                                        return l:lineNumber
                                    endif

                                    " Otherwise: If the full path starts with the current path and the
                                    " current path is a directory, we add a new path component.
                                    if stridx(l:fullPath, l:currentPath) ==# 0 && l:currentPath[-1:] ==# '/'
                                        let l:currentLine = substitute(l:currentLine, '/\s*$', '', '')
                                        call add(l:pathComponents, l:currentLine)
                                        let l:currentPathComponent += 1
                                    endif
                                endfor

                                return -1

FUNCTION  <SNR>130_split_by_keys()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:143
Called 30 times
Total time:   0.001730
 Self time:   0.000638

count  total (s)   self (s)
   30   0.001708   0.000616 	return s:_split_keystring(a:str, "\\%(\<Plug>\\|<Over>\\)(.\\{-})\\zs\\|")

FUNCTION  <SNR>138_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Exit.vim:34
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005 	return deepcopy(s:module)

FUNCTION  <SNR>110_ExpireStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:2863
Called 5 times
Total time:   0.000582
 Self time:   0.000288

count  total (s)   self (s)
    5              0.000032   if a:bufnr == -2
    3              0.000058     let s:head_cache = {}
    3              0.000035     let s:last_time = reltime()
    3              0.000010     return ''
    2              0.000002   endif
    2   0.000186   0.000031   let dir = s:Dir(a:bufnr)
    2              0.000008   if len(dir)
    2   0.000180   0.000041     let s:last_times[s:cpath(dir)] = reltime()
    2              0.000010     if has_key(s:head_cache, dir)
    2              0.000016       call remove(s:head_cache, dir)
    2              0.000002     endif
    2              0.000002   endif
    2              0.000003   return ''

FUNCTION  vital#_easymotion#Over#Commandline#Modules#History#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/History.vim:5
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000017     return map({'make': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>150_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/NoInsert.vim:38
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000007 	let module = deepcopy(s:module)
    1              0.000008 	let module.chars = type(a:chars) == type([]) ? a:chars : [a:chars]
    1              0.000002 	return module

FUNCTION  <SNR>127_inc_highlight()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:271
Called 15 times
Total time:   0.002033
 Self time:   0.000785

count  total (s)   self (s)
   15   0.001104   0.000296     call EasyMotion#highlight#delete_highlight(g:EasyMotion_hl_inc_search)
   15   0.000232   0.000163     if s:search.line.length() > 0
                                    " Error occur when '\zs' without '!'
   13   0.000621   0.000250         silent! call EasyMotion#highlight#add_highlight(a:re, g:EasyMotion_hl_inc_search)
   15              0.000022     endif

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:88
Called 16 times
Total time:   0.001180
 Self time:   0.001180

count  total (s)   self (s)
   16              0.000252   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
   16              0.000117   let g:airline#extensions#wordcount#filetypes = filetypes

                              " Check if filetype needs testing
   16              0.000049   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
    3              0.000025     let ft = substitute(&filetype, '\.', '\\|', 'g')

                                " Select test based on type of "filetypes": new=list, old=string
    3              0.000079     if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
    3              0.000011     elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
    3              0.000002     endif
   16              0.000011   endif

   16              0.000069   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
   16              0.000013   endif

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:173
Called 4 times
Total time:   0.106610
 Self time:   0.002399

count  total (s)   self (s)
    4   0.000798   0.000077   call gitgutter#debug#log(a:diff)

    4              0.000025   if !bufexists(a:bufnr)
                                return
    4              0.000003   endif

    4   0.008817   0.000168   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    4   0.037677   0.000183   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))

    4              0.000020   let signs_count = len(modified_lines)
    4              0.000018   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)

    4              0.000004   else
    4              0.000018     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
    4   0.058664   0.001564       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    4              0.000011     endif
    4              0.000004   endif

    4   0.000357   0.000110   call s:save_last_seen_change(a:bufnr)
    4              0.000047   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
    4              0.000004   endif

FUNCTION  <SNR>110_Dir()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:277
Called 18 times
Total time:   0.002091
 Self time:   0.000237

count  total (s)   self (s)
   18   0.002077   0.000224   return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()

FUNCTION  EasyMotion#is_active()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:775
Called 67 times
Total time:   0.000773
 Self time:   0.000773

count  total (s)   self (s)
   67              0.000545     return s:EasyMotion_is_active

FUNCTION  <SNR>154_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Doautocmd.vim:106
Called 1 time
Total time:   0.000522
 Self time:   0.000522

count  total (s)   self (s)
    1              0.000008 	if has_key(s:cache_command, a:prefix)
                            		unlet! s:cache_command[a:prefix]
    1              0.000001 	endif
    1              0.000018 	execute "augroup " a:prefix . "-vital-over-commandline-doautocmd-dummy"
    1              0.000455 		autocmd!
    1              0.000002 	augroup END

    1              0.000019 	let module = deepcopy(s:module)
    1              0.000006 	let module.prefix = a:prefix
    1              0.000003 	return module

FUNCTION  gitgutter#setup_maps()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:107
Called 9 times
Total time:   0.003454
 Self time:   0.003028

count  total (s)   self (s)
    9              0.000029   if !g:gitgutter_map_keys
                                return
    9              0.000011   endif

                              " Note hasmapto() and maparg() operate on the current buffer.

    9              0.000068   let bufnr = bufnr('')

    9   0.000473   0.000199   if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
    5              0.000006     return
    4              0.000003   endif

    4              0.000441   if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
    3              0.000062     nmap <buffer> [c <Plug>(GitGutterPrevHunk)
    4              0.000004   endif
    4              0.000266   if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
    3              0.000047     nmap <buffer> ]c <Plug>(GitGutterNextHunk)
    4              0.000004   endif

    4              0.000062   if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
                                xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    4              0.000003   endif
    4              0.000063   if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
                                nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    4              0.000003   endif
    4              0.000063   if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
                                nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
    4              0.000003   endif
    4              0.000060   if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
                                nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
    4              0.000003   endif

    4              0.000284   if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
    4              0.000093     omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
    4              0.000006   endif
    4              0.000278   if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
    4              0.000080     omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
    4              0.000005   endif
    4              0.000236   if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
    4              0.000074     xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
    4              0.000004   endif
    4              0.000225   if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
    4              0.000072     xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
    4              0.000004   endif

    4   0.000265   0.000112   call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  <SNR>148_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionMessage.vim:57
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000008 	let result = deepcopy(s:module)
    1              0.000009 	let result.prefix = get(a:, 1, "vital-over(".s:vname.") Exception")
    1              0.000005 	let result.command = get(a:, 2, "echom")
    1              0.000001 	return result

FUNCTION  240()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:268
Called 41 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
   41              0.000122     return self._showBookmarks

FUNCTION  242()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:278
Called 41 times
Total time:   0.000165
 Self time:   0.000165

count  total (s)   self (s)
   41              0.000129     return self._showHelp

FUNCTION  243()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:283
Called 451 times
Total time:   0.002684
 Self time:   0.002684

count  total (s)   self (s)
  451              0.002380     return self._showHidden

FUNCTION  246()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:306
Called 451 times
Total time:   0.001958
 Self time:   0.001958

count  total (s)   self (s)
  451              0.001271     return self._ignoreEnabled ==# 1

FUNCTION  247()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:311
Called 123 times
Total time:   0.001203
 Self time:   0.001203

count  total (s)   self (s)
  123              0.001094     return g:NERDTreeMinimalUI

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:28
Called 24 times
Total time:   0.007844
 Self time:   0.001055

count  total (s)   self (s)
   24   0.006554   0.000443   let summary = gitgutter#hunk#summary(a:bufnr)
   24              0.000104   let summary[0] += a:count
   24   0.001107   0.000429   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  134()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:45
Called 11 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
   11              0.000044     call add(self.children, a:treenode)
   11              0.000029     let a:treenode.parent = self

   11              0.000014     if a:inOrder
                                    call self.sortChildren()
   11              0.000008     endif

FUNCTION  <SNR>243_on_exit_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:72
Called 5 times
Total time:   0.188586
 Self time:   0.001435

count  total (s)   self (s)
    5              0.000645   if !a:exit_code
    5   0.187883   0.000732     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    5              0.000007   endif

FUNCTION  <SNR>246_process_modified_and_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:319
Called 12 times
Total time:   0.003107
 Self time:   0.003107

count  total (s)   self (s)
   12              0.000060   let offset = 0
   56              0.000147   while offset < a:from_count
   44              0.000182     let line_number = a:to_line + offset
   44              0.000256     call add(a:modifications, [line_number, 'modified'])
   44              0.000104     let offset += 1
   56              0.000085   endwhile
  156              0.000342   while offset < a:to_count
  144              0.000420     let line_number = a:to_line + offset
  144              0.000731     call add(a:modifications, [line_number, 'added'])
  144              0.000302     let offset += 1
  156              0.000155   endwhile

FUNCTION  airline#async#nvim_vcs_clean()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:305
Called 8 times
Total time:   0.014216
 Self time:   0.013821

count  total (s)   self (s)
    8   0.001355   0.001100     let config = { 'buf': '', 'vcs': a:vcs, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')), 'on_stdout': function('s:nvim_output_handler'), 'on_stderr': function('s:nvim_output_handler'), 'on_exit': function('s:on_exit_clean')}
    8              0.000045     if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
    8              0.000010     else
    8              0.000067       let cmd = [&shell, &shellcmdflag, a:cmd]
    8              0.000009     endif

    8              0.000049     if !has_key(s:clean_jobs, a:vcs)
    1              0.000005       let s:clean_jobs[a:vcs] = {}
    8              0.000007     endif
    8              0.000057     if has_key(s:clean_jobs[a:vcs], a:file)
                                  " still running
    5              0.000008       return
                                  " jobs dict should be cleaned on exit, so not needed here
                                  " call remove(s:clean_jobs[a:vcs], a:file)
    3              0.000002     endif
    3              0.011951     let id = jobstart(cmd, config)
    3   0.000507   0.000367     call s:set_clean_jobs_variable(a:vcs, a:file, id)

FUNCTION  fugitive#PrepareDirEnvArgv()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:332
Called 3 times
Total time:   0.017079
 Self time:   0.000601

count  total (s)   self (s)
    3              0.000015   if a:0 && type(a:1) ==# type([])
    3              0.000016     let cmd = a:000[1:-1] + a:1
                              else
                                let cmd = copy(a:000)
    3              0.000002   endif
    3              0.000005   let env = {}
    3              0.000005   let i = 0
    6              0.000017   while i < len(cmd)
    6              0.000057     if cmd[i] =~# '^$\|[\/.]' && cmd[i] !~# '^-'
    2              0.000008       let dir = remove(cmd, i)
    4              0.000022     elseif cmd[i] =~# '^--git-dir='
                                  let dir = remove(cmd, i)[10:-1]
    4              0.000014     elseif type(cmd[i]) ==# type(0)
                                  let dir = s:Dir(remove(cmd, i))
    4              0.000013     elseif cmd[i] ==# '-c' && len(cmd) > i + 1
                                  let key = matchstr(cmd[i+1], '^[^=]*')
                                  if has_key(s:prepare_env, tolower(key)) || key !~# '\.'
                                    let var = get(s:prepare_env, tolower(key), key)
                                    let val = matchstr(cmd[i+1], '=\zs.*')
                                    let env[var] = val
                                  endif
                                  if fugitive#GitVersion(1, 8) && cmd[i+1] =~# '\.'
                                    let i += 2
                                  else
                                    call remove(cmd, i, i + 1)
                                  endif
    4              0.000028     elseif cmd[i] =~# '^--.*pathspecs$'
                                  let explicit_pathspec_option = 1
                                  if fugitive#GitVersion(1, 9)
                                    let i += 1
                                  else
                                    call remove(cmd, i)
                                  endif
    4              0.000015     elseif cmd[i] !~# '^-'
    3              0.000003       break
    1              0.000001     else
    1              0.000002       let i += 1
    3              0.000002     endif
    6              0.000015   endwhile
    3              0.000009   if !exists('dir')
    1   0.000045   0.000008     let dir = s:Dir()
    3              0.000002   endif
    3   0.016489   0.000048   call s:PreparePathArgs(cmd, dir, !exists('explicit_pathspec_option'))
    3              0.000012   return [dir, env, cmd]

FUNCTION  EasyMotion#highlight#delete_highlight()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim:164
Called 20 times
Total time:   0.001138
 Self time:   0.001138

count  total (s)   self (s)
   20              0.000163     let groups = !empty(a:000) ? a:000 : keys(s:priorities)
   52              0.000138     for group in groups
   47              0.000155         for id in s:h.ids[group]
   15              0.000139             silent! call matchdelete(id)
   47              0.000054         endfor
   32              0.000133         let s:h.ids[group] = []
   52              0.000065     endfor

FUNCTION  <SNR>146_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/InsertRegister.vim:159
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006 	return deepcopy(s:module)

FUNCTION  360()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:74
Called 15 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
   15              0.000029 	return self.col

FUNCTION  251()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:364
Called 4 times
Total time:   0.001302
 Self time:   0.000398

count  total (s)   self (s)
    4              0.000025     let win = winnr()
    4              0.000031     let self._screenState = {}
    4              0.000007     try
    4   0.000790   0.000042         call g:NERDTree.CursorToTreeWin()
    4              0.000066         let self._screenState['oldPos'] = getpos('.')
    4              0.000036         let self._screenState['oldTopLine'] = line('w0')
    4              0.000049         let self._screenState['oldWindowSize'] = winnr('$')==1 ? g:NERDTreeWinSize : winwidth('')
    4   0.000260   0.000105         call nerdtree#exec(win . 'wincmd w', 1)
                                catch
    4              0.000006     endtry

FUNCTION  254()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:393
Called 41 times
Total time:   0.408509
 Self time:   0.016329

count  total (s)   self (s)
   41   0.000770   0.000765     setlocal noreadonly modifiable

                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
   41              0.000263     let curLine = line('.')
   41              0.000169     let curCol = col('.')
   41              0.000154     let topLine = line('w0')

                                " delete all lines in the buffer (being careful not to clobber a register)
   41              0.001909     silent 1,$delete _

   41   0.011678   0.000498     call self._dumpHelp()

                                " delete the blank line before the help and add one after it
   41   0.000690   0.000523     if !self.isMinimal()
   41              0.000493         call setline(line('.')+1, '')
   41              0.000312         call cursor(line('.')+1, col('.'))
   41              0.000044     endif

   41   0.001571   0.001408     if self.getShowBookmarks()
                                    call self._renderBookmarks()
   41              0.000037     endif

                                " add the 'up a dir' line
   41   0.001150   0.000322     if !self.isMinimal()
   41   0.001709   0.000660         call setline(line('.')+1, s:UI.UpDirLine())
   41              0.000266         call cursor(line('.')+1, col('.'))
   41              0.000043     endif

                                " draw the header line
   41   0.024702   0.000951     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
   41              0.000528     call setline(line('.')+1, header)
   41              0.000259     call cursor(line('.')+1, col('.'))

                                " draw the tree
   41   0.357077   0.002049     silent put =self.nerdtree.root.renderToString()

                                " delete the blank line at the top of the buffer
   41              0.000727     silent 1,1delete _

                                " restore the view
   41              0.000272     let old_scrolloff=&scrolloff
   41   0.000386   0.000382     let &scrolloff=0
   41              0.000225     call cursor(topLine, 1)
   41              0.001059     normal! zt
   41              0.000289     call cursor(curLine, curCol)
   41   0.000275   0.000272     let &scrolloff = old_scrolloff

   41   0.000391   0.000388     setlocal readonly nomodifiable

FUNCTION  <SNR>26_callback()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:871
Called 1 time
Total time:   0.293284
 Self time:   0.000082

count  total (s)   self (s)
    1              0.000005   let popd = has_key(a:dict, 'pushd')
    1              0.000001   if popd
    1              0.000002     let w:fzf_pushd = a:dict.pushd
    1              0.000001   endif

    1              0.000001   try
    1              0.000003     if has_key(a:dict, 'sink')
                                  for line in a:lines
                                    if type(a:dict.sink) == 2
                                      call a:dict.sink(line)
                                    else
                                      execute a:dict.sink s:escape(line)
                                    endif
                                  endfor
    1              0.000001     endif
    1              0.000003     if has_key(a:dict, 'sink*')
    1   0.292741   0.000013       call a:dict['sink*'](a:lines)
    1              0.000001     endif
                              catch
                                if stridx(v:exception, ':E325:') < 0
                                  echoerr v:exception
                                endif
    1              0.000001   endtry

                              " We may have opened a new window or tab
    1              0.000002   if popd
    1              0.000005     let w:fzf_pushd = a:dict.pushd
    1   0.000487   0.000013     call s:dopopd()
    1              0.000001   endif

FUNCTION  <SNR>104_get_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 249 times
Total time:   0.024039
 Self time:   0.019606

count  total (s)   self (s)
  249              0.001330   if has_key(s:section_truncate_width, a:key)
  145   0.006262   0.003494     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
   26              0.000044       return ''
  119              0.000092     endif
  223              0.000161   endif
  223              0.000865   let spc = g:airline_symbols.space
  223              0.001595   if !exists('g:airline_section_{a:key}')
                                return ''
  223              0.000159   endif
  223   0.007037   0.005371   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  223              0.003030   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  223              0.001474   return empty(text) ? '' : prefix.text.suffix

FUNCTION  coc#highlight#clear_highlight()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:49
Called 1 time
Total time:   0.000123
 Self time:   0.000087

count  total (s)   self (s)
    1              0.000010   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
    1              0.000005   if !bufloaded(bufnr)
                                return
    1              0.000001   endif
    1   0.000064   0.000028   let src_id = s:create_namespace(a:key)
    1              0.000006   if has('nvim')
    1              0.000021     call nvim_buf_clear_namespace(a:bufnr, src_id, a:start_line, a:end_line)
                              else
                                call coc#api#call('buf_clear_namespace', [a:bufnr, src_id, a:start_line, a:end_line])
    1              0.000001   endif

FUNCTION  344()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:458
Called 15 times
Total time:   0.080345
 Self time:   0.001418

count  total (s)   self (s)
   15              0.000077 	let char = a:char
   15              0.000092 	let self.variables.input_key = char
   15              0.000048 	let self.variables.char = char
   15   0.000484   0.000212 	call self.setchar(self.variables.char)
   15              0.000034 	let self.variables.is_setted = 0
   15   0.047863   0.000307 	call self.callevent("on_char_pre")
   15   0.001092   0.000250 	call self.insert(self.variables.input)
   15   0.030474   0.000218 	call self.callevent("on_char")

FUNCTION  <SNR>147_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/ExceptionExit.vim:30
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000006 	let result = deepcopy(s:module)
    1              0.000006 	let result.exit_code = get(a:, 1, 0)
    1              0.000001 	return result

FUNCTION  <SNR>118_Filetype()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/polyglot/shebang.vim:24
Called 6 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    6              0.000052   let l:line1 = getline(1)

    6              0.000060   if l:line1 !~# "^#!"
    6              0.000012     return
                              endif

                              let l:pathrest = matchlist(l:line1, s:r_hashbang)

                              if len(l:pathrest) == 0
                                return
                              endif

                              let [_, l:path, l:rest; __] = l:pathrest

                              let l:pathparts = split(l:path, "/")

                              if len(l:pathparts) == 0
                                return
                              endif

                              let l:script = l:pathparts[-1]

                              if l:script == "env"
                                let l:argspath = matchlist(l:rest, s:r_env)
                                if len(l:argspath) == 0
                                  return
                                endif

                                let l:script = l:argspath[1]
                              endif

                              if has_key(s:interpreters, l:script)
                                return s:interpreters[l:script]
                              endif

                              for interpreter in keys(s:interpreters)
                                if l:script =~# '^' . interpreter
                                  return s:interpreters[interpreter]
                                endif
                              endfor

FUNCTION  <SNR>119_create_namespace()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:300
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000006   if type(a:key) == 0
                                return a:key
    1              0.000001   endif
    1              0.000006   if has('nvim')
    1              0.000015     return nvim_create_namespace('coc-'.a:key)
                              endif
                              if !has_key(s:namespace_map, a:key)
                                let s:namespace_map[a:key] = s:ns_id
                                let s:ns_id = s:ns_id + 1
                              endif
                              return s:namespace_map[a:key]

FUNCTION  346()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:503
Called 15 times
Total time:   0.104543
 Self time:   0.002339

count  total (s)   self (s)
   15   0.000146   0.000107 	if !self.is_enable_keymapping()
                            		return self.__input(s:Input.getchar())
   15              0.000014 	endif

   15   0.004507   0.000271 	let input = s:Input.getchar()
   15   0.000642   0.000327 	let old_line = self.getline()
   15   0.000333   0.000163 	let old_pos  = self.getpos()
   15   0.008240   0.000158 	let keymapping = self.__get_keymapping()
   15              0.000024 	try
   15              0.000062 		let t = reltime()
   15   0.001439   0.000309 		while s:is_input_waiting(keymapping, input)		&& str2nr(reltimestr(reltime(t))) * 1000 < &timeoutlen
                            			call self.setline(old_line)
                            			call self.insert(input)
                            			call self.setpos(old_pos)
                            			call self.draw()
                            			let input .= s:Input.getchar(0)
   15              0.000034 		endwhile
   15              0.000023 	finally
   15   0.001000   0.000146 		call self.setline(old_line)
   15   0.000760   0.000143 		call self.setpos(old_pos)
   15              0.000021 	endtry
   15   0.086940   0.000180 	call self.__input(input, keymapping)

FUNCTION  349()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:576
Called 1 time
Total time:   0.000131
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000129   0.000021 	call self.hl_cursor_on()

FUNCTION  <SNR>110_PreparePathArgs()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:301
Called 3 times
Total time:   0.016441
 Self time:   0.000298

count  total (s)   self (s)
    3   0.016194   0.000050   let literal_supported = fugitive#GitVersion(1, 9)
    3              0.000008   if a:literal && literal_supported
    3              0.000014     call insert(a:cmd, '--literal-pathspecs')
    3              0.000003   endif
    3              0.000013   let split = index(a:cmd, '--')
   17              0.000035   for i in range(split < 0 ? len(a:cmd) : split)
   14              0.000051     if type(a:cmd[i]) == type(0)
                                  let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), './', a:dir)
   14              0.000008     endif
   17              0.000014   endfor
    3              0.000004   if split < 0
    3              0.000006     return a:cmd
                              endif
                              for i in range(split + 1, len(a:cmd) - 1)
                                if type(a:cmd[i]) == type(0)
                                  let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), './', a:dir)
                                elseif a:literal
                                  let a:cmd[i] = fugitive#Path(a:cmd[i], './', a:dir)
                                elseif !literal_supported
                                  let a:cmd[i] = substitute(a:cmd[i], '^:\%(/\|([^)]*)\)\=:\=', './', '')
                                endif
                              endfor
                              return a:cmd

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 65 times
Total time:   0.073665
 Self time:   0.011284

count  total (s)   self (s)
   65   0.073539   0.011157   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  262()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:528
Called 41 times
Total time:   0.001049
 Self time:   0.001049

count  total (s)   self (s)
   41              0.001009     return '.. (up a dir)'

FUNCTION  263()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/event.vim:6
Called 491 times
Total time:   0.011607
 Self time:   0.011607

count  total (s)   self (s)
  491              0.003308     let newObj = copy(self)
  491              0.001783     let newObj.nerdtree = a:nerdtree
  491              0.001512     let newObj.subject = a:subject
  491              0.001463     let newObj.action = a:action
  491              0.001477     let newObj.params = a:params
  491              0.000987     return newObj

FUNCTION  265()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:14
Called 491 times
Total time:   0.736318
 Self time:   0.059979

count  total (s)   self (s)
  491   0.020704   0.009097     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)

  982   0.029414   0.009227     for Listener in s:Notifier.GetListenersForEvent(a:event)
  491              0.008572     	let Callback = type(Listener) == type(function('tr')) ? Listener : function(Listener)
  491   0.667987   0.023443         call Callback(event)
  982              0.002417     endfor

FUNCTION  266()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:23
Called 491 times
Total time:   0.007980
 Self time:   0.007980

count  total (s)   self (s)
  491              0.003029     if !exists('s:refreshListenersMap')
                                    let s:refreshListenersMap = {}
  491              0.001591     endif
  491              0.001093     return s:refreshListenersMap

FUNCTION  267()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:30
Called 491 times
Total time:   0.020187
 Self time:   0.012207

count  total (s)   self (s)
  491   0.015393   0.007413     let listenersMap = s:Notifier.GetListenersMap()
  491              0.003159     return get(listenersMap, a:name, [])

FUNCTION  <SNR>110_shellesc()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:58
Called 20 times
Total time:   0.000565
 Self time:   0.000554

count  total (s)   self (s)
   20              0.000078   if type(a:arg) == type([])
                                return join(map(copy(a:arg), 's:shellesc(v:val)'))
   20              0.000301   elseif a:arg =~# '^[A-Za-z0-9_/:.-]\+$'
   18              0.000030     return a:arg
    2   0.000032   0.000021   elseif s:winshell()
                                return '"' . s:gsub(s:gsub(a:arg, '"', '""'), '\%', '"%"') . '"'
    2              0.000002   else
    2              0.000008     return shellescape(a:arg)
                              endif

FUNCTION  <SNR>110_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:104
Called 796 times
Total time:   0.011344
 Self time:   0.011344

count  total (s)   self (s)
  796              0.004697   if exists('+shellslash')
                                return tr(a:path, '\', '/')
  796              0.000767   else
  796              0.001925     return a:path
                              endif

FUNCTION  <SNR>127_adjust_screen()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:252
Called 25 times
Total time:   0.001709
 Self time:   0.001709

count  total (s)   self (s)
   25              0.000083     if s:save_direction != 'b'
                                    " Forward
   25              0.000148         keepjumps call setpos('.', s:orig_line_start)
   25              0.001180         normal! zt
                                else
                                    " Backward
                                    keepjumps call setpos('.', s:orig_line_end)
                                    normal! zb
   25              0.000025     endif

FUNCTION  416()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/NoInsert.vim:47
Called 15 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
   15              0.000102 		return char2nr(a:char) == 128 || char2nr(a:char) < 27

FUNCTION  435()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:392
Called 1 time
Total time:   0.292729
 Self time:   0.000032

count  total (s)   self (s)
    1   0.292727   0.000031       return s:common_sink(self._action, a:lines)

FUNCTION  <SNR>245_set_clean_variables()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim:67
Called 3 times
Total time:   0.000322
 Self time:   0.000322

count  total (s)   self (s)
    3              0.000097   let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
    3              0.000096   if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') && type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
    3              0.000014     let var[a:vcs].dirty=a:val
    3              0.000005     try
    3              0.000073       call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
    3              0.000017       unlet! b:airline_head
                                catch
    3              0.000004     endtry
    3              0.000002   endif

FUNCTION  polyglot#sleuth#GlobForFiletype()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/polyglot/sleuth.vim:637
Called 7 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    7              0.000039   return get(s:globs, a:type, '')

FUNCTION  EasyMotion#command_line#GetInput()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/command_line.vim:170
Called 1 time
Total time:   0.299335
 Self time:   0.000119

count  total (s)   self (s)
    1              0.000006     let s:num_strokes = a:num_strokes

    1   0.000070   0.000017     let s:prompt_base = s:getPromptMessage(a:num_strokes)
    1   0.000017   0.000012     call s:search.set_prompt(s:prompt_base)

                                " Screen: cursor position, first and last line
    1              0.000006     let s:orig_pos = getpos('.')
    1              0.000008     let s:orig_line_start = getpos('w0')
    1              0.000004     let s:orig_line_end = getpos('w$')
    1              0.000006     let s:save_orig_pos = deepcopy(s:orig_pos)

                                " Direction:
    1              0.000004     let s:direction = a:direction == 1 ? 'b' : ''
    1              0.000004     let s:save_direction = deepcopy(s:direction)

    1   0.298924   0.000012     let input = s:search.get()
    1   0.000012   0.000009     if input == '' && ! s:search.exit_code()
                                    return a:prev
    1   0.000010   0.000008     elseif s:search.exit_code() == 1 || s:search.exit_code() == -1
    1   0.000252   0.000010         call s:Cancell()
    1              0.000002         return ''
                                else
                                    return input
                                endif

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:158
Called 265 times
Total time:   0.004798
 Self time:   0.004798

count  total (s)   self (s)
  265              0.001790   if !exists("s:has_lawrencium")
                                let s:has_lawrencium  = exists('*lawrencium#statusline')
  265              0.000954   endif
  265              0.000587   return s:has_lawrencium

FUNCTION  <SNR>136_get()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Palette/Highlight.vim:99
Called 1 time
Total time:   0.000550
 Self time:   0.000073

count  total (s)   self (s)
    1              0.000020 	if !hlexists(a:name)
                            		return {}
    1              0.000001 	endif
    1   0.000511   0.000034 	let result = s:parse(substitute(s:capture(a:name), "\n", "", "g"))
    1              0.000006 	if has_key(result, "link") && get(a:, 1, 0)
                            		return s:get(result.link, get(a:, 1, 0))
    1              0.000001 	else
    1              0.000002 		return result
                            	endif

FUNCTION  <SNR>63_CursorHoldUpdate()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:397
Called 51 times
Total time:   1.279698
 Self time:   0.012160

count  total (s)   self (s)
   51              0.000820   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
   51              0.000063   endif

   51   0.005478   0.001147   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
    3              0.000006     return
   48              0.000057   endif

                              " Do not update when a special buffer is selected
   48              0.000430   if !empty(&l:buftype)
    8              0.000014     return
   40              0.000034   endif

                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
   40              0.000280   let l:winnr = winnr()
   40              0.000220   let l:altwinnr = winnr('#')

   40   0.022485   0.000673   call g:NERDTree.CursorToTreeWin()
   40   0.836541   0.001090   call b:NERDTree.root.refreshFlags()
   40   0.406488   0.000546   call NERDTreeRender()

   40              0.001318   exec l:altwinnr . 'wincmd w'
   40              0.004515   exec l:winnr . 'wincmd w'

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:62
Called 3049 times
Total time:   1.047088
 Self time:   0.487406

count  total (s)   self (s)
                              " only check for the cterm reverse attribute
                              " TODO: do we need to check all modes (gui, term, as well)?
 3049              0.046989   let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
 3049              0.022512   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
 3049              0.003533   else
 3049   0.194906   0.056593     let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
 3049   0.185844   0.051174     let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
 3049   0.183537   0.055284     let guifg = s:get_syn(a:group, 'fg', 'gui')
 3049   0.177295   0.053536     let guibg = s:get_syn(a:group, 'bg', 'gui')
 3049              0.031999     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
 3049              0.005367     if reverse
                                  let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
 3049              0.003171     else
 3049   0.096879   0.062193       let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
 3049              0.003448     endif
 3049              0.002129   endif
 3049              0.024291   let s:hl_groups[a:group] = res
 3049              0.006004   return res

FUNCTION  <SNR>9_detect_indent()
    Defined: ~/.vim/plugged/vim-polyglot/ftdetect/polyglot.vim:2834
Called 9 times
Total time:   0.035070
 Self time:   0.001538

count  total (s)   self (s)
    9              0.000050     if &buftype ==# 'help'
                                  return
    9              0.000007     endif

                                " Do not autodetect indent if language or user sets it
    9              0.000033     if &l:shiftwidth != s:default_shiftwidth
                                  return
    9              0.000005     endif

    9              0.000576     let b:sleuth_culprit = expand("<afile>:p")
    9   0.027650   0.000379     if s:guess(getline(1, 128))
    2              0.000002       return
    7              0.000005     endif
    7   0.006443   0.000227     if s:guess(getline(1, 1024))
                                  return
    7              0.000004     endif
    7   0.000166   0.000121     let pattern = polyglot#sleuth#GlobForFiletype(&filetype)
    7              0.000023     if len(pattern) == 0
    7              0.000007       return
                                endif
                                let pattern = '{' . pattern . ',.git,.svn,.hg}'
                                let dir = expand('%:p:h')
                                let level = 3
                                while isdirectory(dir) && dir !=# fnamemodify(dir, ':h') && level > 0
                                  " Ignore files from homedir and root
                                  if dir == expand('~') || dir == '/'
                                    unlet b:sleuth_culprit
                                    return
                                  endif
                                  for neighbor in glob(dir . '/' . pattern, 0, 1)[0:level]
                                    let b:sleuth_culprit = neighbor
                                    " Do not consider directories above .git, .svn or .hg
                                    if fnamemodify(neighbor, ":h:t")[0] == "."
                                      let level = 0
                                      continue
                                    endif
                                    if neighbor !=# expand('%:p') && filereadable(neighbor)
                                      if s:guess(readfile(neighbor, '', 32))
                                        return
                                      endif
                                    endif
                                  endfor

                                  let dir = fnamemodify(dir, ':h')
                                  let level -= 1
                                endwhile

                                let b:sleuth_culprit = "default"

FUNCTION  EasyMotion#helper#VarReset()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/helper.vim:111
Called 2 times
Total time:   0.000112
 Self time:   0.000105

count  total (s)   self (s)
    2              0.000010     if ! exists('s:var_reset')
    1              0.000004         let s:var_reset = {}
    2              0.000002     endif

    2              0.000010     if a:0 == 0 && has_key(s:var_reset, a:var)
                                    " Reset var to original value
                                    " setbufvar( or bufname): '' or '%' can be used for the current buffer
    1   0.000018   0.000015         call setbufvar('%', a:var, s:var_reset[a:var])
    1              0.000002     elseif a:0 == 1
                                    " Save original value and set new var value

    1              0.000004         let new_value = a:0 == 1 ? a:1 : ''

                                    " Store original value
    1              0.000009         let s:var_reset[a:var] = getbufvar("", a:var)

                                    " Set new var value
    1   0.000020   0.000016         call setbufvar('%', a:var, new_value)
    2              0.000002     endif

FUNCTION  coc#task#running()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/task.vim:163
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000011   if !has_key(s:running_task, a:id) == 1
    1              0.000003     return v:false
                              endif
                              let job = s:running_task[a:id]
                              if s:is_vim
                                let status = job_status(job)
                                return status ==# 'run'
                              endif
                              let [code] = jobwait([job], 10)
                              return code == -1

FUNCTION  <SNR>131_sort_by()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Data/List.vim:120
Called 77 times
Total time:   0.050985
 Self time:   0.011637

count  total (s)   self (s)
   77              0.008277   let pairs = map(a:list, printf('[v:val, %s]', a:expr))
   77   0.042615   0.003267   return map(s:sort(pairs,      'a:a[1] ==# a:b[1] ? 0 : a:a[1] ># a:b[1] ? 1 : -1'), 'v:val[0]')

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:28
Called 988 times
Total time:   0.078251
 Self time:   0.051018

count  total (s)   self (s)
  988   0.058569   0.031336   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
  988              0.000729   else
  988              0.001860     return a:text
                              endif

FUNCTION  271()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:120
Called 1 time
Total time:   0.080541
 Self time:   0.000171

count  total (s)   self (s)
    1   0.000118   0.000089   let path = s:strip_trailing_new_line(a:path)
    1   0.000076   0.000028   call gitgutter#utility#setbufvar(a:buffer, 'path', path)

    1              0.000013   if type(self.continuation) == type(function('tr'))
    1   0.080320   0.000026     call self.continuation()
                              else
                                call call(self.continuation.function, self.continuation.arguments)
    1              0.000001   endif

FUNCTION  coc#util#set_buf_var()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:872
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000009   if !bufloaded(a:bufnr) | return | endif
    1              0.000012   call setbufvar(a:bufnr, a:name, a:val)

FUNCTION  <SNR>90_wrap_accent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:9
Called 7 times
Total time:   0.000296
 Self time:   0.000240

count  total (s)   self (s)
    7              0.000043   if exists('a:part.accent')
    7   0.000169   0.000112     call airline#highlighter#add_accent(a:part.accent)
    7              0.000070     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  FugitiveConfigGetAll()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:114
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000005   if a:0 && type(a:1) ==# type({})
    1              0.000002     let config = a:1
                              else
                                let config = fugitive#Config(FugitiveGitDir(a:0 ? a:1 : -1))
    1              0.000001   endif
    1              0.000028   let name = substitute(a:name, '^[^.]\+\|[^.]\+$', '\L&', 'g')
    1              0.000007   return copy(get(config, name, []))

FUNCTION  coc#float#nvim_refresh_scrollbar()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:765
Called 64 times
Total time:   0.007659
 Self time:   0.004560

count  total (s)   self (s)
   64   0.006890   0.003791   let id = coc#float#get_related(a:winid, 'scrollbar')
   64              0.000279   if id && nvim_win_is_valid(id)
                                call coc#float#nvim_scrollbar(a:winid)
   64              0.000070   endif

FUNCTION  <SNR>135_get()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules.vim:26
Called 15 times
Total time:   0.046723
 Self time:   0.000551

count  total (s)   self (s)
   15              0.000086 	if exists("s:" . a:name)
                            		return s:{a:name}
   15              0.000013 	endif
   15   0.046497   0.000325 	let s:{a:name} = s:V.import('Over.Commandline.Modules.' . a:name)
   15              0.000065 	return s:{a:name}

FUNCTION  <SNR>151__vital_loaded()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/KeyMapping.vim:21
Called 1 time
Total time:   0.004333
 Self time:   0.000017

count  total (s)   self (s)
    1   0.004332   0.000016 	let s:Keymapping = a:V.import("Palette.Keymapping")

FUNCTION  <SNR>110_FormatFile()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1676
Called 12 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
   12              0.000049   return a:dict.status . ' ' . a:dict.filename

FUNCTION  <SNR>28_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:83
Called 64 times
Total time:   0.005552
 Self time:   0.004646

count  total (s)   self (s)
   64              0.000770   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
   64              0.000081   endif
   64   0.004246   0.003339   call airline#update_tabline()

FUNCTION  <SNR>94_init_buffer()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:51
Called 2 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    2              0.000007   let b:buffer_vcs_config = {}
    6              0.000017   for vcs in keys(s:vcs_config)
    4              0.000028     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',     'dirty': 0,   }
    6              0.000006   endfor
    2              0.000004   unlet! b:airline_head

FUNCTION  241()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:273
Called 287 times
Total time:   0.000907
 Self time:   0.000907

count  total (s)   self (s)
  287              0.000693     return self._showFiles

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:223
Called 35 times
Total time:   0.022930
 Self time:   0.002584

count  total (s)   self (s)
   35              0.000282   if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
   35              0.000043   else
   35              0.000731     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
   35              0.000043   endif

   35              0.000120   if !empty(colors)
   35   0.021255   0.000909     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   35              0.000032   endif

FUNCTION  polyglot#shebang#Detect()
    Defined: ~/.vim/plugged/vim-polyglot/autoload/polyglot/shebang.vim:5
Called 6 times
Total time:   0.008104
 Self time:   0.000456

count  total (s)   self (s)
    6   0.000305   0.000159   let ft = s:Filetype()
    6              0.000018   if ft != ""
                                let &ft = ft
                                return 1
    6              0.000008   endif

    6   0.007671   0.000168   let err = polyglot#shebang#VimDetect()
    6              0.000018   if err == ""
                                return 1
    6              0.000006   endif

    6              0.000009   return 0

FUNCTION  <SNR>104_add_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 179 times
Total time:   0.033851
 Self time:   0.012034

count  total (s)   self (s)
  179              0.001615     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
  179   0.004523   0.001958     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
    4              0.000005       return
  175              0.000144     endif
  175              0.000272     if condition
                                  call a:builder.add_raw('%(')
  175              0.000140     endif
  175   0.024256   0.005003     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
  175              0.000401     if condition
                                  call a:builder.add_raw('%)')
  175              0.000157     endif

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:308
Called 257 times
Total time:   0.788891
 Self time:   0.033927

count  total (s)   self (s)
  257   0.738629   0.005841   let head = airline#extensions#branch#head()
  257   0.016102   0.013358   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
  257              0.002045   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
  257   0.025311   0.005878   let head = airline#util#shorten(head, winwidth, minwidth)
  257              0.002179   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  257              0.003655   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  286()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:17
Called 189 times
Total time:   0.001555
 Self time:   0.001555

count  total (s)   self (s)
  189              0.001380   call add(self._sections, [a:group, a:contents])

FUNCTION  <SNR>94_update_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:87
Called 257 times
Total time:   0.468172
 Self time:   0.072564

count  total (s)   self (s)
  257   0.019249   0.013653   call airline#util#ignore_next_focusgain()
  257   0.010509   0.006229   if !airline#util#has_fugitive() && !airline#util#has_gina()
                                let s:vcs_config['git'].branch = ''
                                return
  257              0.000193   endif
  257   0.013252   0.009404   if airline#util#has_fugitive()
  257   0.400446   0.023722     let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
  257   0.012679   0.007519     if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                  " Shorten default a bit
                                  let s:vcs_config['git'].branch='mas'
  257              0.000339     endif
                              else
                                try
                                  let g:gina#component#repo#commit_length = s:sha1size
                                  let s:vcs_config['git'].branch = gina#component#repo#branch()
                                catch
                                endtry
                                if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                  " Shorten default a bit
                                  let s:vcs_config['git'].branch='mas'
                                endif
  257              0.000203   endif

FUNCTION  <SNR>123_extend_opts()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:88
Called 4 times
Total time:   0.001070
 Self time:   0.000490

count  total (s)   self (s)
    4              0.000021   if empty(a:eopts)
                                return
    4              0.000004   endif
    4              0.000017   if has_key(a:dict, 'options')
    2              0.000019     if type(a:dict.options) == s:TYPE.list && type(a:eopts) == s:TYPE.list
                                  if a:prepend
                                    let a:dict.options = extend(copy(a:eopts), a:dict.options)
                                  else
                                    call extend(a:dict.options, a:eopts)
                                  endif
    2              0.000002     else
    2              0.000021       let all_opts = a:prepend ? [a:eopts, a:dict.options] : [a:dict.options, a:eopts]
    2   0.000860   0.000280       let a:dict.options = join(map(all_opts, 'type(v:val) == s:TYPE.list ? join(map(copy(v:val), "fzf#shellescape(v:val)")) : v:val'))
    2              0.000003     endif
    2              0.000001   else
    2              0.000007     let a:dict.options = a:eopts
    4              0.000003   endif

FUNCTION  coc#rpc#notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:95
Called 190 times
Total time:   0.090371
 Self time:   0.019018

count  total (s)   self (s)
  190   0.015133   0.009070   if !coc#rpc#ready()
                                return ''
  190              0.000241   endif
  190   0.072778   0.007487   call s:client['notify'](a:method, a:args)
  190              0.000562   return ''

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:95
Called 241 times
Total time:   0.249994
 Self time:   0.146276

count  total (s)   self (s)
  241              0.001636   if !get(w:, 'airline_active', 0)
                                return ''
  241              0.000475   endif
                              " Cache values, so that it isn't called too often
  241   0.019336   0.014409   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
  241              0.000280   endif
  241   0.086392   0.008557   let hunks = airline#extensions#hunks#get_raw_hunks()
  241              0.000780   let string = ''
  241   0.007659   0.005602   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
  241              0.000945   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
  936              0.002531     for i in [0, 1, 2]
  702   0.080076   0.066988       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
  702              0.008487         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  702              0.000840       endif
  936              0.003125     endfor
  241              0.000223   endif
  241   0.013116   0.011862   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
                                let string = string[0:-2]
  241              0.000236   endif

  241              0.001155   let b:airline_hunks = string
  241              0.000914   let b:airline_changenr = b:changedtick
  241   0.011547   0.006988   let s:airline_winwidth = airline#util#winwidth()
  241              0.001231   return string

FUNCTION  <SNR>248_handle_double_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:212
Called 4 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    4              0.000048   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
    4              0.000004   endif

    4              0.000008   return a:modified_lines

FUNCTION  <SNR>110_winshell()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:44
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000010   return has('win32') && &shellcmdflag !~# '^-'

FUNCTION  coc#float#valid()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:175
Called 3 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
    3              0.000015   if a:winid <= 0
                                return 0
    3              0.000005   endif
    3              0.000022   if has('nvim')
    3              0.000087     return nvim_win_is_valid(a:winid) ? 1 : 0
                              endif
                              return s:popup_visible(a:winid)

FUNCTION  <SNR>26_get_color()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:306
Called 26 times
Total time:   0.006190
 Self time:   0.006190

count  total (s)   self (s)
   26              0.000681   let gui = !s:is_win && !has('win32unix') && has('termguicolors') && &termguicolors
   26              0.000140   let fam = gui ? 'gui' : 'cterm'
   26              0.000096   let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
   30              0.000218   for group in a:000
   30              0.003651     let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
   30              0.000967     if code =~? pat
   26              0.000139       return code
    4              0.000012     endif
    4              0.000005   endfor
                              return ''

FUNCTION  fzf#vim#gitfiles()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:610
Called 2 times
Total time:   0.265057
 Self time:   0.000202

count  total (s)   self (s)
    2   0.035790   0.000049   let root = s:get_git_root()
    2              0.000009   if empty(root)
                                return s:warn('Not in git repo')
    2              0.000003   endif
    2              0.000006   if a:args != '?'
    2   0.229228   0.000114     return s:fzf('gfiles', { 'source':  'git ls-files '.a:args.(s:is_win ? '' : ' | uniq'), 'dir':     root, 'options': '-m --prompt "GitFiles> "'}, a:000)
                              endif

                              " Here be dragons!
                              " We're trying to access the common sink function that fzf#wrap injects to
                              " the options dictionary.
                              let preview = printf( 'bash -c "if [[ {1} =~ M ]]; then %s; else %s {-1}; fi"', executable('delta') ? 'git diff -- {-1} | delta --file-style=omit | sed 1d' : 'git diff --color=always -- {-1} | sed 1,4d', s:bin.preview)
                              let wrapped = fzf#wrap({ 'source':  'git -c color.status=always status --short --untracked-files=all', 'dir':     root, 'options': ['--ansi', '--multi', '--nth', '2..,..', '--tiebreak=index', '--prompt', 'GitFiles?> ', '--preview', preview]})
                              call s:remove_layout(wrapped)
                              let wrapped.common_sink = remove(wrapped, 'sink*')
                              function! wrapped.newsink(lines)
                                let lines = extend(a:lines[0:0], map(a:lines[1:], 'substitute(v:val[3:], ".* -> ", "", "")'))
                                return self.common_sink(lines)
                              endfunction
                              let wrapped['sink*'] = remove(wrapped, 'newsink')
                              return s:fzf('gfiles-diff', wrapped, a:000)

FUNCTION  <SNR>56_on_bufenter()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:219
Called 9 times
Total time:   0.013312
 Self time:   0.000656

count  total (s)   self (s)
    9   0.003571   0.000117   call gitgutter#setup_maps()

                              " To keep vim's start-up fast, do not process the buffer when vim is starting.
                              " Instead process it a short time later.  Normally we would rely on our
                              " CursorHold autocommand to handle this but it turns out CursorHold is not
                              " guaranteed to fire if the user has not typed anything yet; so set up a
                              " timer instead.  The disadvantage is that if CursorHold does fire, the
                              " plugin will do a round of unnecessary work; but since there will not have
                              " been any changes to the buffer since the first round, the second round
                              " will be cheap.
    9              0.000063   if has('vim_starting') && !$VIM_GITGUTTER_TEST
                                if exists('*timer_start')
                                  call timer_start(&updatetime, 'GitGutterCursorHold')
                                endif
                                return
    9              0.000007   endif

    9              0.000044   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
    9              0.000008   else
    9   0.009413   0.000211     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
    9              0.000008   endif

FUNCTION  <SNR>26_has_any()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:248
Called 4 times
Total time:   0.000304
 Self time:   0.000304

count  total (s)   self (s)
   20              0.000058   for key in a:keys
   16              0.000127     if has_key(a:dict, key)
                                  return 1
   16              0.000015     endif
   20              0.000024   endfor
    4              0.000009   return 0

FUNCTION  <SNR>26_default_layout()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:129
Called 2 times
Total time:   0.000375
 Self time:   0.000256

count  total (s)   self (s)
    2   0.000371   0.000252   return s:popup_support() ? { 'window' : { 'width': 0.9, 'height': 0.6 } } : { 'down': '~40%' }

FUNCTION  291()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:62
Called 40 times
Total time:   0.422478
 Self time:   0.047368

count  total (s)   self (s)
   40              0.000094   let side = 1
   40              0.000074   let line = ''
   40              0.000063   let i = 0
   40              0.000200   let length = len(self._sections)
   40              0.000079   let split = 0
   40              0.000080   let is_empty = 0
   40              0.000146   let prev_group = ''

  267              0.000666   while i < length
  227              0.000950     let section = self._sections[i]
  227              0.000739     let group = section[0]
  227              0.000704     let contents = section[1]
  227              0.000608     let pgroup = prev_group
  227   0.009885   0.004715     let prev_group = airline#builder#get_prev_group(self._sections, i)
  227              0.001077     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
    2              0.000004       let group = 'airline_term'
  225              0.001857     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
   12              0.000049       let group = 'airline_c'. self._context.bufnr
  213              0.001308     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
   12              0.000055       let prev_group = 'airline_c'. self._context.bufnr
  227              0.000199     endif
  227              0.000328     if is_empty
                                  let prev_group = pgroup
  227              0.000198     endif
  227   0.011135   0.004930     let is_empty = s:section_is_empty(self, contents)

  227              0.000351     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
  227              0.000185     endif

  227              0.000500     if group == ''
                                  let line .= contents
  227              0.000466     elseif group == '|'
   38              0.000057       let side = 0
   38              0.000129       let line .= contents
   38              0.000057       let split = 1
  189              0.000155     else
  189              0.000400       if prev_group == ''
   40              0.000297         let line .= '%#'.group.'#'
  149              0.000207       elseif split
   23              0.000029         if !is_empty
   23   0.035636   0.000534           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   23              0.000026         endif
   23              0.000049         let split = 0
  126              0.000099       else
  126              0.000193         if !is_empty
  126   0.312666   0.002839           let line .= s:get_seperator(self, prev_group, group, side)
  126              0.000152         endif
  189              0.000221       endif
  189   0.023982   0.005175       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
  227              0.000249     endif

  227              0.000592     let i = i + 1
  267              0.000603   endwhile

   40              0.000115   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
   22              0.001482     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
   40              0.000051   endif
   40              0.000090   return line

FUNCTION  294()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:787
Called 1 time
Total time:   0.027679
 Self time:   0.001023

count  total (s)   self (s)
    1   0.000038   0.000021     if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
    1              0.000001     else
    1              0.000004       if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
    1   0.027286   0.000897         close
    1              0.000001       endif
    1              0.000009       silent! execute 'tabnext' self.ppos.tab
    1              0.000006       silent! execute self.ppos.win.'wincmd w'
    1              0.000001     endif

    1              0.000003     if bufexists(self.buf)
                                  execute 'bd!' self.buf
    1              0.000001     endif

    1   0.000030   0.000017     if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
    1              0.000009       execute self.winrest
    1              0.000001     endif

    1   0.000248   0.000016     let lines = s:collect(self.temps)
    1   0.000020   0.000016     if !s:exit_handler(a:code, self.command, 1)
    1              0.000001       return
                                endif

                                call s:pushd(self.dict)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)

FUNCTION  295()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:90
Called 45 times
Total time:   0.000785
 Self time:   0.000445

count  total (s)   self (s)
   45   0.000742   0.000402 	return self.line.str()

FUNCTION  airline#extensions#fzf#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:28
Called 18 times
Total time:   0.000330
 Self time:   0.000308

count  total (s)   self (s)
   18              0.000065   if &filetype ==# 'fzf'
    2              0.000006     let spc = g:airline_symbols.space
    2   0.000031   0.000019     call a:1.add_section('airline_a', spc.'FZF'.spc)
    2   0.000023   0.000013     call a:1.add_section('airline_c', '')
    2              0.000002     return 1
   16              0.000013   endif

FUNCTION  297()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:100
Called 456 times
Total time:   0.001267
 Self time:   0.001267

count  total (s)   self (s)
  456              0.001023 	return self.variables.char

FUNCTION  298()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:105
Called 30 times
Total time:   0.000523
 Self time:   0.000523

count  total (s)   self (s)
                            	" 1 の場合は既に設定されていても上書きする
                            	" 0 の場合は既に設定されていれば上書きしない
   30              0.000153 	let overwrite = get(a:, 1, 1)
   30              0.000098 	if overwrite || self.variables.is_setted == 0
   23              0.000076 		let self.variables.input = a:char
   23              0.000050 		let self.variables.is_setted = 1
   30              0.000028 	endif

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 458 times
Total time:   0.017091
 Self time:   0.017091

count  total (s)   self (s)
  458              0.004763   let ggvars = getbufvar(a:buffer, 'gitgutter')
  458              0.007428   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
  344              0.001529     return ggvars[a:varname]
  114              0.000175   endif
  114              0.000239   if a:0
  112              0.000310     return a:1
    2              0.000001   endif

FUNCTION  vital#_easymotion#Data#List#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Data/List.vim:5
Called 1 time
Total time:   0.000237
 Self time:   0.000237

count  total (s)   self (s)
    1              0.000236     return map({'combinations': '', 'and': '', 'sort_by': '', 'foldr1': '', 'sort': '', 'flatten': '', 'has_index': '', 'find_indices': '', 'any': '', 'unshift': '', 'span': '', 'pop': '', 'binary_search': '', 'uniq_by': '', 'or': '', 'all': '', 'zip': '', 'find_last_index': '', 'find': '', 'partition': '', 'map_accum': '', 'permutations': '', 'break': '', 'max_by': '', 'foldl': '', 'foldr': '', 'find_index': '', 'group_by': '', 'take_while': '', 'conj': '', 'push': '', 'char_range': '', 'cons': '', 'foldl1': '', 'intersect': '', 'concat': '', 'shift': '', 'clear': '', 'has_common_items': '', 'product': '', 'zip_fill': '', 'uniq': '', 'has': '', 'min_by': '', 'with_index': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>57_not_git_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:59
Called 42 times
Total time:   0.023287
 Self time:   0.003547

count  total (s)   self (s)
   42   0.023203   0.003463   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  FugitiveParse()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:71
Called 8 times
Total time:   0.000323
 Self time:   0.000212

count  total (s)   self (s)
    8   0.000223   0.000112   let path = s:Slash(a:0 ? a:1 : @%)
    8              0.000070   if path !~# '^fugitive:'
    8              0.000019     return ['', '']
                              endif
                              let vals = matchlist(path, '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if len(vals)
                                return [(vals[2] =~# '^.$' ? ':' : '') . vals[2] . substitute(vals[3], '^/', ':', ''), vals[1]]
                              endif
                              let v:errmsg = 'fugitive: invalid Fugitive URL ' . path
                              throw v:errmsg

FUNCTION  <SNR>149_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/History.vim:68
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000007 	let module = deepcopy(s:module)
    1              0.000006 	let module.mode = get(a:, 1, "cmd")
    1              0.000002 	return module

FUNCTION  <SNR>142_make()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/Delete.vim:50
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000008 	return deepcopy(s:module)

FUNCTION  <SNR>107_findMotion()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:527
Called 1 time
Total time:   0.384838
 Self time:   0.000454

count  total (s)   self (s)
                                " Find Motion: S,F,T
    1              0.000006     let s:current.is_operator = mode(1) ==# 'no' ? 1: 0
                                " store cursor pos because 'n' key find motion could be jump to offscreen
    1              0.000008     let s:current.original_position = [line('.'), col('.')]
    1              0.000004     let s:current.is_search = a:num_strokes == -1 ? 1: 0
    1              0.000003     let s:flag.regexp = a:num_strokes == -1 ? 1 : 0 " TODO: remove?

    1              0.000004     if g:EasyMotion_add_search_history && a:num_strokes == -1
    1              0.000005         let s:previous['input'] = @/
                                else
                                    let s:previous['input'] = get(s:previous, 'input', '')
    1              0.000001     endif
    1   0.384786   0.000403     let input = EasyMotion#command_line#GetInput( a:num_strokes, s:previous.input, a:direction)
    1              0.000005     let s:previous['input'] = input

                                " Check that we have an input char
    1              0.000003     if empty(input)
    1              0.000001         return ''
                                endif

                                let re = s:convertRegep(input)

                                if g:EasyMotion_add_search_history && a:num_strokes == -1
                                    let history_re = substitute(re, '\\c\|\\C', '', '')
                                    let @/ = history_re "For textobject: 'gn'
                                    call histadd('search', history_re)
                                endif

                                return re

FUNCTION  fugitive#MapCfile()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:5906
Called 1 time
Total time:   0.001417
 Self time:   0.000172

count  total (s)   self (s)
    1              0.000081   exe 'cnoremap <buffer> <expr> <Plug><cfile>' (a:0 ? a:1 : 'fugitive#Cfile()')
    1              0.000011   let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|sil! exe "cunmap <buffer> <Plug><cfile>"'
    1              0.000004   if !exists('g:fugitive_no_maps')
    1   0.000330   0.000016     call s:Map('n', 'gf',          '<SID>:find <Plug><cfile><CR>', '<silent><unique>', 1)
    1   0.000247   0.000015     call s:Map('n', '<C-W>f',     '<SID>:sfind <Plug><cfile><CR>', '<silent><unique>', 1)
    1   0.000243   0.000014     call s:Map('n', '<C-W><C-F>', '<SID>:sfind <Plug><cfile><CR>', '<silent><unique>', 1)
    1   0.000266   0.000014     call s:Map('n', '<C-W>gf',  '<SID>:tabfind <Plug><cfile><CR>', '<silent><unique>', 1)
    1   0.000232   0.000013     call s:Map('c', '<C-R><C-F>', '<Plug><cfile>', '<silent><unique>', 1)
    1              0.000001   endif

FUNCTION  <SNR>28_init()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:15
Called 15 times
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
   15              0.000041   if s:airline_initialized
   15              0.000020     return
                              endif
                              let s:airline_initialized = 1

                              call airline#extensions#load()
                              call airline#init#sections()

                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  if g:airline_theme is# 'random'
                                    let g:airline_theme=s:random_theme()
                                  endif
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                endtry
                                try
                                  silent call airline#switch_theme(g:airline_theme)
                                catch
                                  call airline#util#warning(printf('Could not find airline theme "%s".', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                  silent call airline#switch_theme(g:airline_theme)
                                endtry
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif

                              call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  <SNR>94_display_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim:115
Called 8 times
Total time:   0.001116
 Self time:   0.000682

count  total (s)   self (s)
                              " disable FocusGained autocommand, might cause loops because system() causes
                              " a refresh, which causes a system() command again #2029
    8   0.000254   0.000144   call airline#util#ignore_next_focusgain()
    8              0.000037   let name = b:buffer_vcs_config['git'].branch
    8              0.000010   try
    8   0.000489   0.000166     let commit = matchstr(FugitiveParse()[0], '^\x\+')

    8              0.000032     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
    8              0.000024     elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
    8              0.000005     endif
                              catch
    8              0.000009   endtry
    8              0.000013   return name

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:58
Called 3 times
Total time:   0.001286
 Self time:   0.001286

count  total (s)   self (s)
    3              0.001271   let s:hl_groups = {}

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:63
Called 1245 times
Total time:   0.019940
 Self time:   0.019940

count  total (s)   self (s)
 1245              0.008710   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 1245              0.000932   endif
 1245              0.006440   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  nerdtree#compareNodePaths()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:119
Called 33 times
Total time:   0.010495
 Self time:   0.002111

count  total (s)   self (s)
   33   0.005600   0.000246     let sortKey1 = a:p1.getSortKey()
   33   0.003342   0.000313     let sortKey2 = a:p2.getSortKey()
   33              0.000053     let i = 0
   56              0.000346     while i < min([len(sortKey1), len(sortKey2)])
                                    " Compare chunks upto common length.
                                    " If chunks have different type, the one which has
                                    " integer type is the lesser.
   56              0.000272         if type(sortKey1[i]) ==# type(sortKey2[i])
   56              0.000152             if sortKey1[i] <# sortKey2[i]
   16              0.000020                 return - 1
   40              0.000111             elseif sortKey1[i] ># sortKey2[i]
   17              0.000019                 return 1
   23              0.000017             endif
                                    elseif type(sortKey1[i]) ==# v:t_number
                                        return -1
                                    elseif type(sortKey2[i]) ==# v:t_number
                                        return 1
   23              0.000015         endif
   23              0.000040         let i = i + 1
   23              0.000020     endwhile

                                " Keys are identical upto common length.
                                " The key which has smaller chunks is the lesser one.
                                if len(sortKey1) < len(sortKey2)
                                    return -1
                                elseif len(sortKey1) > len(sortKey2)
                                    return 1
                                else
                                    return 0
                                endif

FUNCTION  <SNR>246_write_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:375
Called 4 times
Total time:   0.003034
 Self time:   0.003034

count  total (s)   self (s)
    4              0.000314   let bufcontents = getbufline(a:bufnr, 1, '$')

    4              0.000031   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
    4              0.000005   endif

    4              0.000039   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
    4              0.000004   endif

    4              0.000020   if getbufvar(a:bufnr, '&endofline')
    4              0.000022     call add(bufcontents, '')
    4              0.000004   endif

    4              0.000024   let fenc = getbufvar(a:bufnr, '&fileencoding')
    4              0.000014   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
    4              0.000004   endif

    4              0.000019   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
    4              0.000004   endif

                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
    4              0.000006   try
    4              0.002287     call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
    4              0.000025   endtry

FUNCTION  <SNR>110_fnameescape()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:71
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000005   if type(a:file) == type([])
                                return join(map(copy(a:file), 's:fnameescape(v:val)'))
    1              0.000004   elseif exists('*fnameescape')
    1              0.000005     return fnameescape(a:file)
                              else
                                return escape(a:file, s:fnameescape)
                              endif

FUNCTION  <SNR>110_ReloadWinStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:2879
Called 6 times
Total time:   0.000360
 Self time:   0.000275

count  total (s)   self (s)
    6              0.000173   if get(b:, 'fugitive_type', '') !=# 'index' || &modified
    5              0.000011     return
    1              0.000001   endif
    1              0.000005   if !exists('b:fugitive_reltime')
                                exe s:ReloadStatusBuffer()
                                return
    1              0.000001   endif
    1              0.000003   let t = b:fugitive_reltime
    1   0.000143   0.000058   if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' || reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatusBuffer()
    1              0.000001   endif

FUNCTION  <SNR>128__exists_autoload_func_with_source()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:240
Called 27 times
Total time:   0.060174
 Self time:   0.002504

count  total (s)   self (s)
   27              0.000223   if exists('*' . a:funcname)
                                " Return true if a given func is already defined
                                return 1
   27              0.000025   endif
                              " source a file which may include a given func definition and try again.
   27              0.001218   let path = 'autoload/' . substitute(substitute(a:funcname, '#[^#]*$', '.vim', ''), '#', '/', 'g')
   27   0.058198   0.000528   call s:_runtime(path)
   27              0.000341   return exists('*' . a:funcname)

FUNCTION  <SNR>123_blue()
    Defined: ~/.vim/plugged/fzf.vim/autoload/fzf/vim.vim:263
Called 1 time
Total time:   0.000321
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000319   0.000029    return s:ansi(a:str, get(a:, 1, ''), 'blue')

FUNCTION  airline#util#getbufvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:71
Called 58 times
Total time:   0.000514
 Self time:   0.000514

count  total (s)   self (s)
   58              0.000441     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  <SNR>21_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim:164
Called 318 times
Total time:   0.010349
 Self time:   0.010349

count  total (s)   self (s)
  318              0.001330   let dir = a:path
  318              0.006053   if dir =~# '/\.git$'
  271              0.001976     return len(dir) ==# 5 ? '/' : dir[0:-6]
   47              0.000104   elseif dir ==# ''
   47              0.000069     return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = FugitiveVimPath(matchstr(config[0], '= *\zs.*'))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  <SNR>130_length()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:158
Called 15 times
Total time:   0.001165
 Self time:   0.000211

count  total (s)   self (s)
   15   0.001153   0.000199 	return len(s:split_by_keys(a:str))

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:499
Called 241 times
Total time:   0.001253
 Self time:   0.001253

count  total (s)   self (s)
  241              0.000953   return s:loaded_ext

FUNCTION  <SNR>26_dopopd()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:541
Called 12 times
Total time:   0.002075
 Self time:   0.001050

count  total (s)   self (s)
   12              0.000067   if !exists('w:fzf_pushd')
    9              0.000012     return
    3              0.000003   endif

                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
    3   0.000194   0.000079   if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
    3   0.001728   0.000818     execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
    3              0.000004   endif
    3              0.000015   unlet! w:fzf_pushd

FUNCTION  fzf#run()
    Defined: ~/.vim/plugged/fzf/plugin/fzf.vim:414
Called 2 times
Total time:   0.149213
 Self time:   0.001448

count  total (s)   self (s)
    2              0.000007 try
    2   0.000246   0.000062   let [shell, shellslash, shellcmdflag, shellxquote] = s:use_sh()

    2              0.000044   let dict   = exists('a:1') ? copy(a:1) : {}
    2   0.000141   0.000070   let temps  = { 'result': s:fzf_tempname() }
    2   0.000090   0.000055   let optstr = s:evaluate_opts(get(dict, 'options', ''))
    2              0.000004   try
    2   0.000609   0.000161     let fzf_exec = fzf#shellescape(fzf#exec())
                              catch
                                throw v:exception
    2              0.000005   endtry

    2              0.000016   if !has_key(dict, 'dir')
                                let dict.dir = s:fzf_getcwd()
    2              0.000002   endif
    2              0.000022   if has('win32unix') && has_key(dict, 'dir')
                                let dict.dir = fnamemodify(dict.dir, ':p')
    2              0.000003   endif

    2              0.000010   if has_key(dict, 'source')
    2              0.000011     let source = dict.source
    2              0.000011     let type = type(source)
    2              0.000005     if type == 1
    2              0.000011       let prefix = '( '.source.' )|'
                                elseif type == 3
                                  let temps.input = s:fzf_tempname()
                                  call writefile(source, temps.input)
                                  let prefix = (s:is_win ? 'type ' : 'cat ').fzf#shellescape(temps.input).'|'
                                else
                                  throw 'Invalid source type'
    2              0.000002     endif
                              else
                                let prefix = ''
    2              0.000002   endif

    2              0.000021   let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0) || has_key(dict, 'tmux')
    2              0.000038   let use_height = has_key(dict, 'down') && !has('gui_running') && !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right', 'window')) && executable('tput') && filereadable('/dev/tty')
    2              0.000024   let has_vim8_term = has('terminal') && has('patch-8.0.995')
    2              0.000033   let has_nvim_term = has('nvim-0.2.1') || has('nvim') && !s:is_win
    2              0.000026   let use_term = has_nvim_term || has_vim8_term && !has('win32unix') && (has('gui_running') || s:is_win || !use_height && s:present(dict, 'down', 'up', 'left', 'right', 'window'))
    2              0.000030   let use_tmux = (has_key(dict, 'tmux') || (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:splittable(dict)) && s:tmux_enabled()
    2              0.000005   if prefer_tmux && use_tmux
                                let use_height = 0
                                let use_term = 0
    2              0.000003   endif
    2              0.000004   if use_height
                                let height = s:calc_size(&lines, dict.down, dict)
                                let optstr .= ' --height='.height
    2              0.000005   elseif use_term
    2              0.000024     let optstr .= ' --no-height'
    2              0.000003   endif
    2   0.010023   0.000106   let optstr .= s:border_opt(get(dict, 'window', 0))
    2              0.000046   let command = prefix.(use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result

    2              0.000005   if use_term
    2   0.137426   0.000325     return s:execute_term(dict, command, temps)
                              endif

                              let lines = use_tmux ? s:execute_tmux(dict, command, temps) : s:execute(dict, command, use_height, temps)
                              call s:callback(dict, lines)
                              return lines
    2              0.000003 finally
    2   0.000053   0.000045   let [&shell, &shellslash, &shellcmdflag, &shellxquote] = [shell, shellslash, shellcmdflag, shellxquote]
    2              0.000007 endtry

FUNCTION  <SNR>128_import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/easymotion.vim:53
Called 31 times
Total time:   0.110379
 Self time:   0.002029

count  total (s)   self (s)
   31              0.000097   let target = {}
   31              0.000075   let functions = []
   31              0.000111   for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
   31              0.000075   endfor
   31   0.069816   0.025085   let module = self._import(a:name)
   31              0.000121   if empty(functions)
   31              0.000454     call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
   31              0.000028   endif
   31              0.000056   return target

FUNCTION  <SNR>130__split_keystring()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/String.vim:139
Called 30 times
Total time:   0.001092
 Self time:   0.001092

count  total (s)   self (s)
   30              0.001067 	return split(a:str, s:_engine . '\m\%(' . get(a:, 1, '') . s:_regex . '\)')

FUNCTION  vital#_easymotion#Over#Keymapping#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Keymapping.vim:5
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000039     return map({'_vital_depends': '', 'unmapping': '', 'as_key_config': '', 'match_key': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  vital#_easymotion#Over#Commandline#Modules#KeyMapping#import()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Modules/KeyMapping.vim:5
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000034     return map({'_vital_depends': '', 'make_emacs': '', 'make_vim_cmdline_mapping': '', '_vital_loaded': ''},  'function("s:" . v:key)')

FUNCTION  <SNR>107_handleEmpty()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion.vim:742
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
                                " if empty, reselect and return 1
    1              0.000003     if empty(a:input)
    1              0.000003         if ! empty(a:visualmode)
                                        silent exec 'normal! gv'
    1              0.000001         endif
    1              0.000003         let s:EasyMotion_is_cancelled = 1 " Cancel
    1              0.000001         return 1
                                endif
                                return 0

FUNCTION  <SNR>97_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:185
Called 53 times
Total time:   0.000943
 Self time:   0.000943

count  total (s)   self (s)
   53              0.000616   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
   48              0.000086     return
    5              0.000007   endif
    5              0.000025   unlet! b:airline_whitespace_check
    5              0.000033   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
    5              0.000006   endif
    5              0.000035   let b:airline_ws_changedtick = b:changedtick

FUNCTION  airline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:229
Called 40 times
Total time:   0.002421
 Self time:   0.002421

count  total (s)   self (s)
   40              0.000585   let builder = copy(s:prototype)
   40              0.000173   let builder._context = a:context
   40              0.000148   let builder._sections = []

   40              0.001254   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   40              0.000104   return builder

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:34
Called 28 times
Total time:   0.004248
 Self time:   0.001866

count  total (s)   self (s)
   28   0.002185   0.000884   let summary = gitgutter#hunk#summary(a:bufnr)
   28              0.000135   let summary[1] += a:count
   28   0.001879   0.000799   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>129_is_input_waiting()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/vital/_easymotion/Over/Commandline/Base.vim:497
Called 15 times
Total time:   0.001130
 Self time:   0.001130

count  total (s)   self (s)
   15              0.001036 	let num = len(filter(copy(a:keymapping), 'stridx(v:key, a:input) == 0'))
   15              0.000079 	return num > 1 || (num == 1 && !has_key(a:keymapping, a:input))

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:5
Called 4 times
Total time:   0.001824
 Self time:   0.001371

count  total (s)   self (s)
    4   0.000269   0.000083   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    4   0.001549   0.001282   call s:reset_summary(a:bufnr)

FUNCTION  EasyMotion#highlight#add_highlight()
    Defined: ~/.vim/plugged/vim-easymotion/autoload/EasyMotion/highlight.vim:173
Called 15 times
Total time:   0.000443
 Self time:   0.000443

count  total (s)   self (s)
   15              0.000430     call add(s:h.ids[a:group], matchadd(a:group, a:re, s:priorities[a:group]))

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  335   1.552512   0.086947  airline#check_mode()
   35   1.434690   0.201629  airline#highlighter#highlight()
   51   1.279698   0.012160  <SNR>63_CursorHoldUpdate()
  200   1.104665   0.247679  162()
 3049   1.047088   0.487406  airline#highlighter#get_highlight()
 1865   1.041702   0.244402  airline#highlighter#exec()
  480   0.811917   0.019841  36()
  257   0.788891   0.033927  airline#extensions#branch#get_head()
  491   0.736318   0.059979  265()
  257   0.732788   0.030555  airline#extensions#branch#head()
  491   0.644544   0.166851  NERDTreeWebDevIconsRefreshListener()
  466   0.644528   0.049792  <SNR>91_exec_separator()
    4   0.643591   0.000156  coc#rpc#request()
    4   0.643383   0.493211  <SNR>20_request()
    2   0.640327   0.000066  <SNR>17_SyncAutocmd()
  257   0.555136   0.048084  <SNR>94_update_branch()
   18   0.546787   0.002962  airline#update_statusline()
  328   0.532735   0.370160  131()
12196   0.524996             <SNR>91_get_syn()
   40   0.516089   0.005044  <SNR>64_invoke_funcrefs()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
12196              0.524996  <SNR>91_get_syn()
    4   0.643383   0.493211  <SNR>20_request()
 3049   1.047088   0.487406  airline#highlighter#get_highlight()
  740   0.388139   0.371555  WebDevIconsGetFileTypeSymbol()
  328   0.532735   0.370160  131()
  200   1.104665   0.247679  162()
 1865   1.041702   0.244402  airline#highlighter#exec()
   35   1.434690   0.201629  airline#highlighter#highlight()
  265   0.252701   0.167042  fugitive#Find()
  491   0.644544   0.166851  NERDTreeWebDevIconsRefreshListener()
    2              0.149740  coc#util#echo_messages()
  241   0.249994   0.146276  airline#extensions#hunks#get_hunks()
  934   0.308031   0.135865  38()
   15   0.130496   0.129963  <SNR>141__redraw()
  257   0.145886   0.113063  <SNR>94_update_untracked()
  893   0.162581   0.095856  43()
  335   1.552512   0.086947  airline#check_mode()
  249   0.086729   0.084248  airline#extensions#fugitiveline#bufname()
 1865              0.082697  <SNR>91_CheckDefined()
  241   0.102531   0.072626  airline#extensions#whitespace#check()

